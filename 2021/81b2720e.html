<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RPG 游戏开发（12）触碰箱子获取金币 | 麦甜怪圈 Xiaomai Circle</title><meta name="author" content="小麦 Andrew Xiaomai"><meta name="copyright" content="小麦 Andrew Xiaomai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="这篇文章我们将继续完善箱子功能。但在此之前，我们需要在 Collidable 类和 Chest 类中增加一层 Collectible 类（原先是 Chest 类继承了 Collidable 类；现在是 Chest 类继承 Collectible 类，Collectible 类继承 Collidable 类）。因为之后会有一些物体是碰撞之后，被玩家捡起来的。 添加这层继承关系是因为，假如之后我们有武">
<meta property="og:type" content="article">
<meta property="og:title" content="RPG 游戏开发（12）触碰箱子获取金币">
<meta property="og:url" content="https://xiaomai.tootaio.com/2021/81b2720e.html">
<meta property="og:site_name" content="麦甜怪圈 Xiaomai Circle">
<meta property="og:description" content="这篇文章我们将继续完善箱子功能。但在此之前，我们需要在 Collidable 类和 Chest 类中增加一层 Collectible 类（原先是 Chest 类继承了 Collidable 类；现在是 Chest 类继承 Collectible 类，Collectible 类继承 Collidable 类）。因为之后会有一些物体是碰撞之后，被玩家捡起来的。 添加这层继承关系是因为，假如之后我们有武">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaomai.tootaio.com/Gallery/covers/Unity2020rpg2d.jpg">
<meta property="article:published_time" content="2021-08-14T02:37:38.000Z">
<meta property="article:modified_time" content="2021-08-14T02:37:38.000Z">
<meta property="article:author" content="小麦 Andrew Xiaomai">
<meta property="article:tag" content="Unity 游戏开发">
<meta property="article:tag" content="RPG 游戏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaomai.tootaio.com/Gallery/covers/Unity2020rpg2d.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RPG 游戏开发（12）触碰箱子获取金币",
  "url": "https://xiaomai.tootaio.com/2021/81b2720e.html",
  "image": "https://xiaomai.tootaio.com/Gallery/covers/Unity2020rpg2d.jpg",
  "datePublished": "2021-08-14T02:37:38.000Z",
  "dateModified": "2021-08-14T02:37:38.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "小麦 Andrew Xiaomai",
      "url": "https://xiaomai.tootaio.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://xiaomai.tootaio.com/2021/81b2720e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小麦 Andrew Xiaomai","link":"链接: ","source":"来源: 麦甜怪圈 Xiaomai Circle","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPG 游戏开发（12）触碰箱子获取金币',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://at.alicdn.com/t/c/font_4366094_hx3hbrje2st.css"><script defer src="https://umami.tootaio.com/script.js" data-website-id="0a4aaffe-9809-4b7b-ad31-81bee68b29fc"></script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="麦甜怪圈 Xiaomai Circle" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="麦甜怪圈 Xiaomai Circle" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Gallery/notion-avatar-1703138102056.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post type-Unity2020" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Gallery/covers/Unity2020rpg2d.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Gallery/logos/Logo-11.jpg" alt="Logo"><span class="site-name">麦甜怪圈 Xiaomai Circle</span></a><a class="nav-page-title" href="/"><span class="site-name">RPG 游戏开发（12）触碰箱子获取金币</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RPG 游戏开发（12）触碰箱子获取金币</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-14T02:37:38.000Z" title="发表于 2021-08-14 10:37:38">2021-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-14T02:37:38.000Z" title="更新于 2021-08-14 10:37:38">2021-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E5%88%97/">系列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-Sharp/">C-Sharp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E5%88%97/Unity-2020-%E5%BC%80%E5%8F%91%E5%9C%B0%E7%89%A2%E6%8E%A2%E9%99%A9%E7%B1%BB%E6%B8%B8%E6%88%8F/">Unity 2020 开发地牢探险类游戏</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>4分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天未被更新了，可能里边的内容已经过时，请注意斟酌。&quot;,&quot;postUpdate&quot;:&quot;2021-08-14 10:37:38&quot;}" hidden></div><link rel="stylesheet external nofollow noreferrer" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章我们将继续完善箱子功能。但在此之前，我们需要在 Collidable 类和 Chest 类中增加一层 Collectible 类（原先是 Chest 类继承了 Collidable 类；现在是 Chest 类继承 Collectible 类，Collectible 类继承 Collidable 类）。因为之后会有一些物体是碰撞之后，被玩家捡起来的。</p>
<p>添加这层继承关系是因为，假如之后我们有武器了，当武器挥动的时候，应该是碰撞（Collidable）处理而非获取（Collectible）处理。而箱子则是获取（Collectable）处理。</p>
<p>所以，修改之后代码如下：</p>
<p>Chest.cs</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(collider.name + <span class="string">&quot;This is called from Chest.cs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Collectable.cs</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collectable</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Collectable-类"><a href="#Collectable-类" class="headerlink" title="Collectable 类"></a>Collectable 类</h2><p>接下来，我们要修改 Collectable.cs 的代码。因为是继承了 Collidible 类，所以我们覆盖重写 OnCollide 函数。它需要判断碰撞对象是否为玩家，如果是的话，则将 collected 设置为 true。</p>
<p>这里的 collected 的修饰符是 protected。该修饰符只能允许自己和自己的子类访问，别人是无法访问的。</p>
<p>所以现在知道的概念是：当这个物品被玩家触碰之后，它可以被拾取。至于怎么样被拾取（拾取之后获得什么，或者该物件有什么外观上的变化），则通过继承该类的子类进行定义。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collectable</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span> collected; <span class="comment">// protected 修饰符只能让自己和儿子访问</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当触碰的对象是玩家</span></span><br><span class="line">        <span class="keyword">if</span>(collider.name == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OnCollect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        collected = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，我们通过判断碰撞对象的名字是否为 Player 来检测对方是否为玩家，所以回到我们的 Unity，在 Hierarchy 面板中选中 player_0 然后将其重命名为 Player。</p>
<h2 id="Chest-类"><a href="#Chest-类" class="headerlink" title="Chest 类"></a>Chest 类</h2><p>所以现在我们知道，Chest 类继承了 Collectable 类，用人话来说，就是他是能够被拾取的。所以原先我们覆盖重写的是 OnCollide 函数，现在将其删掉，替换为 OnCollect 函数。意味着<strong>当被捡起来时</strong>该干嘛干嘛。</p>
<p>这次重写 OnCollect 函数，我们保留了 base.OnCollect() 函数的调用。这是因为父类（Collectable 类）里这个函数将 collected（判断是否被捡起来的布尔值）设置为 true。当然，如果你觉得代码可读性降低了的话，你也可以删除 base.OnCollect() 函数，然后替换为 collected = true 语句。</p>
<p>在这里的 OnCollect 函数，首先我们要判断这件物品是否没被获取过，如果没被获取过，则才可以被获取。那么对于箱子，我们原本的图片箱子是装满了金币的，当玩家触碰之后，金币将会被获取，而箱子变为空的。</p>
<p>所以我们声明一个 Sprite 对象，这个对象用于保存空箱子的图片。然后再声明一个 int 数值，记录宝箱中拥有的金币数量。这两个变量的修饰符都是 public，所以你可以再 Inspector 面板中直接进行修改。</p>
<p>在 OnCollect 函数里，我们获取 SpriteRenderer 组件（你打开 Inspector 面板就会看到其实图片就是被这个组件渲染上去的），然后将它的 sprite 属性改为上面定义的 Sprite 对象。</p>
<p>我们再用 Debug.Log 函数暂时输出“玩家获取了多少金币”这个信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Sprite emptyChest; <span class="comment">// 空箱子的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> goldAmount = <span class="number">10</span>; <span class="comment">// 箱子里拥有的金币</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!collected) <span class="comment">// 当还未被拾取</span></span><br><span class="line">        &#123;</span><br><span class="line">            collected = <span class="literal">true</span>;</span><br><span class="line">            GetComponent&lt;SpriteRenderer&gt;().sprite = emptyChest;</span><br><span class="line">            Debug.Log(<span class="string">&quot;获得了&quot;</span> + goldAmount + <span class="string">&quot;金币！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 Unity 界面，我们从 Artwork 文件夹中的 Atlas 图集里找到 chest_1 图片（这是我们之前裁剪好的空箱子），在 Hierarchy 面板中选中 chest_0，然后把 chest_1 图片长按拖曳到 Inspector 面板中的 Empty Chest 栏里。或者点击 Inspector 面板中，Empty Chest 右侧的小圆圈，可以直接选择所需的图片。</p>
<p>所以按照上面的代码逻辑，当玩家碰撞到这个箱子，则会触发，图片将会替换为 emptyChest 我们赋值的图片，然后显示信息“获得了xx金币！”。</p>
<p><img src="/uploads/unity2020-rpg/20210814%20Chest%20Obtain.png"/></p>
<p>我们可以将 chest_0 命名为 Chest（规范命名），然后将其从 Hierarchy 面板中直接拖曳到 Project 面板中的 Prefabs 文件夹里。这样我们就能直接从 Prefabs 文件夹拖曳出来到游戏场景，从而生成多个箱子。Prefab 就是预制件，也就是已经提前设定好的游戏物件。</p>
<p>当然，拖出来的每个箱子也能有自己所拥有的金币。</p>
<p><img src="/uploads/unity2020-rpg/20210814%20Multiple%20Chests.png"/></p>
<p>那么本章就学到这里。今天就学会了怎么和地图上的物件进行交互。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiaomai.tootaio.com">小麦 Andrew Xiaomai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiaomai.tootaio.com/2021/81b2720e.html">https://xiaomai.tootaio.com/2021/81b2720e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiaomai.tootaio.com" target="_blank">麦甜怪圈 Xiaomai Circle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">Unity 游戏开发</a><a class="post-meta__tags" href="/tags/RPG-%E6%B8%B8%E6%88%8F/">RPG 游戏</a></div><div class="post-share"><div class="social-share" data-image="/Gallery/covers/Unity2020rpg2d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>欢迎打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/Gallery/wallets/WechatPaySquare.jpg" target="_blank"><img class="post-qr-code-img" src="/Gallery/wallets/WechatPaySquare.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/Gallery/wallets/AlipaySquare.jpg" target="_blank"><img class="post-qr-code-img" src="/Gallery/wallets/AlipaySquare.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/f1cc100.html" title="RPG 游戏开发（11）CSharp 继承"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RPG 游戏开发（11）CSharp 继承</div></div><div class="info-2"><div class="info-item-1">大家好啊，上个文章我们做了个基本的碰撞触发事件，但是只是输出了个 Debug.Log 那么这一章我们将详细地说怎么去实现一些效果，比如打开箱子获得物品。 那么首先我们就需要到我们的 Atlas 图块里把箱子的像素图切出来。打开 Sprite Editor，开始干活！首先，我们把之前弄好的褐色木箱子改名为 crate，而找到宝箱，他有六个图，我们选两个（一个空的，一个满的）使用即可。将满的命名为 chest_0，另一个为 1。裁剪好了之后点击 Apply。          然后将 chest_0 图块从 Project 面板拖到游戏场景 Scene 中随便一个位置（注意，不要贴着墙壁，因为墙面有 Collider 演示的时候会造成混淆），这时候你会发现只有一个框框，宝箱没看见。这是因为它的 Sorting Layer 在 Default，被地板当着了，所以我们新建一个 Sorting Layer 命名为 Interactable，将他的位置放在 Floor 和 Actor 之间，也就是在视觉效果里，看见该箱子在地板之上，在角色之下。 我们给 chest_0 添加一个 BoxCol...</div></div></div></a><a class="pagination-related" href="/2021/9e393d82.html" title="RPG 游戏开发（13）传送门"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RPG 游戏开发（13）传送门</div></div><div class="info-2"><div class="info-item-1">哈喽大家好，还记得我们在设计第一个地图（有箱子的那个）时画了个凸起的地方吧？这次我们会在那里放置一块碰撞体，当玩家走过去之后，将会被传送到 Dungeon1 场景。 我们在 SampleScene 的 Hierarchy 面板中，右键创建一个 Game Object 并命名为 Portal（传送门），给其新增 BoxCollider2D 组件，调整它的位置。强迫症，所以我将这个 GameObject 的位置修改为 X = 0，Y = 1.36，Collider 的 Offset 设置为 0，Size 为 0.48 和 0.16，都是 8 和 16 的倍数。  创建一个新的脚本（Script），命名为 Portal，然后将其拖拽到我们刚刚创建的 Game Object（Portal）里。双击编辑该脚本。因为是传送门，我们不需要从它这儿获取到什么东西。所以它的继承应该是 Collidable。 重写 OnCollide 方法。我们要实现的逻辑是，当玩家踏入这个区域时，随机传送到一个地牢里。 定义一个字符串数组，里边保存了需要传送的场景名称。在 OnCollide 函数里，当玩家碰撞到...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/db6458d9.html" title="RPG 游戏开发（19）准备武器"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="info-item-2">RPG 游戏开发（19）准备武器</div></div><div class="info-2"><div class="info-item-1">欢迎来到第六部分！重头戏！！！战斗系统。 首先，我们需要裁剪所需的武器图片素材  裁剪之后，点击 Apply。在 Project 面板中，我们把 weapon_0 拖曳到 Hierarchy 面板中 Player 下。使其属于 Player 游戏物件的子物件。然后在 weapon_0 的 Inspector 面板中，增加一个新的 Sorting Layer。 我们调整一下武器的位置。注意，由于武器的父组件是玩家，所以武器的位置是相对于玩家的（也就是说 0, 0 的位置是在玩家正中央）。我们将位置和大小做调整：Position x = 0.064，y = 0.08；Scale x&amp;y = 0.7。然后我们可以运行游戏，当玩家两面走动的时候，武器会随着玩家的朝向变动。 然后我们给 weapon_0 加上 BoxCollider2D，再创建一个 Weapon 脚本，它继承了 Collidable 类，武器也需要检测碰撞。 我们声明几个变量，变量用途都写在注释上了。升级系统需要获取武器的 SpriteRenderer 是因为我们要给其改变不同的武器样式（更换图片）。挥动武器有冷却...</div></div></div></a><a class="pagination-related" href="/2021/7ac9d386.html" title="RPG 游戏开发（18）文字系统 3"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="info-item-2">RPG 游戏开发（18）文字系统 3</div></div><div class="info-2"><div class="info-item-1">我们回到 GameManager 类，才参考对象那里加上一个新的 FloatingTextManager。因为显示文字的函数会被游戏中的各种元素调用（箱子、NPC、怪物……），我们不想在每个地方都有一个 reference 所以统一在 GameManager 设置它。 // 参考对象public Player player;public FloatingTextManager floatingTextManager; 然后我们在 GameManager 类里新建一个函数 ShowText（创建函数的位置和 SaveState 函数同级），参数列表和 FloatingTextManager 的 Show 函数一致。然后调用 floatingTextManager 的 Show 函数，将所有参数值传递进去。 /* * 显示浮动文字 */public void ShowText(string message, int fontSize, Color color, Vector3 position, Vector3 motion, float duration)&#123;    flo...</div></div></div></a><a class="pagination-related" href="/2021/fbb14778.html" title="RPG 游戏开发（17）文字系统 2"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-16</div><div class="info-item-2">RPG 游戏开发（17）文字系统 2</div></div><div class="info-2"><div class="info-item-1">这是文字系统的第二部分，这一部分，我们将创建一个 GameObject 包含一个 Manager 脚本，用来负责我们所有地图上的文字。 创建一个新的脚本 FloatingTextManager。这个类需要有一个包含了所有 FloatingText 的列表，所以这堆 FloatingText 可以作为对象池重复使用。每次重复使用的时候，我们需要修改文字内容、颜色、位置等其他属性。 我们需要定义两个成员变量，类型为 GameObject。textPrefab 是文字组件的预制件，用于之后在对象池里生成这个组件（我们过后就好像复制 textPrefab 在游戏界面中）。textContainer 是所有文字组件的父级组件。 然后再有一个保存 FloatingText 类型的列表，这就是我们的对象池。 接下来准备一个函数 GetFloatingText，这个函数用于从对象池里找到未被激活（未使用）的 FloatingText。如果找不到，或者说对象池为空，那么就创建一个新的 FloatingText。新的 FloatingText 的 GameObject 就是文字预制件（textPre...</div></div></div></a><a class="pagination-related" href="/2021/8deaa023.html" title="RPG 游戏开发（16）文字系统 1"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-16</div><div class="info-item-2">RPG 游戏开发（16）文字系统 1</div></div><div class="info-2"><div class="info-item-1">欢迎来到第五部分——文字系统。在这个部分，我们将会实现一个悬浮文字。大概说一下这个部分的学习内容：  对象池：这是一种设计模式，因为我们有多个文字需要显示，所以在每次显示一个文字都创建一个 Game Object 再销毁，对系统性能消耗挺高。所以我们将创建几个 Game Object，当需要显示文字的时候，就激活这个 Game Object 让它显示在屏幕上，否则就让它休眠。  文字系统需要比较多的逻辑：  需要显示的文字 被激活了没 显示在界面上的时长 显示在界面上的位置 有没有动画效果 字体颜色和字形  所以我们需要创建一个新的脚本，用于编写文字的逻辑代码。脚本名称为 FloatingText。这个脚本是专注于文字的逻辑类代码。 编辑代码，这次我们不需要继承 MonoBehavior 类。首先我们引用 UnityEngine.UI 命名空间（using 语句）。然后里边定义六个成员变量（变量用途我都写在代码注释了）。 然后我们定义两个函数，Show 和 Hide，Show 显示函数将 isActive 设置为 true，然后更新 lastShown 时间，最后再把该 game...</div></div></div></a><a class="pagination-related" href="/2021/5fb51f82.html" title="RPG 游戏开发（15）PlayerPrefs"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="info-item-2">RPG 游戏开发（15）PlayerPrefs</div></div><div class="info-2"><div class="info-item-1">上篇文章，我们写好了 GameManager 的基础架构，然后今天我们来完善 SaveState 和 LoadState 函数。 Awake 函数首先我们修改一下 Awake 函数，在 Awake 调用的时候，需要判断 instance（也就是 GameManager 对象）如果不是空的，则删除该 GameObject，然后直接跳出函数。如果是空的，则将这个 GameManager 对象指向 instance 变量（就是上章说的自己指向自己）。 为什么判断 GameManager 对象是否为空？因为如果我们回到同一场景（比如说从 Main 去到 Dungeon1 再回到 Main），这样就会出现两个 GameManager 了。所以我们需要判断，如果 instance 不为空，就代表已经有一个 GameManager 存在，那么就删掉这个新的冲突的 GameManager。 还有一种解决方式是：我们将这个 GameManager 提取出来单独放在一个 Scene 里（比如说加载界面）而这个 Scene 只会被调用一次。那么就能解决这个BUG。 引用 UnityEngine.Sce...</div></div></div></a><a class="pagination-related" href="/2021/235e0781.html" title="RPG 游戏开发（14）GameManager"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="info-item-2">RPG 游戏开发（14）GameManager</div></div><div class="info-2"><div class="info-item-1">前面三个部分，我们已经把游戏的基本内容做好了（角色移动、场景设计、碰撞触发某些功能）。现在，我们需要给游戏打上地基，让游戏可以保存玩家信息——金币、经验值、武器等…… 那么我们在 Scripts 文件夹里创建一个新的脚本 GameManager，Unity 默认会将此脚本的图标变更为齿轮状。双击编辑它。首先，我们定义一个 instance 变量，类型是 GameManager（也就是我们现在创建的脚本），修饰符为 public static。修饰符是 static，这意味着这个变量是全局的。我可以在任何一个类访问 GameManager.instance 来访问到这个 GameManager 我们让游戏的 GameManager 自己获取自己，所以重写 Awake 函数，内容是 instance = this。意味着这个类的 instance 对象指向他自己。 using UnityEngine;public class GameManager : MonoBehaviour&#123;    public static GameManager instance;    priv...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Gallery/notion-avatar-1703138102056.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">小麦 Andrew Xiaomai</div><div class="author-info-description">一个喜欢肉鸽类游戏的程序员<br>分享日常生活，学习笔记，技术文章等。感兴趣想一起开发游戏的欢迎联系我哟！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">69</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">49</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kingsmai"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kingsmai" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="iconfont icon-GitHub" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/670118055" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="iconfont icon-bilibili-fill" style="color: #ff6699;"></i></a><a class="social-icon" href="mailto:xsbugh@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="iconfont icon-email-fill" style="color: #ff3e30;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/creeper0924" rel="external nofollow noreferrer" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu" style="color: #1772F6;"></i></a><a class="social-icon" href="https://blog.csdn.net/Xsbugh" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="iconfont icon-csdn" style="color: #FC4144;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/%E5%B0%8F%E9%BA%A6-xiaomai-0a672124b/" rel="external nofollow noreferrer" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin" style="color: #0A66C2;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS 链接"><i class="iconfont icon-Atom" style="color: #6EA3E5;"></i></a><a class="social-icon" href="/rss2.xml" target="_blank" title="RSS 链接"><i class="iconfont icon-dingyue" style="color: #ee802f;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collectable-%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Collectable 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chest-%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Chest 类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/a3c435dc.html" title="如何优雅地整理 Git 分支历史：从混乱到清晰"><img src="/Gallery/covers/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E6%95%B4%E7%90%86%20Git%20%E5%88%86%E6%94%AF%E5%8E%86%E5%8F%B2%EF%BC%9A%E4%BB%8E%E6%B7%B7%E4%B9%B1%E5%88%B0%E6%B8%85%E6%99%B0.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何优雅地整理 Git 分支历史：从混乱到清晰"/></a><div class="content"><a class="title" href="/2025/a3c435dc.html" title="如何优雅地整理 Git 分支历史：从混乱到清晰">如何优雅地整理 Git 分支历史：从混乱到清晰</a><time datetime="2025-09-20T00:33:25.000Z" title="发表于 2025-09-20 08:33:25">2025-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/5a564e54.html" title="使用 Cloudflare Tunnel 将家里服务器映射到公网"><img src="/Gallery/covers/%E4%BD%BF%E7%94%A8%20Cloudflare%20Tunnel%20%E5%B0%86%E5%AE%B6%E9%87%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%A0%E5%B0%84%E5%88%B0%E5%85%AC%E7%BD%91%20%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2%E5%9B%BE.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 Cloudflare Tunnel 将家里服务器映射到公网"/></a><div class="content"><a class="title" href="/2025/5a564e54.html" title="使用 Cloudflare Tunnel 将家里服务器映射到公网">使用 Cloudflare Tunnel 将家里服务器映射到公网</a><time datetime="2025-09-11T17:19:00.000Z" title="发表于 2025-09-12 01:19:00">2025-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/91b8a59.html" title="Springboot JavaEE @Resource 注解解释"><img src="/Gallery/covers/Explaination%20of%20@Resource%20annotation%20in%20JavaEE.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot JavaEE @Resource 注解解释"/></a><div class="content"><a class="title" href="/2024/91b8a59.html" title="Springboot JavaEE @Resource 注解解释">Springboot JavaEE @Resource 注解解释</a><time datetime="2024-09-30T06:51:30.000Z" title="发表于 2024-09-30 14:51:30">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/8aef8f58.html" title="Springboot Spring @Component 注解解释"><img src="/Gallery/covers/Explaination%20of%20@Component%20annotation%20in%20SpringBoot.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot Spring @Component 注解解释"/></a><div class="content"><a class="title" href="/2024/8aef8f58.html" title="Springboot Spring @Component 注解解释">Springboot Spring @Component 注解解释</a><time datetime="2024-09-30T06:50:43.000Z" title="发表于 2024-09-30 14:50:43">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/d207740e.html" title="Springboot Spring Security 的基础解释"><img src="/Gallery/covers/Basic%20Explaination%20of%20Spring%20Security%20Configuration.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot Spring Security 的基础解释"/></a><div class="content"><a class="title" href="/2024/d207740e.html" title="Springboot Spring Security 的基础解释">Springboot Spring Security 的基础解释</a><time datetime="2024-09-30T06:47:09.000Z" title="发表于 2024-09-30 14:47:09">2024-09-30</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 小麦 Andrew Xiaomai</span></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20235160" rel="external nofollow noreferrer" target="_blank"><img class="icp-icon" src="/Gallery/moe-icons/icon120.png">备案号：✮萌ICP备20235160号✮</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>