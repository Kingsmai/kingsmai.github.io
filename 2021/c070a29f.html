<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测 | 麦甜怪圈 Xiaomai Circle</title><meta name="author" content="小麦 Andrew Xiaomai"><meta name="copyright" content="小麦 Andrew Xiaomai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="首先，我们将 Atlas 素材里一开始我们准备好的 player_1 素材拖曳到 Hierarchy 面板。这时候就会产生第二个角色。我们在 Hierarchy 面板中选中刚刚加入的 player_1，然后在 Inspector 面板中，最顶端的 player_1 改为 Test_NPC。以区分他是玩家或是 NPC，然后我们将他的坐标（Position）的 X 轴修改为 -0.2，让他出现在玩家左">
<meta property="og:type" content="article">
<meta property="og:title" content="RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测">
<meta property="og:url" content="https://kingsmai.github.io/2021/c070a29f.html">
<meta property="og:site_name" content="麦甜怪圈 Xiaomai Circle">
<meta property="og:description" content="首先，我们将 Atlas 素材里一开始我们准备好的 player_1 素材拖曳到 Hierarchy 面板。这时候就会产生第二个角色。我们在 Hierarchy 面板中选中刚刚加入的 player_1，然后在 Inspector 面板中，最顶端的 player_1 改为 Test_NPC。以区分他是玩家或是 NPC，然后我们将他的坐标（Position）的 X 轴修改为 -0.2，让他出现在玩家左">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kingsmai.github.io/Gallery/covers/Unity2020rpg2d.jpg">
<meta property="article:published_time" content="2021-08-09T12:51:08.000Z">
<meta property="article:modified_time" content="2021-08-09T12:51:08.000Z">
<meta property="article:author" content="小麦 Andrew Xiaomai">
<meta property="article:tag" content="Unity 游戏开发">
<meta property="article:tag" content="RPG 游戏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kingsmai.github.io/Gallery/covers/Unity2020rpg2d.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测",
  "url": "https://kingsmai.github.io/2021/c070a29f.html",
  "image": "https://kingsmai.github.io/Gallery/covers/Unity2020rpg2d.jpg",
  "datePublished": "2021-08-09T12:51:08.000Z",
  "dateModified": "2021-08-09T12:51:08.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "小麦 Andrew Xiaomai",
      "url": "https://kingsmai.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://kingsmai.github.io/2021/c070a29f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小麦 Andrew Xiaomai","link":"链接: ","source":"来源: 麦甜怪圈 Xiaomai Circle","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://at.alicdn.com/t/c/font_4366094_hx3hbrje2st.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="麦甜怪圈 Xiaomai Circle" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="麦甜怪圈 Xiaomai Circle" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/Gallery/notion-avatar-1703138102056.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post type-Unity2020" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/Gallery/covers/Unity2020rpg2d.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/Gallery/logos/Logo-11.jpg" alt="Logo"><span class="site-name">麦甜怪圈 Xiaomai Circle</span></a><a class="nav-page-title" href="/"><span class="site-name">RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-image"></i><span> 图片</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-09T12:51:08.000Z" title="发表于 2021-08-09 20:51:08">2021-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-09T12:51:08.000Z" title="更新于 2021-08-09 20:51:08">2021-08-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E5%88%97/">系列</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-Sharp/">C-Sharp</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E5%88%97/Unity-2020-%E5%BC%80%E5%8F%91%E5%9C%B0%E7%89%A2%E6%8E%A2%E9%99%A9%E7%B1%BB%E6%B8%B8%E6%88%8F/">Unity 2020 开发地牢探险类游戏</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天未被更新了，可能里边的内容已经过时，请注意斟酌。&quot;,&quot;postUpdate&quot;:&quot;2021-08-09 20:51:08&quot;}" hidden></div><link rel="stylesheet external nofollow noreferrer" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先，我们将 Atlas 素材里一开始我们准备好的 player_1 素材拖曳到 Hierarchy 面板。这时候就会产生第二个角色。我们在 Hierarchy 面板中选中刚刚加入的 player_1，然后在 Inspector 面板中，最顶端的 player_1 改为 Test_NPC。以区分他是玩家或是 NPC，然后我们将他的坐标（Position）的 X 轴修改为 -0.2，让他出现在玩家左侧。</p>
<p>接下来，在 Inspector 面板中，点击 Add Component 按钮，添加一个 BoxCollider2D 元件，该元件就是用来检测物体碰撞，碰撞包括：触碰到NPC和其对话、触碰到怪物造成伤害、触碰到墙体无法继续前进等等。调整框的大小，这里我选择和我的玩家一样。 调整参数为：Offset X: 0, Y: -0.01，Size X: 0.1, Y: 0.1</p>
<p><img src="/uploads/unity2020-rpg/20210808%20Create%20NPC.png"/></p>
<h2 id="制作地板"><a href="#制作地板" class="headerlink" title="制作地板"></a>制作地板</h2><p>我们点击 Atlas，然后在 Inspector 面板中点击 Sprite Editor。我们找到两个合适的图标作为地板和墙体。我选择了深色的块作为墙壁，并将其命名为 wall_0；然后选择另一个较为浅色的块作为地板，将其命名为 floor_0。切割完毕之后，点击 Apply，这时候发现 Atlas 图集的小箭头多出了两个图标。</p>
<div style="display: flex; justify-content: space-between;">
  <img src="/uploads/unity2020-rpg/20210808%20Wall%20Sprite.png"/>
  <img src="/uploads/unity2020-rpg/20210808%20Floor%20Sprite.png"/>
</div>

<p>当我们将 floor_0 图块直接拖拽到 Hierarchy 面板上，默认他会出现在原点（x = 0, y = 0），也就是我们玩家的位置。这时候你会发现，我们的玩家被这个图块挡住了。</p>
<h2 id="修改渲染图层"><a href="#修改渲染图层" class="headerlink" title="修改渲染图层"></a>修改渲染图层</h2><p>为了解决这个问题，我们需要知道一个概念：图层。在 Hierarchy 面板选择 player_0，在 Inspector 面板定位到 Sprite Renderer 元件的 Sorting Layer 项（如果没有这个属性，则是隐藏在 Additional Layer 里）点开下拉框，然后点击 Add Sorting Layer。这时候 Inspector 面板将会跳转至 Tags &amp; Layer，并且展开 Sorting Layers 属性列。</p>
<p>在 Sorting Layer 点击右侧的 ＋ 号，新建一个图层 Actor（角色）。添加完毕后，我们再点击 Hierarchy 面板中的 player_0，再找到 Inspector 面板里的 Sorting Layer。点开下拉框选择刚刚添加的 Actor，然后你的 玩家就会出现在地板前面了！</p>
<p>同理，对 NPC 也要执行同样的操作。</p>
<p><img src="/uploads/unity2020-rpg/20210808%20Sorting%20Layer.png"/></p>
<p>接下来，我们需要再继续复制粘贴几个地板，然后再把墙壁放上去。结果大概这样（如果你有强迫症，每个区块之间的间隔为0.16）我们现在用比较笨的方法去弄这个，后续将会使用 Tile Palette 功能进行地图绘制。</p>
<p><img src="/uploads/unity2020-rpg/20210808%20Simple%20Map.png"/></p>
<h2 id="碰撞的概念"><a href="#碰撞的概念" class="headerlink" title="碰撞的概念"></a>碰撞的概念</h2><p>首先我们要知道几个需求，地板是没有 BoxCollider 的，所以不被考虑在内：</p>
<ol>
<li>玩家不可经过踩上去的地方（碰到这些，玩家会被阻拦）<ol>
<li>墙体</li>
<li>NPC</li>
</ol>
</li>
<li>玩家可以踩上去的地方（触发某些机制）<ol>
<li>开关</li>
<li>回复泉水</li>
<li>陷阱</li>
</ol>
</li>
</ol>
<p>所以，我们需要增加两个图层（Layer）。这和 Sorting Layer 是不同的，Sorting Layer 是关于渲染的层级关系，而 Layer 可以理解为一个组别，我们需要实现的是：当玩家碰上这些块的时候，会出现什么事情。</p>
<p>现在，我们选择 Hierarchy 界面的 wall_0 然后在 Inspector 界面的 Layer 下拉菜单中点击 Add Layer。我们在 User Layer 中依次添加 Blocking 和 Actor 层。</p>
<p><img src="/uploads/unity2020-rpg/20210808%20User%20Layer.png"/></p>
<p>点击 Hierarchy 面板中的 wall_0，然后按住 CTRL 选择 wall_1（可以多选）。如果某些需要选择的物体在 Hierarchy 面板中是连续的，可以直接长按 Shift 多选。然后 Layer 下拉菜单中选择 Blocking，这将作为我们玩家的障碍物。然后我们也要给他俩加上 BoxCollider2D 元件。</p>
<p><img src="/uploads/unity2020-rpg/20210808%20Wall%20Properties.png"/></p>
<p>之后再选择 player_0 和 Test_NPC，将 Layer 切换为刚刚创建的 Actor 层。</p>
<p>别担心，之后不会那么麻烦。我们会把这些琐碎的事情交给 Tilemap 来做，但是现在为了让大家理解原理，就先搞得麻烦一点。</p>
<p>有了碰撞体之后，还是不能阻止玩家经过的。我们需要让角色知道“哦，这是墙体，我不能穿过去”。那要让角色知道的事情，就需要用代码来完成了。</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>碰撞检测的编程思路是这样的：我们需要在移动的时候，往移动的方向前方投影一个看不见的方块，如果这个方块检测到障碍物，那么人物就不能向前移动。</p>
<p>所以我们需要声明 RaycastHit2D hit; 变量来检测。</p>
<p>我们在之前朝向切换和开始移动之间写上一段代码，具体位置在这里：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (moveDelta.x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    transform.localScale = Vector3.one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (moveDelta.x &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在这里添加新代码 <span class="doctag">///</span></span></span><br><span class="line"></span><br><span class="line">transform.translate(moveDelta * Time.DeltaTime);</span><br></pre></td></tr></table></figure>
<p>然后我们说到，RaycastHit2D 的作用是放置一个投影，用于检测前方是否有障碍物，所以我们调用 <code>Physic2D.BoxCast()</code> 函数，创建一个投影块。具体检测两个轴，x 和 y。我们先检测 y 轴（上下），BoxCast() 函数需要传递 6 个参数，分别是：</p>
<ol>
<li>投影块要出现的位置：角色的位置</li>
<li>投影块的大小：角色的 BoxCollider2D 的大小</li>
<li>角度：角色移动不需要角度，所以传递 0</li>
<li>方向：所需要计算的方向（这里只能计算一个轴的方向（上下、左右））。它的计算判断应该是取 x y 轴的点，然后算与原点的角度。</li>
<li>投影块的距离：我们传递绝对值，这样不管是向左走（-1）还是向右走（1）都能为 1</li>
<li>需要检测的碰撞体所在图层：检测 Blocking 和 Actor 层</li>
</ol>
<p>当检测的投影块碰撞（collider）为空，则可以移动。代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">hit = Physics2D.BoxCast(</span><br><span class="line">    transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">    boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">    <span class="keyword">new</span> Vector2(<span class="number">0</span>, moveDelta.y), <span class="comment">// 方向计算其中一个方向 moveDelta.y</span></span><br><span class="line">    Mathf.Abs(moveDelta.y * Time.deltaTime), <span class="comment">// 检测距离为我们需要移动的距离</span></span><br><span class="line">    LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果检测到空的</span></span><br><span class="line"><span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让他动起来</span></span><br><span class="line">    <span class="comment">// 因为我们只检测 y 轴，所以我们要修改为 y 轴</span></span><br><span class="line">    transform.Translate(<span class="number">0</span>, moveDelta.y * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，我们也需要给 x 轴有同样的操作：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">hit = Physics2D.BoxCast(</span><br><span class="line">    transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">    boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">    <span class="keyword">new</span> Vector2(moveDelta.x, <span class="number">0</span>), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">    Mathf.Abs(moveDelta.x * Time.deltaTime), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">    LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果检测到空的</span></span><br><span class="line"><span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为检测 x 轴，所以我们要修改为 x 轴</span></span><br><span class="line">    transform.Translate(moveDelta.x * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的完整代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D boxCollider;</span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDelta;</span><br><span class="line">    <span class="keyword">private</span> RaycastHit2D hit; <span class="comment">// 用于碰撞检测</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxCollider = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> x = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> y = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">        moveDelta = <span class="keyword">new</span> Vector3(x, y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (moveDelta.x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (moveDelta.x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">        hit = Physics2D.BoxCast(</span><br><span class="line">            transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">            boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">            <span class="keyword">new</span> Vector2(<span class="number">0</span>, moveDelta.y), <span class="comment">// 方向计算其中一个方向 moveDelta.y</span></span><br><span class="line">            Mathf.Abs(moveDelta.y * Time.deltaTime), <span class="comment">// 检测距离为我们需要移动的距离</span></span><br><span class="line">            LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果检测到空的</span></span><br><span class="line">        <span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 让他动起来</span></span><br><span class="line">            <span class="comment">// 因为我们只检测 y 轴，所以我们要修改为 y 轴</span></span><br><span class="line">            transform.Translate(<span class="number">0</span>, moveDelta.y * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        hit = Physics2D.BoxCast(</span><br><span class="line">            transform.position,</span><br><span class="line">            boxCollider.size,</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">            <span class="keyword">new</span> Vector2(moveDelta.x, <span class="number">0</span>), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">            Mathf.Abs(moveDelta.x * Time.deltaTime), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">            LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为我们检测 x 轴，所以我们要修改为 x 轴</span></span><br><span class="line">            transform.Translate(moveDelta.x * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测的时候，我们发现玩家居然完全不能移动，怎么回事？</p>
<p>因为我们检测的是 Blocking 层和 Actor 层、玩家也在 Actor 层里，所以他就检测自己，觉得“自己和自己碰撞了”。那需要解决这个问题，我们需要打开项目设置：Unity 左上角 Edit / Project Settings 然后弹出的对话框中左侧选择 Physic 2D。在右侧的属性列表中找到 Queries Start in Colliders，取消勾选。</p>
<p><img src="/uploads/unity2020-rpg/20210808%20Physic2D%20Setting.png"/></p>
<p>设置结束后，运行游戏。可以发现玩家可以在地图上奔跑，然后遇到障碍物会停下了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://kingsmai.github.io">小麦 Andrew Xiaomai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kingsmai.github.io/2021/c070a29f.html">https://kingsmai.github.io/2021/c070a29f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kingsmai.github.io" target="_blank">麦甜怪圈 Xiaomai Circle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">Unity 游戏开发</a><a class="post-meta__tags" href="/tags/RPG-%E6%B8%B8%E6%88%8F/">RPG 游戏</a></div><div class="post-share"><div class="social-share" data-image="/Gallery/covers/Unity2020rpg2d.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>欢迎打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/Gallery/wallets/WechatPaySquare.jpg" target="_blank"><img class="post-qr-code-img" src="/Gallery/wallets/WechatPaySquare.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/Gallery/wallets/AlipaySquare.jpg" target="_blank"><img class="post-qr-code-img" src="/Gallery/wallets/AlipaySquare.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/c64e943e.html" title="RPG 游戏开发（3）角色移动"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">RPG 游戏开发（3）角色移动</div></div><div class="info-2"><div class="info-item-1">如果你是跟着上一篇文章来的，那么你的屏幕上应该有两个角色，我们先把 player_0 (1) 删掉，直接点击 Delete 键即可。 现在，我要让角色动起来。从这里开始，我们就会涉及到编程了。 不会编程的小伙伴不用担心，我会把所有代码清晰的复制粘贴到这里来。你们只需要理解每一行代码，并且给代码写上注释就行。方便以后你复习项目的时候，可以清楚的知道当初自己写了什么。 回到我们的 Hierarchy 界面，我们选中 player_0。然后在 Inspector 界面点击下方的 Add Component 按钮，添加新的元件。Unity 已经为我们准备了一大堆的元件库，但是现在我们需要创建新的元件（代码）。所以我们需要在元件库搜索框里输入 Player。然后列表会弹出两个元件，直接无视它，点击 New Script，然后点击 Create and Add 按钮。 这时候你就会发现 Project 面板的 Asset 目录下出现了一个文件：Player；并且你的 player_0 的 Inspector 面板也会出现一个 Player 的元件。如果没有的话，将刚刚创建的 Player 文...</div></div></div></a><a class="pagination-related" href="/2021/c86d9551.html" title="RPG 游戏开发（5）镜头跟随"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RPG 游戏开发（5）镜头跟随</div></div><div class="info-2"><div class="info-item-1">比起传统的镜头跟随，我更喜欢一种镜头 - 玩家在一定的范围里移动，镜头位置保持不变，当玩家超出该移动范围，则镜头开始追随玩家，直到玩家再次出现在限定的范围里。 点击 Main Camera 打开摄像头的 Inspector 界面，我们添加一个自定义脚本，命名为：CameraMotor，创建方法和创建 Player 脚本是一样的。然后我们将 Project 面板里的 CameraMotor 文件拖拽到 Scripts 文件夹里。 双击用 Visual Studio 打开 CameraMotor 源文件 删掉所有在 CameraMotor 类里面的函数（Start 和 Update），然后 ctrl + shift + m 打开 Unity 函数库，找到 LateUpdate 函数，点击添加。该函数在 Update 和 FixedUpdate 之后才被调用。因为我们需要在逻辑上让玩家先移动，镜头才跟随。这样不会让玩家产生奇怪的视觉效果。 在代码里，我们需要镜头跟随一个目标，所以我声明一个变量 public Transform lookAt; 将其修饰符写为 public，以便我们可以...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/db6458d9.html" title="RPG 游戏开发（19）准备武器"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="info-item-2">RPG 游戏开发（19）准备武器</div></div><div class="info-2"><div class="info-item-1">欢迎来到第六部分！重头戏！！！战斗系统。 首先，我们需要裁剪所需的武器图片素材  裁剪之后，点击 Apply。在 Project 面板中，我们把 weapon_0 拖曳到 Hierarchy 面板中 Player 下。使其属于 Player 游戏物件的子物件。然后在 weapon_0 的 Inspector 面板中，增加一个新的 Sorting Layer。 我们调整一下武器的位置。注意，由于武器的父组件是玩家，所以武器的位置是相对于玩家的（也就是说 0, 0 的位置是在玩家正中央）。我们将位置和大小做调整：Position x = 0.064，y = 0.08；Scale x&amp;y = 0.7。然后我们可以运行游戏，当玩家两面走动的时候，武器会随着玩家的朝向变动。 然后我们给 weapon_0 加上 BoxCollider2D，再创建一个 Weapon 脚本，它继承了 Collidable 类，武器也需要检测碰撞。 我们声明几个变量，变量用途都写在注释上了。升级系统需要获取武器的 SpriteRenderer 是因为我们要给其改变不同的武器样式（更换图片）。挥动武器有冷却...</div></div></div></a><a class="pagination-related" href="/2021/7ac9d386.html" title="RPG 游戏开发（18）文字系统 3"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="info-item-2">RPG 游戏开发（18）文字系统 3</div></div><div class="info-2"><div class="info-item-1">我们回到 GameManager 类，才参考对象那里加上一个新的 FloatingTextManager。因为显示文字的函数会被游戏中的各种元素调用（箱子、NPC、怪物……），我们不想在每个地方都有一个 reference 所以统一在 GameManager 设置它。 // 参考对象public Player player;public FloatingTextManager floatingTextManager; 然后我们在 GameManager 类里新建一个函数 ShowText（创建函数的位置和 SaveState 函数同级），参数列表和 FloatingTextManager 的 Show 函数一致。然后调用 floatingTextManager 的 Show 函数，将所有参数值传递进去。 /* * 显示浮动文字 */public void ShowText(string message, int fontSize, Color color, Vector3 position, Vector3 motion, float duration)&#123;    flo...</div></div></div></a><a class="pagination-related" href="/2021/fbb14778.html" title="RPG 游戏开发（17）文字系统 2"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-16</div><div class="info-item-2">RPG 游戏开发（17）文字系统 2</div></div><div class="info-2"><div class="info-item-1">这是文字系统的第二部分，这一部分，我们将创建一个 GameObject 包含一个 Manager 脚本，用来负责我们所有地图上的文字。 创建一个新的脚本 FloatingTextManager。这个类需要有一个包含了所有 FloatingText 的列表，所以这堆 FloatingText 可以作为对象池重复使用。每次重复使用的时候，我们需要修改文字内容、颜色、位置等其他属性。 我们需要定义两个成员变量，类型为 GameObject。textPrefab 是文字组件的预制件，用于之后在对象池里生成这个组件（我们过后就好像复制 textPrefab 在游戏界面中）。textContainer 是所有文字组件的父级组件。 然后再有一个保存 FloatingText 类型的列表，这就是我们的对象池。 接下来准备一个函数 GetFloatingText，这个函数用于从对象池里找到未被激活（未使用）的 FloatingText。如果找不到，或者说对象池为空，那么就创建一个新的 FloatingText。新的 FloatingText 的 GameObject 就是文字预制件（textPre...</div></div></div></a><a class="pagination-related" href="/2021/8deaa023.html" title="RPG 游戏开发（16）文字系统 1"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-16</div><div class="info-item-2">RPG 游戏开发（16）文字系统 1</div></div><div class="info-2"><div class="info-item-1">欢迎来到第五部分——文字系统。在这个部分，我们将会实现一个悬浮文字。大概说一下这个部分的学习内容：  对象池：这是一种设计模式，因为我们有多个文字需要显示，所以在每次显示一个文字都创建一个 Game Object 再销毁，对系统性能消耗挺高。所以我们将创建几个 Game Object，当需要显示文字的时候，就激活这个 Game Object 让它显示在屏幕上，否则就让它休眠。  文字系统需要比较多的逻辑：  需要显示的文字 被激活了没 显示在界面上的时长 显示在界面上的位置 有没有动画效果 字体颜色和字形  所以我们需要创建一个新的脚本，用于编写文字的逻辑代码。脚本名称为 FloatingText。这个脚本是专注于文字的逻辑类代码。 编辑代码，这次我们不需要继承 MonoBehavior 类。首先我们引用 UnityEngine.UI 命名空间（using 语句）。然后里边定义六个成员变量（变量用途我都写在代码注释了）。 然后我们定义两个函数，Show 和 Hide，Show 显示函数将 isActive 设置为 true，然后更新 lastShown 时间，最后再把该 game...</div></div></div></a><a class="pagination-related" href="/2021/5fb51f82.html" title="RPG 游戏开发（15）PlayerPrefs"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="info-item-2">RPG 游戏开发（15）PlayerPrefs</div></div><div class="info-2"><div class="info-item-1">上篇文章，我们写好了 GameManager 的基础架构，然后今天我们来完善 SaveState 和 LoadState 函数。 Awake 函数首先我们修改一下 Awake 函数，在 Awake 调用的时候，需要判断 instance（也就是 GameManager 对象）如果不是空的，则删除该 GameObject，然后直接跳出函数。如果是空的，则将这个 GameManager 对象指向 instance 变量（就是上章说的自己指向自己）。 为什么判断 GameManager 对象是否为空？因为如果我们回到同一场景（比如说从 Main 去到 Dungeon1 再回到 Main），这样就会出现两个 GameManager 了。所以我们需要判断，如果 instance 不为空，就代表已经有一个 GameManager 存在，那么就删掉这个新的冲突的 GameManager。 还有一种解决方式是：我们将这个 GameManager 提取出来单独放在一个 Scene 里（比如说加载界面）而这个 Scene 只会被调用一次。那么就能解决这个BUG。 引用 UnityEngine.Sce...</div></div></div></a><a class="pagination-related" href="/2021/235e0781.html" title="RPG 游戏开发（14）GameManager"><img class="cover" src="/Gallery/covers/Unity2020rpg2d.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-15</div><div class="info-item-2">RPG 游戏开发（14）GameManager</div></div><div class="info-2"><div class="info-item-1">前面三个部分，我们已经把游戏的基本内容做好了（角色移动、场景设计、碰撞触发某些功能）。现在，我们需要给游戏打上地基，让游戏可以保存玩家信息——金币、经验值、武器等…… 那么我们在 Scripts 文件夹里创建一个新的脚本 GameManager，Unity 默认会将此脚本的图标变更为齿轮状。双击编辑它。首先，我们定义一个 instance 变量，类型是 GameManager（也就是我们现在创建的脚本），修饰符为 public static。修饰符是 static，这意味着这个变量是全局的。我可以在任何一个类访问 GameManager.instance 来访问到这个 GameManager 我们让游戏的 GameManager 自己获取自己，所以重写 Awake 函数，内容是 instance = this。意味着这个类的 instance 对象指向他自己。 using UnityEngine;public class GameManager : MonoBehaviour&#123;    public static GameManager instance;    priv...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/Gallery/notion-avatar-1703138102056.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">小麦 Andrew Xiaomai</div><div class="author-info-description">一个喜欢肉鸽类游戏的程序员<br>分享日常生活，学习笔记，技术文章等。感兴趣想一起开发游戏的欢迎联系我哟！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kingsmai"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kingsmai" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="iconfont icon-GitHub" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/670118055" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><i class="iconfont icon-bilibili-fill" style="color: #ff6699;"></i></a><a class="social-icon" href="mailto:xsbugh@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="iconfont icon-email-fill" style="color: #ff3e30;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/creeper0924" rel="external nofollow noreferrer" target="_blank" title="Zhihu"><i class="iconfont icon-zhihu" style="color: #1772F6;"></i></a><a class="social-icon" href="https://blog.csdn.net/Xsbugh" rel="external nofollow noreferrer" target="_blank" title="CSDN"><i class="iconfont icon-csdn" style="color: #FC4144;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/%E5%B0%8F%E9%BA%A6-xiaomai-0a672124b/" rel="external nofollow noreferrer" target="_blank" title="LinkedIn"><i class="iconfont icon-linkedin" style="color: #0A66C2;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS 链接"><i class="iconfont icon-Atom" style="color: #6EA3E5;"></i></a><a class="social-icon" href="/rss2.xml" target="_blank" title="RSS 链接"><i class="iconfont icon-dingyue" style="color: #ee802f;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E5%9C%B0%E6%9D%BF"><span class="toc-number">1.</span> <span class="toc-text">制作地板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B8%B2%E6%9F%93%E5%9B%BE%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">修改渲染图层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">碰撞的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">编程</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/91b8a59.html" title="Springboot JavaEE @Resource 注解解释"><img src="/Gallery/covers/Explaination%20of%20@Resource%20annotation%20in%20JavaEE.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot JavaEE @Resource 注解解释"/></a><div class="content"><a class="title" href="/2024/91b8a59.html" title="Springboot JavaEE @Resource 注解解释">Springboot JavaEE @Resource 注解解释</a><time datetime="2024-09-30T06:51:30.000Z" title="发表于 2024-09-30 14:51:30">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/8aef8f58.html" title="Springboot Spring @Component 注解解释"><img src="/Gallery/covers/Explaination%20of%20@Component%20annotation%20in%20SpringBoot.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot Spring @Component 注解解释"/></a><div class="content"><a class="title" href="/2024/8aef8f58.html" title="Springboot Spring @Component 注解解释">Springboot Spring @Component 注解解释</a><time datetime="2024-09-30T06:50:43.000Z" title="发表于 2024-09-30 14:50:43">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/d207740e.html" title="Springboot Spring Security 的基础解释"><img src="/Gallery/covers/Basic%20Explaination%20of%20Spring%20Security%20Configuration.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot Spring Security 的基础解释"/></a><div class="content"><a class="title" href="/2024/d207740e.html" title="Springboot Spring Security 的基础解释">Springboot Spring Security 的基础解释</a><time datetime="2024-09-30T06:47:09.000Z" title="发表于 2024-09-30 14:47:09">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/195a7602.html" title="Springboot Spring @Configuration 和 @Bean 注解解释"><img src="/Gallery/covers/Explaination%20of%20@Configuration%20and%20@Bean%20annotation%20in%20SpringBoot.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Springboot Spring @Configuration 和 @Bean 注解解释"/></a><div class="content"><a class="title" href="/2024/195a7602.html" title="Springboot Spring @Configuration 和 @Bean 注解解释">Springboot Spring @Configuration 和 @Bean 注解解释</a><time datetime="2024-09-30T06:41:26.000Z" title="发表于 2024-09-30 14:41:26">2024-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/b89e24c9.html" title="The usage of Signal in Godot 4"><img src="/Gallery/covers/20240608-The-usage-of-Signal-in-Godot%204.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The usage of Signal in Godot 4"/></a><div class="content"><a class="title" href="/2024/b89e24c9.html" title="The usage of Signal in Godot 4">The usage of Signal in Godot 4</a><time datetime="2024-06-08T14:59:02.000Z" title="发表于 2024-06-08 22:59:02">2024-06-08</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 小麦 Andrew Xiaomai</span></div><div class="footer_custom_text"><a href="https://icp.gov.moe/?keyword=20235160" rel="external nofollow noreferrer" target="_blank"><img class="icp-icon" src="/Gallery/moe-icons/icon120.png">备案号：✮萌ICP备20235160号✮</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>