<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 Cloudflare Tunnel 将家里服务器映射到公网</title>
      <link href="/2025/5a564e54.html"/>
      <url>/2025/5a564e54.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>很多朋友买了域名之后，都希望能在公网安全访问自己家里的服务。传统做法需要公网 IP、端口转发、防火墙配置，甚至要考虑动态 IP 的问题。其实，借助 <strong>Cloudflare Tunnel（cloudflared）</strong>，我们可以绕过这些繁琐的步骤，让 Cloudflare 作为中转，把外网请求安全转发到家里的内网服务。</p><p>下面我整理了一份完整的教程，帮助你从零开始配置 Cloudflare Tunnel，并绑定到你购买的域名。</p><hr><h2 id="1-前置准备"><a href="#1-前置准备" class="headerlink" title="1. 前置准备"></a>1. 前置准备</h2><ul><li>一个 <strong>Cloudflare 账号</strong>，并将你购买的域名的 DNS 托管到 Cloudflare（即域名的 NS 指向 Cloudflare 提供的地址）。</li><li>家里的服务器一台，可以是 Linux / Windows / macOS。</li><li>服务器需要能访问外网（内网即可，不需要公网 IP）。</li></ul><hr><h2 id="2-安装-cloudflared"><a href="#2-安装-cloudflared" class="headerlink" title="2. 安装 cloudflared"></a>2. 安装 cloudflared</h2><p>以 Linux 为例，安装 cloudflared：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install cloudflared</span><br></pre></td></tr></table></figure><p>或使用 Cloudflare 官方安装包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -o cloudflared.deb</span><br><span class="line">sudo dpkg -i cloudflared.deb</span><br></pre></td></tr></table></figure><p>检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cloudflared --version</span><br></pre></td></tr></table></figure><hr><h2 id="3-登录-Cloudflare-并创建-Tunnel"><a href="#3-登录-Cloudflare-并创建-Tunnel" class="headerlink" title="3. 登录 Cloudflare 并创建 Tunnel"></a>3. 登录 Cloudflare 并创建 Tunnel</h2><p>在服务器运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cloudflared tunnel login</span><br></pre></td></tr></table></figure><p>这会打开浏览器，让你登录并选择授权的域名。完成后，cloudflared 会在 <code>~/.cloudflared/</code> 下生成认证文件 <code>cert.pem</code>。</p><p>接着创建一个隧道，例如命名为 <code>home-server</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cloudflared tunnel create home-server</span><br></pre></td></tr></table></figure><p>此时会生成一个唯一的隧道 UUID 文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.cloudflared/4c144478-8e47-4c94-b45a-015382745e29.json</span><br></pre></td></tr></table></figure><hr><h2 id="4-配置-Tunnel"><a href="#4-配置-Tunnel" class="headerlink" title="4. 配置 Tunnel"></a>4. 配置 Tunnel</h2><p>我们选择将配置迁移到系统目录 <code>/etc/cloudflared/</code>，这样可以避免路径冲突，更符合 Linux 系统服务的习惯。</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/cloudflared</span><br><span class="line">sudo <span class="built_in">cp</span> ~/.cloudflared/4c144478-8e47-4c94-b45a-015382745e29.json /etc/cloudflared/</span><br></pre></td></tr></table></figure><p>新建 <code>/etc/cloudflared/config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tunnel:</span> <span class="string">4c144478-8e47-4c94-b45a-015382745e29</span></span><br><span class="line"><span class="attr">credentials-file:</span> <span class="string">/etc/cloudflared/4c144478-8e47-4c94-b45a-015382745e29.json</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">myserver.example.com</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:3000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>tunnel</code>：就是你的隧道 UUID。</li><li><code>credentials-file</code>：对应刚才复制过来的 JSON 文件。</li><li><code>ingress</code>：定义域名与内网服务的映射关系。例如 <code>myserver.example.com</code> → 服务器本地的 <code>http://localhost:3000</code>。</li></ul><hr><h2 id="5-配置-Cloudflare-DNS"><a href="#5-配置-Cloudflare-DNS" class="headerlink" title="5. 配置 Cloudflare DNS"></a>5. 配置 Cloudflare DNS</h2><p>登录 Cloudflare Dashboard → 选择你的域名 → DNS 管理，添加一条记录：</p><ul><li>类型：<code>CNAME</code></li><li>名称：<code>myserver</code></li><li>目标：<code>&lt;tunnel-uuid&gt;.cfargotunnel.com</code></li><li>代理状态：开启（橙色小云 ☁️）</li></ul><p>这样外部访问 <code>myserver.example.com</code> 就会自动通过 Cloudflare Tunnel 转发到你的内网服务。</p><hr><h2 id="6-安装并启动服务"><a href="#6-安装并启动服务" class="headerlink" title="6. 安装并启动服务"></a>6. 安装并启动服务</h2><p>安装为 systemd 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cloudflared service install</span><br></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start cloudflared</span><br></pre></td></tr></table></figure><p>设置开机自启：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> cloudflared</span><br></pre></td></tr></table></figure><p>查看运行状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl status cloudflared</span><br></pre></td></tr></table></figure><hr><h2 id="7-多服务配置（可选）"><a href="#7-多服务配置（可选）" class="headerlink" title="7. 多服务配置（可选）"></a>7. 多服务配置（可选）</h2><p>如果你需要映射多个端口，可以直接扩展 <code>config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">app.example.com</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">ssh.example.com</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">ssh://localhost:22</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">service:</span> <span class="string">http_status:404</span></span><br></pre></td></tr></table></figure><p>这样不同子域名可以对应不同的服务：</p><ul><li><code>app.example.com</code> → 内网 8080 端口</li><li><code>ssh.example.com</code> → SSH 登录</li></ul><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>通过 Cloudflare Tunnel，我们实现了：</p><ul><li>无需公网 IP，即可将内网服务暴露到公网。</li><li>Cloudflare 提供安全加密的隧道，不需要自己配置复杂的防火墙规则。</li><li>支持多服务、多子域名的灵活映射。</li></ul><p>最终，我们把配置文件放在 <code>/etc/cloudflared/config.yml</code>，这样 cloudflared 服务可以稳定运行，并在系统启动时自动加载。</p><p>🎉 现在，你可以直接通过 <code>myserver.example.com</code> 来访问家里的服务了！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名, Tunnel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot JavaEE @Resource 注解解释</title>
      <link href="/2024/91b8a59.html"/>
      <url>/2024/91b8a59.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>@Resource</code> 是 Java EE（也称为 Jakarta EE）中的注解，但也可以用于 Spring 框架中来实现依赖注入。它主要用于标识依赖对象，并将该对象注入到类的字段、方法或构造函数中。</p><h3 id="与-Autowired-的区别"><a href="#与-Autowired-的区别" class="headerlink" title="与 @Autowired 的区别"></a>与 <code>@Autowired</code> 的区别</h3><p>在 Spring 中，<code>@Resource</code> 和 <code>@Autowired</code> 都可以用来实现依赖注入，但它们有以下区别：</p><ul><li><p><strong><code>@Resource</code> 来自 Java EE</strong>：</p><ul><li><code>@Resource</code> 注解源自 Java EE 规范（<code>javax.annotation.Resource</code>），它遵循 Java 的标准，兼容多个依赖注入框架。</li><li>它使用 <strong>by name</strong> 的方式进行注入。即优先按名称（通过字段名或属性名）查找 Bean 进行注入，如果找不到与名称匹配的 Bean，再根据类型查找。</li></ul></li><li><p><strong><code>@Autowired</code> 来自 Spring</strong>：</p><ul><li><code>@Autowired</code> 是 Spring 框架特有的注解，默认使用 <strong>by type</strong> 的方式进行注入，按类型匹配所需的依赖对象。</li><li>如果需要按名称注入，可以配合 <code>@Qualifier</code> 注解使用。</li></ul></li></ul><h3 id="Resource-的使用"><a href="#Resource-的使用" class="headerlink" title="@Resource 的使用"></a><code>@Resource</code> 的使用</h3><p><code>@Resource</code> 注解可以应用在字段、setter 方法、或构造函数上。它可以接受两个属性：</p><ul><li><code>name</code>：用于指定注入的 Bean 的名称。</li><li><code>type</code>：用于指定注入的 Bean 的类型。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><strong>按名称注入（默认方式）</strong>：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;  <span class="comment">// 按名称注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        myRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Spring 将根据字段名 <code>myRepository</code> 去 Spring 容器中查找同名的 Bean，并注入它。</p><ol><li><strong>使用 <code>name</code> 属性指定注入的 Bean 名称</strong>：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;customRepository&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;  <span class="comment">// 指定 Bean 名称注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        myRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，<code>@Resource(name = &quot;customRepository&quot;)</code> 明确指定了要注入的 Bean 的名称为 <code>customRepository</code>，Spring 会根据这个名称来注入相应的 Bean。</p><ol><li><strong>使用 <code>type</code> 属性按类型注入</strong>：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(type = MyRepository.class)</span></span><br><span class="line">    <span class="keyword">private</span> MyRepository myRepository;  <span class="comment">// 按类型注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performAction</span><span class="params">()</span> &#123;</span><br><span class="line">        myRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>type</code> 属性，明确按类型 <code>MyRepository</code> 进行注入，Spring 会根据类型匹配相应的 Bean。</p><h3 id="Resource-的工作流程"><a href="#Resource-的工作流程" class="headerlink" title="@Resource 的工作流程"></a><code>@Resource</code> 的工作流程</h3><ol><li><strong>按名称匹配</strong>：<code>@Resource</code> 首先根据属性名查找与之匹配的 Bean。</li><li><strong>按类型匹配</strong>：如果没有找到与名称匹配的 Bean，<code>@Resource</code> 则根据类型进行查找。</li><li><strong>注入</strong>：如果找到匹配的 Bean，则注入该 Bean；如果找不到，且没有设置 <code>required = false</code>，则会抛出异常。</li></ol><h3 id="何时使用-Resource"><a href="#何时使用-Resource" class="headerlink" title="何时使用 @Resource"></a>何时使用 <code>@Resource</code></h3><ul><li><strong>兼容性</strong>：如果你希望你的代码能够在 Spring 和 Java EE 之间保持较好的兼容性，<code>@Resource</code> 是一个更标准的选择。</li><li><strong>按名称注入</strong>：如果你需要通过名称来指定依赖，<code>@Resource</code> 可能会更加方便，因为它默认按名称注入，而不需要像 <code>@Autowired</code> 那样配合 <code>@Qualifier</code> 使用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>@Resource</code></strong> 是 Java EE 的注解，用于依赖注入，Spring 也支持该注解。</li><li><strong>默认按名称注入</strong>，如果没有找到名称匹配的 Bean，才按类型注入。</li><li><strong>适用场景</strong>：当你需要按名称注入或者希望代码兼容 Java EE 标准时，可以使用 <code>@Resource</code>。</li></ul><p>如果你还有其他问题或需要更多示例，随时告诉我！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Springboot 学习笔记 </category>
          
          <category> Java Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot Spring @Component 注解解释</title>
      <link href="/2024/8aef8f58.html"/>
      <url>/2024/8aef8f58.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>@Component</code> 是 Spring Framework 中的一个注解，用于将一个类标识为 Spring 容器的组件。它是 Spring 的一种构造方式，允许开发者以注解的方式定义 Bean，从而使得 Spring 能够自动扫描并注册这些类为 Bean。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><p><strong>自动扫描</strong>：</p><ul><li>Spring 可以通过类路径扫描来检测被 <code>@Component</code> 注解标记的类，并将其自动注册为 Spring 容器中的 Bean。这个过程通常在应用启动时发生。</li></ul></li><li><p><strong>泛化的组件定义</strong>：</p><ul><li><code>@Component</code> 是一个泛化的注解，意味着它可以用于任何类型的类。Spring 提供了其他特定功能的注解，例如 <code>@Service</code>（用于服务层组件）、<code>@Repository</code>（用于数据访问层组件）和 <code>@Controller</code>（用于控制层组件），这些注解实际上都是基于 <code>@Component</code> 的。</li></ul></li><li><p><strong>与依赖注入结合使用</strong>：</p><ul><li>被 <code>@Component</code> 注解的类可以通过 Spring 的依赖注入机制（如 <code>@Autowired</code>）注入到其他组件中，促进了松耦合的设计。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的使用 <code>@Component</code> 注解的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service is serving...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>自定义 Bean</strong>：当你有一个自定义类，想要让 Spring 容器管理它并进行依赖注入时，可以使用 <code>@Component</code>。</li><li><strong>服务层</strong>：在服务层，使用 <code>@Service</code> 注解是推荐的做法，但你也可以使用 <code>@Component</code>。</li><li><strong>数据访问层</strong>：在数据访问层，使用 <code>@Repository</code> 是推荐的做法，但你也可以使用 <code>@Component</code>。</li><li><strong>控制器</strong>：在控制器层，使用 <code>@Controller</code> 是推荐的做法，但你也可以使用 <code>@Component</code>。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>作用</strong>：将类标记为 Spring 组件，使其能够被 Spring 容器自动检测并管理。</li><li><strong>功能</strong>：实现组件的自动扫描和注册，结合依赖注入促进松耦合的架构设计。</li><li><strong>灵活性</strong>：可以与其他 Spring 注解（如 <code>@Service</code>、<code>@Repository</code> 和 <code>@Controller</code>）互换使用，但使用更具体的注解可以提高代码的可读性和语义性。</li></ul><p>希望这个解释对你理解 <code>@Component</code> 注解有所帮助！如果你有其他问题或需要更深入的解释，随时可以问我。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Springboot 学习笔记 </category>
          
          <category> Java Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot Spring Security 的基础解释</title>
      <link href="/2024/d207740e.html"/>
      <url>/2024/d207740e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="最简单的-SpringSecurity-配置（毫无意义，基础）"><a href="#最简单的-SpringSecurity-配置（毫无意义，基础）" class="headerlink" title="最简单的 SpringSecurity 配置（毫无意义，基础）"></a>最简单的 SpringSecurity 配置（毫无意义，基础）</h2><p>这段代码是一个 <strong>Spring Security</strong> 的配置类，用于定义应用程序的安全过滤链（<code>SecurityFilterChain</code>）。下面我将详细解释这段代码的执行过程以及它的作用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="1-Configuration-注解"><a href="#1-Configuration-注解" class="headerlink" title="1. @Configuration 注解"></a>1. <code>@Configuration</code> 注解</h3><ul><li><strong>作用</strong>：标识该类是一个配置类，类似于 Spring 的 XML 配置文件。</li><li><strong>功能</strong>：Spring 在启动时会扫描被 <code>@Configuration</code> 注解的类，将其中定义的 Bean 注册到应用程序的上下文中。</li></ul><h3 id="2-Bean-注解"><a href="#2-Bean-注解" class="headerlink" title="2. @Bean 注解"></a>2. <code>@Bean</code> 注解</h3><ul><li><strong>作用</strong>：标记方法的返回值应该作为一个 Bean，被 Spring 容器管理。</li><li><strong>功能</strong>：当 Spring 容器初始化时，会调用这个方法，将返回的对象注册为一个 Bean。</li></ul><h3 id="3-SecurityFilterChain-securityFilterChain-HttpSecurity-http"><a href="#3-SecurityFilterChain-securityFilterChain-HttpSecurity-http" class="headerlink" title="3. SecurityFilterChain securityFilterChain(HttpSecurity http)"></a>3. <code>SecurityFilterChain securityFilterChain(HttpSecurity http)</code></h3><ul><li><strong>参数</strong>：<code>HttpSecurity http</code>，这是由 Spring Security 提供的，用于配置基于 Web 的安全性。</li><li><strong>返回值</strong>：<code>SecurityFilterChain</code>，表示安全过滤器链，Spring Security 会使用它来过滤 HTTP 请求。</li><li><strong>抛出异常</strong>：<code>throws Exception</code>，因为配置过程中可能会抛出受检异常。</li></ul><h3 id="4-方法体：return-http-build"><a href="#4-方法体：return-http-build" class="headerlink" title="4. 方法体：return http.build();"></a>4. 方法体：<code>return http.build();</code></h3><ul><li><strong>作用</strong>：构建并返回一个 <code>SecurityFilterChain</code> 实例。</li><li><strong>功能</strong>：由于没有对 <code>http</code> 对象进行任何配置，返回的将是一个 <strong>默认配置</strong> 的安全过滤器链。</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li><p><strong>Spring Boot 应用启动</strong>：</p><ul><li>Spring Boot 自动扫描被 <code>@Configuration</code> 注解的类。</li></ul></li><li><p><strong>处理配置类</strong>：</p><ul><li>发现 <code>SecurityConfiguration</code> 类，并解析其中的 <code>@Bean</code> 方法。</li></ul></li><li><p><strong>依赖注入</strong>：</p><ul><li><code>HttpSecurity</code> 对象被注入到 <code>securityFilterChain</code> 方法中。</li><li>这是因为 Spring 可以在 <code>@Bean</code> 方法中自动注入参数，这些参数可以是其他 Bean，也可以是框架提供的对象。</li></ul></li><li><p><strong>调用 <code>securityFilterChain</code> 方法</strong>：</p><ul><li>执行方法体。</li><li>由于没有对 <code>http</code> 进行任何配置，直接调用 <code>http.build()</code>。</li></ul></li><li><p><strong>构建 <code>SecurityFilterChain</code></strong>：</p><ul><li><code>http.build()</code> 方法会根据当前的 <code>HttpSecurity</code> 配置构建一个 <code>SecurityFilterChain</code> 对象。</li><li>因为没有添加任何自定义配置，使用的是 <strong>默认的安全配置</strong>。</li></ul></li><li><p><strong>注册 Bean</strong>：</p><ul><li>将生成的 <code>SecurityFilterChain</code> 对象注册为 Spring 容器中的一个 Bean。</li><li>Spring Security 使用这个 Bean 来保护应用程序的 HTTP 端点。</li></ul></li></ol><h2 id="代码的作用和效果"><a href="#代码的作用和效果" class="headerlink" title="代码的作用和效果"></a>代码的作用和效果</h2><h3 id="默认安全配置"><a href="#默认安全配置" class="headerlink" title="默认安全配置"></a>默认安全配置</h3><ul><li><strong>启用基本的 HTTP 安全性</strong>：所有的 HTTP 请求都需要认证。</li><li><strong>启用表单登录</strong>：提供一个默认的登录页面。</li><li><strong>启用 CSRF 保护</strong>：防止跨站请求伪造攻击。</li><li><strong>启用会话管理</strong>：跟踪用户会话。</li></ul><h3 id="为什么会这样执行"><a href="#为什么会这样执行" class="headerlink" title="为什么会这样执行"></a>为什么会这样执行</h3><ul><li><strong>Spring Security 的自动配置</strong>：当检测到应用程序中存在 <code>SecurityFilterChain</code> 类型的 Bean 时，Spring Security 会使用它来配置安全过滤器链。</li><li><strong>默认行为</strong>：如果没有对 <code>HttpSecurity</code> 进行配置，Spring Security 会应用默认的安全策略，以确保应用程序的基本安全性。</li></ul><h2 id="如何自定义安全配置"><a href="#如何自定义安全配置" class="headerlink" title="如何自定义安全配置"></a>如何自定义安全配置</h2><p>如果你希望自定义安全配置，可以在 <code>securityFilterChain</code> 方法中对 <code>HttpSecurity</code> 对象进行配置。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()  <span class="comment">// 所有请求都需要认证</span></span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()  <span class="comment">// 启用表单登录</span></span><br><span class="line">            .and()</span><br><span class="line">            .httpBasic();  <span class="comment">// 启用 HTTP Basic 认证</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><strong><code>authorizeRequests()</code></strong>：开始配置授权规则。</li><li><strong><code>anyRequest().authenticated()</code></strong>：任何请求都需要认证。</li><li><strong><code>formLogin()</code></strong>：启用表单登录，提供默认的登录页面。</li><li><strong><code>httpBasic()</code></strong>：启用 HTTP Basic 认证方式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>执行内容</strong>：在应用程序启动时，Spring 会调用 <code>securityFilterChain</code> 方法，生成一个默认配置的 <code>SecurityFilterChain</code>，并将其注册为一个 Bean。</li><li><strong>原因</strong>：因为 <code>@Configuration</code> 和 <code>@Bean</code> 注解的存在，Spring 会管理该配置类和其中的方法，将返回的对象作为 Bean 管理。</li><li><strong>影响</strong>：应用程序将使用 Spring Security 的默认安全配置，保护所有的 HTTP 端点。</li></ul><h2 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h2><h3 id="方法参数注入"><a href="#方法参数注入" class="headerlink" title="方法参数注入"></a>方法参数注入</h3><ul><li><strong><code>HttpSecurity</code> 参数的注入</strong>：Spring 能够将方法需要的参数自动注入，即使这些参数不是直接定义为 Bean。这是通过方法参数注入（Method Parameter Injection）实现的。</li><li><strong>原因</strong>：<code>HttpSecurity</code> 是 Spring Security 提供的，用于构建安全过滤链的主要配置对象。</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><strong><code>throws Exception</code></strong>：配置过程中可能会抛出受检异常，需要在方法签名中声明。</li></ul><h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><ul><li><strong>自定义安全策略</strong>：通过对 <code>HttpSecurity</code> 进行配置，可以定制化应用程序的安全策略，满足特定的安全需求。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><strong>Spring Security 官方文档</strong>：了解更多关于 <code>HttpSecurity</code> 和安全配置的细节。</li><li><strong>Spring Boot 自动配置机制</strong>：了解 Spring 如何自动配置应用程序，以及如何自定义这些配置。</li></ul><hr><h2 id="完整的-SecurityFilterChain-函数解释"><a href="#完整的-SecurityFilterChain-函数解释" class="headerlink" title="完整的 SecurityFilterChain 函数解释"></a>完整的 SecurityFilterChain 函数解释</h2><p>这段代码是一个基于 <strong>Spring Security</strong> 的安全配置，用于处理应用程序的安全性，特别是针对 API 端点的身份验证、授权、以及基于 JWT（无状态）的安全机制。下面我们一步步分析每个部分的具体作用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">            .authorizeHttpRequests(conf -&gt; conf</span><br><span class="line">                    .requestMatchers(<span class="string">&quot;/api/auth/**&quot;</span>, <span class="string">&quot;/error&quot;</span>).permitAll() <span class="comment">// 允许所有的 /api/auth 和 /error 请求</span></span><br><span class="line">                    .anyRequest().authenticated() <span class="comment">// 其他请求需要认证</span></span><br><span class="line">            )</span><br><span class="line">            .formLogin(conf -&gt; conf</span><br><span class="line">                    .loginProcessingUrl(<span class="string">&quot;/api/auth/login&quot;</span>) <span class="comment">// 自定义登录处理 URL</span></span><br><span class="line">                    .usernameParameter(<span class="string">&quot;user&quot;</span>) <span class="comment">// 登录表单中的用户名参数名称</span></span><br><span class="line">                    .successHandler(<span class="built_in">this</span>::onAuthenticationSuccess) <span class="comment">// 登录成功处理</span></span><br><span class="line">                    .failureHandler(<span class="built_in">this</span>::onAuthenticationFailure) <span class="comment">// 登录失败处理</span></span><br><span class="line">            )</span><br><span class="line">            .logout(conf -&gt; conf</span><br><span class="line">                    .logoutUrl(<span class="string">&quot;/api/auth/logout&quot;</span>) <span class="comment">// 自定义注销 URL</span></span><br><span class="line">                    .logoutSuccessHandler(<span class="built_in">this</span>::onLogoutSuccess) <span class="comment">// 注销成功处理</span></span><br><span class="line">            )</span><br><span class="line">            .exceptionHandling(conf -&gt; conf</span><br><span class="line">                    .authenticationEntryPoint(<span class="built_in">this</span>::onUnauthorized) <span class="comment">// 未认证时处理</span></span><br><span class="line">                    .accessDeniedHandler(<span class="built_in">this</span>::onAccessDenied) <span class="comment">// 权限不足时处理</span></span><br><span class="line">            )</span><br><span class="line">            .csrf(AbstractHttpConfigurer::disable) <span class="comment">// 禁用 CSRF 保护</span></span><br><span class="line">            .sessionManagement(conf -&gt; conf</span><br><span class="line">                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS) <span class="comment">// 无状态会话管理，禁止 Session</span></span><br><span class="line">            )</span><br><span class="line">            .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class) <span class="comment">// 在用户名密码认证过滤器之前加入 JWT 认证过滤器</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-authorizeHttpRequests-conf-gt"><a href="#1-authorizeHttpRequests-conf-gt" class="headerlink" title="1. authorizeHttpRequests(conf -&gt; ...)"></a>1. <code>authorizeHttpRequests(conf -&gt; ...)</code></h3><p>这是配置 <strong>HTTP 请求的授权规则</strong>：</p><ul><li><code>requestMatchers(&quot;/api/auth/**&quot;, &quot;/error&quot;).permitAll()</code>：允许 <code>/api/auth/**</code> 和 <code>/error</code> 路径下的所有请求，无需认证。</li><li><code>anyRequest().authenticated()</code>：其他所有请求都需要认证，未经认证的请求会被拒绝。</li></ul><h3 id="2-formLogin-conf-gt"><a href="#2-formLogin-conf-gt" class="headerlink" title="2. formLogin(conf -&gt; ...)"></a>2. <code>formLogin(conf -&gt; ...)</code></h3><p>这是配置表单登录相关的功能：</p><ul><li><code>loginProcessingUrl(&quot;/api/auth/login&quot;)</code>：自定义登录处理的 URL，这里指定 <code>/api/auth/login</code> 为登录请求的处理路径。</li><li><code>usernameParameter(&quot;user&quot;)</code>：指定登录请求中的用户名参数为 <code>&quot;user&quot;</code>，默认的参数名称是 <code>&quot;username&quot;</code>。</li><li><code>successHandler(this::onAuthenticationSuccess)</code>：自定义登录成功的处理逻辑。</li><li><code>failureHandler(this::onAuthenticationFailure)</code>：自定义登录失败的处理逻辑。</li></ul><h3 id="3-logout-conf-gt"><a href="#3-logout-conf-gt" class="headerlink" title="3. logout(conf -&gt; ...)"></a>3. <code>logout(conf -&gt; ...)</code></h3><p>这是配置用户注销（Logout）的逻辑：</p><ul><li><code>logoutUrl(&quot;/api/auth/logout&quot;)</code>：指定自定义的注销请求 URL <code>/api/auth/logout</code>。</li><li><code>logoutSuccessHandler(this::onLogoutSuccess)</code>：自定义注销成功后的处理逻辑。</li></ul><h3 id="4-exceptionHandling-conf-gt"><a href="#4-exceptionHandling-conf-gt" class="headerlink" title="4. exceptionHandling(conf -&gt; ...)"></a>4. <code>exceptionHandling(conf -&gt; ...)</code></h3><p>这是配置异常处理：</p><ul><li><code>authenticationEntryPoint(this::onUnauthorized)</code>：未认证时的处理逻辑。当用户未登录或凭证无效时，系统调用 <code>onUnauthorized</code> 方法进行处理。</li><li><code>accessDeniedHandler(this::onAccessDenied)</code>：当用户试图访问无权限的资源时，调用 <code>onAccessDenied</code> 方法进行处理。</li></ul><h3 id="5-csrf-AbstractHttpConfigurer-disable"><a href="#5-csrf-AbstractHttpConfigurer-disable" class="headerlink" title="5. .csrf(AbstractHttpConfigurer::disable)"></a>5. <code>.csrf(AbstractHttpConfigurer::disable)</code></h3><p>禁用 CSRF 保护：</p><ul><li><strong>原因</strong>：通常在前后端分离、RESTful API 的场景下，CSRF 不再适用，特别是在使用 JWT 时。因此，CSRF 被禁用。</li></ul><h3 id="6-sessionManagement-conf-gt"><a href="#6-sessionManagement-conf-gt" class="headerlink" title="6. sessionManagement(conf -&gt; ...)"></a>6. <code>sessionManagement(conf -&gt; ...)</code></h3><p>配置会话管理策略：</p><ul><li><code>sessionCreationPolicy(SessionCreationPolicy.STATELESS)</code>：将会话管理设置为无状态模式。所有的用户认证信息不再存储在 Session 中，而是通过每次请求携带的 JWT 来进行认证。</li><li><strong>目的</strong>：由于前后端分离，使用 JWT 的无状态架构，不再需要通过服务器端的会话（Session）来管理用户的身份状态。</li></ul><h3 id="7-addFilterBefore-jwtAuthorizeFilter-UsernamePasswordAuthenticationFilter-class"><a href="#7-addFilterBefore-jwtAuthorizeFilter-UsernamePasswordAuthenticationFilter-class" class="headerlink" title="7. addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)"></a>7. <code>addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</code></h3><p>添加自定义的 JWT 过滤器：</p><ul><li><code>addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)</code>：将自定义的 <code>jwtAuthorizeFilter</code> 过滤器添加到 <code>UsernamePasswordAuthenticationFilter</code> 之前。</li><li><strong>作用</strong>：在用户名密码认证之前，先通过 JWT 来判断请求是否已经认证。如果请求携带有效的 JWT，用户就被视为已认证，跳过后续的登录流程。</li></ul><h3 id="总体作用"><a href="#总体作用" class="headerlink" title="总体作用"></a>总体作用</h3><p>这段代码配置了一个无状态的安全过滤链，适用于前后端分离的应用程序，主要特点如下：</p><ol><li><strong>允许特定端点的访问</strong>：例如，<code>/api/auth/**</code>（通常用于登录、注册）和 <code>/error</code> 的请求不需要认证。</li><li><strong>自定义表单登录和注销</strong>：可以自定义登录请求的 URL，处理登录成功或失败的逻辑，以及自定义注销的行为。</li><li><strong>禁用 CSRF</strong>：由于使用 JWT 进行无状态认证，CSRF 防护被禁用。</li><li><strong>无状态会话管理</strong>：通过设置 <code>SessionCreationPolicy.STATELESS</code>，不使用会话管理用户状态，所有身份验证信息都通过 JWT 来处理。</li><li><strong>JWT 认证</strong>：添加了自定义的 JWT 过滤器，确保在处理用户名和密码认证之前，先判断 JWT 是否有效。</li></ol><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ol><li>请求到达服务器时，首先检查是否是允许的未认证端点（如 <code>/api/auth/**</code>）。</li><li>如果不是，Spring Security 会查看请求是否带有 JWT。如果带有 JWT，则通过 <code>jwtAuthorizeFilter</code> 进行认证。</li><li>如果 JWT 无效，则请求会被拒绝，或者重定向到登录端点。</li><li>用户通过 <code>/api/auth/login</code> 进行登录时，系统会使用自定义的登录表单配置处理登录流程，并在成功或失败时调用相应的处理器。</li><li>用户注销时，会调用 <code>/api/auth/logout</code>，并使用自定义的注销成功处理器。</li></ol><p>希望这些解释能够帮你更好地理解这段代码！</p><hr><h2 id="补充：什么时候-Spring-会取消生成测试用的登录密码"><a href="#补充：什么时候-Spring-会取消生成测试用的登录密码" class="headerlink" title="补充：什么时候 Spring 会取消生成测试用的登录密码"></a>补充：什么时候 Spring 会取消生成测试用的登录密码</h2><p>Spring Boot 默认在没有明确定义安全配置的情况下，会自动生成一个测试用的登录密码（通常在启动日志中显示），并要求用户使用这个密码登录。这种行为是在开发阶段为了方便调试和测试。然而，当你明确配置了安全认证机制或自定义用户详情服务时，Spring 就不会再生成测试用的登录密码。</p><h3 id="Spring-会取消生成测试用的登录密码的条件："><a href="#Spring-会取消生成测试用的登录密码的条件：" class="headerlink" title="Spring 会取消生成测试用的登录密码的条件："></a>Spring 会取消生成测试用的登录密码的条件：</h3><ol><li><p><strong>定义了用户认证逻辑</strong>：</p><ul><li>当你定义了自定义的用户认证方式，例如提供了一个 <code>UserDetailsService</code> 或者直接通过内存、数据库等配置用户时，Spring 不再生成测试用的登录密码。</li></ul><p>例如，当你使用以下代码定义了一个用户，Spring 就不会生成默认密码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withDefaultPasswordEncoder()</span><br><span class="line">        .username(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">        .password(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">        .roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>禁用默认的 HTTP 基本认证</strong>：</p><ul><li>如果你禁用了默认的 HTTP 基本认证或表单登录，Spring 不会提供默认的登录页面和登录密码。例如，配置无状态认证机制时，Spring 就不会生成默认的密码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</span><br><span class="line">        .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用了自定义的安全配置</strong>：</p><ul><li>如果你通过自定义 <code>SecurityFilterChain</code> 完全覆盖了 Spring Security 的默认配置，Spring 也会取消生成默认的登录密码。例如在你提供了完整的 <code>SecurityFilterChain</code> 时，就不再需要默认的密码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">        .authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin().disable()  <span class="comment">// 禁用表单登录</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自定义认证方式</strong>：</p><ul><li>如果你使用了其他的认证方式（例如 OAuth2、JWT、LDAP 等），并禁用了默认的用户密码认证机制，Spring 也不会生成测试用的登录密码。</li></ul></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>当你开始自定义安全配置，定义自己的用户认证逻辑、禁用表单登录或启用无状态认证机制（如 JWT），Spring 就不会再生成默认的测试用密码。</p><p>如果你没有配置这些，Spring 会认为你处于开发或测试阶段，自动生成一个默认密码用于简单的登录认证。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Springboot 学习笔记 </category>
          
          <category> Java Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot Spring @Configuration 和 @Bean 注解解释</title>
      <link href="/2024/195a7602.html"/>
      <url>/2024/195a7602.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- hexo new note-springboot "Spring @Configuration 注解解释" --type SpringBoot --><h2 id="Configuration-注解"><a href="#Configuration-注解" class="headerlink" title="@Configuration 注解"></a>@Configuration 注解</h2><p>在 Spring Framework 中，<code>@Configuration</code> 是一个注解，用于定义配置类。配置类是用来替代 XML 配置文件的，它可以用来声明 Bean 和配置 Spring 容器中的依赖关系。</p><p>具体来说，<code>@Configuration</code> 注解表明该类是一个配置类，负责创建和管理 Spring 容器中的 Bean。通常，与 <code>@Bean</code> 注解一起使用，<code>@Bean</code> 用于方法上，指示该方法返回一个要被 Spring 管理的 Bean 实例。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ol><li>当 Spring 容器启动时，它会扫描带有 <code>@Configuration</code> 注解的类。</li><li>容器会执行这些类中的 <code>@Bean</code> 方法，并将返回的对象作为 Bean 注册到 Spring 的 IoC 容器中。</li><li>这些 Bean 就可以在应用的其他部分通过注入机制（如 <code>@Autowired</code>）来使用。</li></ol><p>相比于传统的 XML 配置，使用 <code>@Configuration</code> 注解更具可读性，并且通过 Java 代码的方式可以利用强类型检查和 IDE 提供的代码提示。</p><h2 id="Bean-注解"><a href="#Bean-注解" class="headerlink" title="@Bean 注解"></a>@Bean 注解</h2><p><code>@Bean</code> 是 Spring Framework 中的一个注解，用于将一个方法的返回值声明为一个 Spring 容器管理的 <strong>Bean</strong>。它通常与 <code>@Configuration</code> 注解一起使用，用于显式地定义 Bean，并将其添加到 Spring 的 IoC（控制反转）容器中。</p><h3 id="Bean-的作用"><a href="#Bean-的作用" class="headerlink" title="@Bean 的作用"></a><code>@Bean</code> 的作用</h3><p><code>@Bean</code> 注解通常标注在方法上，这个方法返回的对象会被注册为 Spring 容器中的一个 Bean。这样可以在应用的其他部分中，通过依赖注入（如 <code>@Autowired</code>）来使用这些 Bean。</p><h3 id="与-Component-的区别"><a href="#与-Component-的区别" class="headerlink" title="与 @Component 的区别"></a>与 <code>@Component</code> 的区别</h3><ul><li><strong><code>@Component</code></strong>：是一种类级别的注解，自动将类的实例作为 Bean 注册到 Spring 容器中，主要用于自动扫描和自动装配。</li><li><strong><code>@Bean</code></strong>：是一种方法级别的注解，用于显式声明一个 Bean，适合那些无法直接使用 <code>@Component</code> 标注的类，或者需要更多定制化的 Bean 创建逻辑时。</li></ul><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并返回一个 MyService 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><ol><li>Spring 容器在启动时，扫描带有 <code>@Configuration</code> 的类，并调用这些类中的带有 <code>@Bean</code> 注解的方法。</li><li>返回的对象会被注册为容器中的一个 Bean，供应用程序中的其他组件使用。</li></ol><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul><li>如果需要精细控制 Bean 的创建过程，或者需要创建的 Bean 来自第三方库（无法通过 <code>@Component</code> 进行标注），可以使用 <code>@Bean</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Springboot 学习笔记 </category>
          
          <category> Java Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The usage of Signal in Godot 4</title>
      <link href="/2024/b89e24c9.html"/>
      <url>/2024/b89e24c9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h1><p>Using <code>bind()</code> method is useful when connecting a signal.</p><blockquote><p>In fact, bind is not a method for signal but for function (or <code>Callable</code> class in Godot).</p></blockquote><p>For example, we have three button on our start menu.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@onready var start: Button = %Start</span><br><span class="line">@onready var settings: Button = %Settings</span><br><span class="line">@onready var quit: Button = %Quit</span><br></pre></td></tr></table></figure><p>Then we can bind the start event in <code>_ready()</code> method, and parse some custom parameter using <code>bind()</code> function. For example:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func _ready() -&gt; void:</span><br><span class="line">start.pressed.connect(handle_menu_press.bind(start))</span><br><span class="line">settings.pressed.connect(handle_menu_press.bind(settings))</span><br><span class="line">quit.pressed.connect(handle_menu_press.bind(quit))</span><br></pre></td></tr></table></figure><p>The code above showing, we connect the <code>handle_menu_press</code> function to the button’s <code>pressed</code> signal. But we are binding the <code>start</code> button (itself) as the parameters for the method.</p><blockquote><p>Confused? Don’t worry, keep reading and I’ll explain it below.</p></blockquote><p>What should <code>handle_menu_press()</code> function do?</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func handle_menu_press(button_pressed: Button):</span><br><span class="line">match button_pressed:</span><br><span class="line">start:</span><br><span class="line">start_game()</span><br><span class="line">settings:</span><br><span class="line">open_settings()</span><br><span class="line">quit:</span><br><span class="line">quit_game()</span><br></pre></td></tr></table></figure><p>The code about show that, the <code>handle_menu_press</code> function received a <code>Button</code> type of parameters. We already parse into via <code>bind</code> function. So for now, when the <code>handle_menu_press()</code> function is called, it will also know which button is pressed, and we just need to process each button’s code logic to make them function well.</p><p>For example, when we pressed <code>Settings</code> button, the function will call like this <code>handle_menu_press(setting)</code> , then inside the function, the code determine which button is pressed (since all buttons will call the <code>handle_menu_press</code>) using <code>match</code> case, then it will <code>open_settings()</code> as the running result.</p><h1 id="Bubble-signal"><a href="#Bubble-signal" class="headerlink" title="Bubble signal"></a>Bubble signal</h1><p>For example, We have a Hero (Character2D) scene in our game, and inside the scene tree, we have a PowerUp node (Node2D) below it. Here is the code of PowerUp node:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># powerup.gd</span><br><span class="line"></span><br><span class="line">signal powerup_started(id: int)</span><br><span class="line">signal powerup_ended</span><br><span class="line"></span><br><span class="line">func pickup_powerup(id: int) -&gt; void:</span><br><span class="line">powerup_started.emit(id)</span><br><span class="line"># Other powerup logic here (start timer, define timeout, store type, etc...)</span><br><span class="line"></span><br><span class="line">func end_powerup() -&gt; void:</span><br><span class="line">powerup_ended.emit()</span><br><span class="line"># Other logic here (clear type, etc...)</span><br></pre></td></tr></table></figure><p>It is very easy to receive the signal from PowerUp by Hero. But, what if in case we need to let the Node higher than Hero (like game world, or something above it) to listen to the <code>powerup_started</code> signal?</p><p>We may use the lambda inside Hero code, and bubble the signal up via the code below</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hero.gd</span><br><span class="line"></span><br><span class="line">signal powerup_started(id: int)</span><br><span class="line">signal powerup_ended</span><br><span class="line"></span><br><span class="line">@onready var powerup: PowerUp = $PowerUp</span><br><span class="line"></span><br><span class="line">func _ready() -&gt; void:</span><br><span class="line"># Lambda bubbers</span><br><span class="line">powerup.powerup_started.connect(func (id): powerup_started.emit(id))</span><br><span class="line">powerup.powerup_ended.connect(func (): powerup_ended.emit())</span><br></pre></td></tr></table></figure><p>The example above, we use lambda expression ⇒ <code>func (id): powerup_started.emit(id)</code> and <code>func (): powerup_ended.emit()</code> to bubble up the signal (To emit the signal from Hero routed from PowerUp)</p><p>So now, the Hero’s parent node can listen the <code>powerup_started</code> and <code>powerup_ended</code> signal from the PowerUp node inside the Hero node.</p><h1 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h1><p>We create a <a href="http://event.gd"><code>event.gd</code></a> script and make it Autoload via Project Settings so it can be access from anywhere in our game. For example:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># event.gd</span><br><span class="line"></span><br><span class="line">extend Node</span><br><span class="line"></span><br><span class="line">signal language_changed(lang_id)</span><br></pre></td></tr></table></figure><p>Then, we connect the signal inside our Settings menu (or any other way it will change your game language) by:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># for example in settings.gd</span><br><span class="line"></span><br><span class="line">extend Controls</span><br><span class="line"></span><br><span class="line">func change_language(lang_id: int)</span><br><span class="line">Event.language_change.emit(lang_id)</span><br></pre></td></tr></table></figure><p>We can connect the signal from anywhere, and it will working by using these code (where you need to change the language when the language is changed)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func _ready() -&gt; void:</span><br><span class="line">Event.language_change.connect(_on_language_change)</span><br><span class="line"></span><br><span class="line"># Process your language change logic right here.</span><br><span class="line">func _on_language_change(lang_id: int):</span><br><span class="line">pass # Change texts and etc...</span><br></pre></td></tr></table></figure><hr><h1 id="References-documentations"><a href="#References-documentations" class="headerlink" title="References documentations"></a>References documentations</h1><p><a href="https://docs.godotengine.org/en/stable/classes/class_callable.html#class-callable-method-bind">https://docs.godotengine.org/en/stable/classes/class_callable.html#class-callable-method-bind</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Godot 中实现超大数十六进制转十进制</title>
      <link href="/2024/6eea2b0c.html"/>
      <url>/2024/6eea2b0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="使用-Godot-引擎实现以太坊仪表盘-🛠️✨"><a href="#使用-Godot-引擎实现以太坊仪表盘-🛠️✨" class="headerlink" title="使用 Godot 引擎实现以太坊仪表盘 🛠️✨"></a>使用 Godot 引擎实现以太坊仪表盘 🛠️✨</h3><p>今天我打算分享一个如何使用 Godot 引擎实现以太坊仪表盘的项目。Godot 引擎是一款类 Python 语言开发工具，所见即所得的开发过程非常方便和高效。</p><p><img src="/uploads/godot-hex-to-dec/Screenshot%202024-05-29%20222245.png" alt="开发中的仪表盘界面展示"></p><p>本项目的数据获取采用了 Etherscan API 和 JSON-RPC 接口。以下是详细的实现过程和相关代码。</p><h2 id="Etherscan-的数据获取-📊"><a href="#Etherscan-的数据获取-📊" class="headerlink" title="Etherscan 的数据获取 📊"></a>Etherscan 的数据获取 📊</h2><p>原先我使用 Etherscan API 获取账户数据。Etherscan 提供的 API 非常简单，只需要提供地址和 API Token，就能返回所需的数据，数据以 JSON 格式展示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request_url = <span class="string">&quot;&quot;&quot;https://api.etherscan.io/api</span></span><br><span class="line"><span class="string">   ?module=account</span></span><br><span class="line"><span class="string">   &amp;action=balance</span></span><br><span class="line"><span class="string">   &amp;address=0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae</span></span><br><span class="line"><span class="string">   &amp;tag=latest</span></span><br><span class="line"><span class="string">   &amp;apikey=YourApiKeyToken&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>返回的 JSON 数据如下所示，其中 <code>result</code> 字段为钱包中的 ETH 数量，单位为 wei：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;40891626854930000000000&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="为什么需要更多选择？"><a href="#为什么需要更多选择？" class="headerlink" title="为什么需要更多选择？"></a>为什么需要更多选择？</h3><p>Etherscan API 对于免费用户每秒只能执行 5 次请求。由于我计划中的仪表盘需要查询的数据量较大，这样的限制使我们无法完全依赖 Etherscan API。为了确保数据的实时性和准确性，我们需要寻找其他数据获取方式。</p><h2 id="使用-JSON-RPC-获取数据-🖥️"><a href="#使用-JSON-RPC-获取数据-🖥️" class="headerlink" title="使用 JSON-RPC 获取数据 🖥️"></a>使用 JSON-RPC 获取数据 🖥️</h2><p>好在区块链提供了公共 RPC 节点进行调用。我们可以通过这些节点与区块链交互。由于 Godot 中没有 <code>web3.js</code> 或 <code>web3.py</code> 等替代代码库，因此需要使用 JSON-RPC 请求获取数据。在此项目中，我们使用 Infura 提供的 RPC 节点和 INFURA_PROJECT_ID 进行数据请求。</p><p>以下是具体实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const INFURA_PROJECT_ID = &quot;YOUR_INFURA_PROJECT_ID&quot;</span><br><span class="line">const INFURA_JSONRPC = &quot;https://mainnet.infura.io/v3/&quot; + INFURA_PROJECT_ID</span><br><span class="line"></span><br><span class="line">var headers = [&quot;Content-Type: application/json&quot;]</span><br><span class="line">var payload = &#123;</span><br><span class="line">&quot;jsonrpc&quot;: 2.0,</span><br><span class="line">&quot;method&quot;: &quot;&quot;,</span><br><span class="line">&quot;params&quot;: [],</span><br><span class="line">&quot;id&quot;: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func get_eth_balance(address: String):</span><br><span class="line"># 获取以太坊主币金额</span><br><span class="line">var data = Utils.deep_copy(payload)</span><br><span class="line">data.method = &quot;eth_getBalance&quot;</span><br><span class="line">data.params = [address, &quot;latest&quot;]</span><br><span class="line">var payload = JSON.stringify(data)</span><br><span class="line">get_eth_balance_request.request_completed.connect(_on_get_eth_balance_request_done)</span><br><span class="line">get_eth_balance_request.request(INFURA_JSONRPC, headers, HTTPClient.METHOD_POST, payload)</span><br></pre></td></tr></table></figure><p>返回的结果如下，其中 <code>result</code> 字段是余额，但格式为十六进制：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span><span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span><span class="string">&quot;0x417dc47f925afc21b1c3&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="为什么需要自己写转换器？"><a href="#为什么需要自己写转换器？" class="headerlink" title="为什么需要自己写转换器？"></a>为什么需要自己写转换器？</h3><p>由于 Godot 原生不支持超大数值计算（超出 2^64-1），我们需要将十六进制格式的余额转换成十进制。</p><h3 id="实现十六进制转十进制-🔄"><a href="#实现十六进制转十进制-🔄" class="headerlink" title="实现十六进制转十进制 🔄"></a>实现十六进制转十进制 🔄</h3><p>为了处理十六进制格式的余额，我们需要一个转换器，将十六进制字符串转换成十进制：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 将十六进制字符串转换成十进制，会丢失第 17 位之后的精度</span><br><span class="line">func hex_to_decimal(hex_str: String) -&gt; float:</span><br><span class="line"># 移除字符串中的 0x 前缀</span><br><span class="line">if hex_str.begins_with(&quot;0x&quot;):</span><br><span class="line">hex_str = hex_str.substr(2)</span><br><span class="line"># 初始化结果</span><br><span class="line">var result := 0.0</span><br><span class="line"># 从十六进制字符串的最低位（最右边）开始遍历</span><br><span class="line">for i in range(len(hex_str) - 1, -1, -1):</span><br><span class="line"># 获取当前十六进制字符对应的十进制值，并使用浮点数来避免整数溢出问题（牺牲精度）</span><br><span class="line">var decimal_value = float(hex_str[i].hex_to_int())</span><br><span class="line"># 计算当前位的十进制值乘以16的相应幂次</span><br><span class="line">var loc = len(hex_str) - i - 1</span><br><span class="line">var value = decimal_value * pow(16, loc)</span><br><span class="line"># 将计算结果相加</span><br><span class="line">result = result + value</span><br><span class="line">return result</span><br></pre></td></tr></table></figure><p>通过这种方式，我们可以得到十进制格式的余额。虽然在精度上有些牺牲，但足以满足需求。</p><h2 id="赠品-🎁"><a href="#赠品-🎁" class="headerlink" title="赠品 🎁"></a>赠品 🎁</h2><p>感谢您阅读到这里，下面附送两个额外的实用函数：</p><h3 id="实现-round-函数，到-n-位小数"><a href="#实现-round-函数，到-n-位小数" class="headerlink" title="实现 round 函数，到 n 位小数"></a>实现 round 函数，到 n 位小数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func round_to_decimals(x: float, digit: int) -&gt; float:</span><br><span class="line">return round(x * pow(10.0, digit)) / pow(10.0, digit)</span><br></pre></td></tr></table></figure><h3 id="格式化输出可读性更高的数值"><a href="#格式化输出可读性更高的数值" class="headerlink" title="格式化输出可读性更高的数值"></a>格式化输出可读性更高的数值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 将字符串进行格式化输出</span><br><span class="line">## 输入：8372914982598237298347  18, 6</span><br><span class="line">## 输出：8,372.91</span><br><span class="line">func format_number(x: float, max_reserve_decimal: int = 6) -&gt; String:</span><br><span class="line"># 计算小数点前面有多少位</span><br><span class="line">var digits = len(str(int(x)))</span><br><span class="line"># 最少预留两个小数，最多预留 6 个小数。</span><br><span class="line">var reserve_decimal = max(max_reserve_decimal - digits + 1, 2)</span><br><span class="line">x = round_to_decimals(x, reserve_decimal)</span><br><span class="line"># 格式化输出，加上逗号</span><br><span class="line">var number_string = str(x)</span><br><span class="line">var parts = number_string.split(&quot;.&quot;)</span><br><span class="line">var num: String = parts[0]</span><br><span class="line">var dec: String = &quot;.&quot; + parts[1]</span><br><span class="line">var reversed_str = num.reverse()</span><br><span class="line">var formatted_str = &quot;&quot;</span><br><span class="line"># 每三位插入逗号</span><br><span class="line">for i in range(reversed_str.length()):</span><br><span class="line">if i &gt; 0 and i % 3 == 0:</span><br><span class="line">formatted_str += &quot;,&quot;</span><br><span class="line">formatted_str += reversed_str[i]</span><br><span class="line"># 再次反转字符串以得到正确顺序</span><br><span class="line">formatted_str = formatted_str.reverse()</span><br><span class="line"># 拼接小数部分</span><br><span class="line">formatted_str += dec</span><br><span class="line">return formatted_str</span><br></pre></td></tr></table></figure><h3 id="总结-🌟"><a href="#总结-🌟" class="headerlink" title="总结 🌟"></a>总结 🌟</h3><p>通过本文，我们展示了如何使用 Godot 引擎和 Etherscan API 以及 JSON-RPC 接口来实现一个以太坊仪表盘。希望这些代码和方法对您有所帮助，并激发您在区块链开发中的更多灵感和创意。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>获取和某个智能合约交互的所有地址</title>
      <link href="/2024/c3c62cc2.html"/>
      <url>/2024/c3c62cc2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本项目已经开源到 GitHub 中，地址为：<a href="https://github.com/hubei-xhjy/blockchain-history-analyzer">https://github.com/hubei-xhjy/blockchain-history-analyzer</a></p></blockquote><h1 id="Eigenlayer-交互地址查询"><a href="#Eigenlayer-交互地址查询" class="headerlink" title="Eigenlayer 交互地址查询"></a>Eigenlayer 交互地址查询</h1><h2 id="1-get-txn-by-etherscan-py"><a href="#1-get-txn-by-etherscan-py" class="headerlink" title="1. get_txn_by_etherscan.py"></a>1. get_txn_by_etherscan.py</h2><h3 id="1-获取-EigenLayer-合约地址"><a href="#1-获取-EigenLayer-合约地址" class="headerlink" title="1. 获取 EigenLayer 合约地址"></a>1. 获取 EigenLayer 合约地址</h3><p>一般上，项目都会在他们的官网提供合约地址。通常在 Documentation 文档中。</p><ol><li>如 EigenLayer 的官网： <a href="https://www.eigenlayer.xyz/">https://www.eigenlayer.xyz/</a></li><li>打开 Documentation 页面</li><li>直接搜索 Contract，找到类似 <code>Contract Address</code><ol><li>会跳转到这里： <a href="https://docs.eigenlayer.xyz/eigenlayer/deployed-contracts/">https://docs.eigenlayer.xyz/eigenlayer/deployed-contracts/</a></li></ol></li><li>从文档中可以看到，这里提供了几个站外连接，我们点击 README.md 文档</li><li>这时候会跳转到 GitHub（其他项目会有不同的方法，可能直接写在页面中）<ol><li><a href="https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments">https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments</a></li></ol></li></ol><p>可以看到他们的表格如下：</p><div class="table-container"><table><thead><tr><th>Name</th><th>Proxy</th><th>Implementation</th><th>Notes</th></tr></thead><tbody><tr><td>DelegationManager</td><td>0x012345</td><td>0xabcdef</td><td>Proxy: TUP@4.7.1</td></tr></tbody></table></div><p>我们只需要获取 Proxy 的合约就行，可以看到这里有一大串合约地址，都要留下来，以免有漏网之鱼</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x39053D51B77DC0d36036Fc1fCc8Cb819df8Ef37A</span><br><span class="line">0x858646372CC42E1A627fcE94aa7A7033e7CF075A</span><br><span class="line">0x91E677b07F7AF907ec9a428aafA9fc14a0d3A338</span><br><span class="line">0x135dda560e946695d6f155dacafc6f1f25c1f5af</span><br><span class="line">0xD92145c07f8Ed1D392c1B88017934E301CC1c3Cd</span><br><span class="line"></span><br><span class="line">0x54945180dB7943c0ed0FEE7EdaB2Bd24620256bc</span><br><span class="line">0x93c4b944D05dfe6df7645A86cd2206016c51564D</span><br><span class="line">0x1BeE69b7dFFfA4E2d53C2a2Df135C388AD25dCD2</span><br><span class="line">0x9d7eD45EE2E8FC5482fa2428f15C971e6369011d</span><br><span class="line">0x13760F50a9d7377e4F20CB8CF9e4c26586c658ff</span><br><span class="line">0xa4C637e0F704745D182e4D38cAb7E7485321d059</span><br><span class="line">0x57ba429517c3473B6d34CA9aCd56c0e735b94c02</span><br><span class="line">0x0Fe4F44beE93503346A3Ac9EE5A26b130a5796d6</span><br><span class="line">0x7CA911E83dabf90C90dD3De5411a10F1A6112184</span><br><span class="line">0x8CA7A5d6f3acd3A7A8bC468a8CD0FB14B6BD28b6</span><br><span class="line">0xAe60d8180437b5C34bB956822ac2710972584473</span><br><span class="line">0x298aFB19A105D59E74658C4C334Ff360BadE6dd2</span><br><span class="line">0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0</span><br><span class="line"></span><br><span class="line">0x5a2a4F2F3C18f09179B6703e63D9eDD165909073</span><br><span class="line">0x7Fe7E9CC0F274d2435AD5d56D5fa73E47F6A23D8</span><br><span class="line"></span><br><span class="line">0x5050389572f2d220ad927CcbeA0D406831012390</span><br><span class="line">0xFEA47018D632A77bA579846c840d5706705Dc598</span><br><span class="line">0x369e6F597e22EaB55fFb173C6d9cD234BD699111</span><br><span class="line">0xBE1685C81aA44FF9FB319dD389addd9374383e90</span><br></pre></td></tr></table></figure><h3 id="2-使用-Etherscan-搭配合约地址进行数据爬取"><a href="#2-使用-Etherscan-搭配合约地址进行数据爬取" class="headerlink" title="2. 使用 Etherscan 搭配合约地址进行数据爬取"></a>2. 使用 Etherscan 搭配合约地址进行数据爬取</h3><p>Etherscan 已经给我们提供了通过合约地址以及区块范围进行数据爬取的 API</p><blockquote><p>注意：此 API 每次最大只返回 10000 条数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.etherscan.io/api</span><br><span class="line">?module=account</span><br><span class="line">&amp;action=txlist</span><br><span class="line">&amp;address=合约地址</span><br><span class="line">&amp;startblock=起始区块</span><br><span class="line">&amp;endblock=结束区块</span><br><span class="line">&amp;page=1</span><br><span class="line">&amp;offset=10000</span><br><span class="line">&amp;sort=asc</span><br><span class="line">&amp;apikey=&#123;etherscan_api&#125;</span><br></pre></td></tr></table></figure><p>我们在这里做个示例，执行以下请求：</p><ul><li>我们用 18905564 作为起始区块</li><li>这里我们用 19438188 作为结束区块</li><li>这里我们用 1 作为页数</li><li>这里我们用 1 作为偏移量（显示 1 条数据）</li><li>示例 API </li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.etherscan.io/api</span><br><span class="line">?module=account</span><br><span class="line">&amp;action=txlist</span><br><span class="line">&amp;address=0x858646372CC42E1A627fcE94aa7A7033e7CF075A</span><br><span class="line">&amp;startblock=18905564</span><br><span class="line">&amp;endblock=19438188</span><br><span class="line">&amp;page=1</span><br><span class="line">&amp;offset=10000</span><br><span class="line">&amp;sort=asc</span><br><span class="line">&amp;apikey=你的 API Key</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>这段代码是为了从 Etherscan API 拉取特定以太坊智能合约地址的交易数据，并将其保存到本地文件中。以下是对代码各部分的详细解释：</p><ol><li><strong>导入模块</strong>:<br>使用 <code>import requests</code> 导入 Python 的 <code>requests</code> 库，这是一个常用的库，用于发起 HTTP 请求。</li><li><strong>API 密钥和合约地址</strong>:<br><code>etherscan_api_key</code> 存储了 Etherscan API 的密钥，这是进行 API 调用时验证用户的关键信息。<br><code>contract_addresses</code> 列表包含了需要查询交易信息的多个智能合约地址。</li><li><strong>区块范围</strong>:<br><code>start_block</code> 和 <code>end_block</code> 定义了查询交易的起始和结束区块号。代码中将起始区块设定为 10000000，结束区块设定为 19438188。这样设定是为了确保涵盖了需要查询的所有交易数据。</li><li><strong>查询循环</strong>:<br>代码使用了一个外层的 <code>for</code> 循环遍历每一个合约地址，内层的 <code>while</code> 循环则用于持续查询直到没有更多数据。对于每个合约地址，代码构造一个 URL 来调用 Etherscan 的 API，获取该地址的交易列表。如果一页的结果满了（默认是 10000 条最大），就调整 <code>current_block</code> 来获取接下来的数据。</li><li><strong>构造 URL</strong>:<br>URL 包括合约地址、起始和结束区块号等参数。为了保证 URL 的正确，代码中有步骤替换 URL 中的空格和换行符。</li><li><strong>处理响应</strong>:<br>如果 HTTP 请求成功（状态码 200），则读取返回的数据并检查结果集的长度。如果结果集为 0，说明没有更多数据；否则，将数据写入本地文件。每次成功写入文件后，如果结果集达到 10000 条，就更新 <code>current_block</code> 并增加文件索引 <code>file_index</code>，准备写入新的文件。</li><li><strong>错误处理</strong>:<br>如果 HTTP 请求失败，会打印错误信息和状态码。</li></ol><p>这段代码的主要功能是从 Etherscan API 拉取交易数据，并根据数据量可能将结果分成多个文件保存。这可以用于分析智能合约的交易历史或进行区块链数据的备份。</p><h2 id="2-get-addresses-list-py"><a href="#2-get-addresses-list-py" class="headerlink" title="2. get_addresses_list.py"></a>2. get_addresses_list.py</h2><p>有了这些 tx 数据，接下来我们需要对这些数据进行分析。得出与这个智能合约交互的地址列表。</p><p>上面的 json 返回数据如下（节选）</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;OK&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;blockNumber&quot;</span><span class="punctuation">:</span> <span class="string">&quot;18000269&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;timeStamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1693070135&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x853e2a2f40ccf327b850724e538846a5268ead8e7fb3f359abbb678a469b9759&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;214&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;blockHash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x89d54f887e7f948d9f9c0c7d6144c90f31cd81618c1d7c1772d9b2ac23c50691&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;transactionIndex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;154&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xd06210462fa34227ecfff888c143fccd32b89157&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x858646372cc42e1a627fce94aa7a7033e7cf075a&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;285000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gasPrice&quot;</span><span class="punctuation">:</span> <span class="string">&quot;12600604735&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isError&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;txreceipt_status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xe7a050aa0000000000000000000000001bee69b7dfffa4e2d53c2a2df135c388ad25dcd2000000000000000000000000ae78736cd615f374d3085123a210448e74fc63930000000000000000000000000000000000000000000000000166d2f688429c50&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;contractAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cumulativeGasUsed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;16328658&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gasUsed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;32119&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;confirmations&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1815150&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;methodId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xe7a050aa&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;functionName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;depositIntoStrategy(address strategy,address token,uint256 amount)&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以得到以下信息：</p><ol><li>我们所需的数据都在 result 数组里</li><li>重要的几个字段有：<ol><li>from</li><li>to</li><li>isError</li></ol></li></ol><p>其中，isError 是用来检查这个 tx 是否成功的，0 表示成功，1 表示失败。</p><p>接下来要做的事情就是对所有交互过的地址进行收集并去重。</p><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><p>这段代码用于从之前通过 Etherscan API 获取的交易数据中提取出所有唯一的钱包地址，并将它们保存到一个文本文件中。以下是对代码各部分的详细解释：</p><ol><li><strong>导入模块</strong>:<br>使用 <code>import os</code> 和 <code>import json</code> 导入 Python 的 <code>os</code> 库和 <code>json</code> 库。<code>os</code> 库用于操作文件和目录，<code>json</code> 库用于解析 JSON 文件。</li><li><strong>初始化数据</strong>:<br><code>contract_addresses</code> 列表包含了所有需要处理的智能合约地址。这些地址之前已通过其他脚本用来获取交易数据。<br><code>wallet_addresses</code> 是一个集合（set），用于存储不重复的钱包地址。</li><li><strong>处理文件</strong>:<br>代码遍历 <code>contract_addresses</code> 中的每个地址。对于每个地址，它查找 <code>output</code> 目录下以该地址开头且以 <code>.json</code> 结尾的所有文件。</li><li><strong>读取和解析数据</strong>:<br>对于找到的每个文件，代码打开文件并加载 JSON 数据。它遍历每个交易数据的 ‘result’ 部分，对每个交易项进行处理。</li><li><strong>筛选交易数据</strong>:<br>代码检查每个交易是否有错误（通过 ‘isError’ 字段）。如果 <code>isError</code> 为 <code>1</code>，则忽略该交易；否则，将交易的发送方（’from’）和接收方（’to’）地址添加到 <code>wallet_addresses</code> 集合中。</li><li><strong>保存结果</strong>:<br>将 <code>wallet_addresses</code> 集合中的地址写入到 <code>output/wallet_addresses.txt</code> 文件中，每个地址占一行。</li><li><strong>输出统计信息</strong>:<br>最后，打印出存储的钱包地址总数，以帮助了解处理的结果规模。</li></ol><h2 id="3-track-eigenlayer-airdrop-by-address-py"><a href="#3-track-eigenlayer-airdrop-by-address-py" class="headerlink" title="3. track_eigenlayer_airdrop_by_address.py"></a>3. track_eigenlayer_airdrop_by_address.py</h2><p>现在有了所有的地址列表，接下来就是向空投项目方发送请求，查询空投额度：</p><p>通过一次前端请求过程中，我们使用开发者工具获取到了官方的空投 API 地址：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&quot;https://claims.eigenfoundation.org/clique-eigenlayer-api/campaign/eigenlayer/credentials?walletAddress=&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>我们发现官方并没有对 IP 进行禁止（流量限制），所以我们可以只挂一个 VPN 就开始暴力请求</p><p>因为这是一个很漫长的请求，所以我加入了 tqdm 来追踪进度</p><h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><p>这段代码旨在从一个 CSV 文件中读取钱包地址，通过并发请求一个 API 来获取关于每个钱包地址的额外数据（例如资格令牌信息），并将结果写入到一个新的 CSV 文件中。下面是对代码的详细解释：</p><ol><li><strong>导入必要的模块</strong>:<ul><li><code>requests</code> 用于发起网络请求。</li><li><code>csv</code> 用于处理 CSV 文件读写。</li><li><code>tqdm</code> 提供进度条功能，让用户可视化处理进度。</li><li><code>ThreadPoolExecutor</code> 用于实现多线程并发，提高请求处理的效率。</li></ul></li><li><strong>定义 API URL</strong>:<br><code>url</code> 定义了用来获取数据的 API 地址，该地址需要填入一个钱包地址。</li><li><strong>读取钱包地址</strong>:<br>使用 <code>csv.reader</code> 从 “output/wallet_addresses.csv” 文件中读取钱包地址。首先读取标题行，并检查是否已经包含 ‘Tokens’ 列。如果没有，将 ‘Tokens’ 添加到标题行中。</li><li><strong>定义辅助函数 <code>fetch_token_data</code></strong>:<br>这个函数接收一行数据（即一个钱包地址），向 API 发送请求，并处理响应。成功获取数据后，将其添加到该行；如果请求失败或发生异常，则记录相应的错误信息。</li><li><strong>多线程处理</strong>:<br>使用 <code>ThreadPoolExecutor</code> 创建一个线程池，最多允许 10 个并发线程。这些线程将并行地为每个钱包地址调用 <code>fetch_token_data</code> 函数。</li><li><strong>写入新的 CSV 文件</strong>:<br>结果被写入到 “output/wallet_addresses_updated.csv” 文件中。首先写入更新后的标题行，然后写入每行的处理结果。</li><li><strong>进度条显示</strong>:<br>使用 <code>tqdm</code> 包装 <code>executor.map</code> 的调用，显示处理进度条，提供用户友好的进度显示。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Branch 分支的用法以及使用场景</title>
      <link href="/2024/30c66ff0.html"/>
      <url>/2024/30c66ff0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Git 分支（branch）是 Git 中一项非常重要的功能，它允许您从主开发线（通常是 <code>main</code> 或 <code>master</code> 分支）分离出来，独立进行开发。这样做的主要目的是保持主开发线的稳定性，同时允许多个开发者或团队并行工作于不同的功能或修复上。</p><h3 id="Git-分支的基本用法"><a href="#Git-分支的基本用法" class="headerlink" title="Git 分支的基本用法"></a>Git 分支的基本用法</h3><ol><li><p><strong>创建分支</strong>：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p> 这个命令会创建一个新的分支，但不会自动切换到该分支。</p></li><li><p><strong>切换分支</strong>：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p> 使用这个命令切换到已有的分支。也可以使用 <code>git switch &lt;branch-name&gt;</code>，这是一个较新的命令，作用相同。</p></li><li><p><strong>合并分支</strong>：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p> 当在一个分支上的开发完成并且准备合并回主分支时，使用这个命令。这将会把 <code>&lt;branch-name&gt;</code> 分支的变更合并到当前分支。</p></li><li><p><strong>删除分支</strong>：</p> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p> 当完成分支的所有工作并已经合并回主分支后，可以使用这个命令删除不再需要的分支。</p></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>功能开发</strong>：<br>对于新功能的开发，可以创建一个专门的分支。这样做可以保证主分支的稳定性，同时也方便多个功能并行开发。</li><li><strong>修复 Bug</strong>：<br>当需要修复主分支上的 bug 时，可以创建一个修复分支。修复完成并测试无误后，再将其合并回主分支。</li><li><strong>实验性更改</strong>：<br>当想尝试一些新想法时，可以创建一个实验性分支。如果实验成功，可以将其合并回主分支；如果失败，则可以简单地放弃该分支。</li><li><strong>代码审查</strong>：<br>在一些团队中，新的代码合并到主分支前需要进行代码审查。在这种情况下，开发者可以在自己的分支上工作，完成后创建一个合并请求（Merge Request 或 Pull Request），由其他团队成员审查。</li><li><strong>版本发布</strong>：<br>对于即将发布的版本，可以创建一个专门的发布分支。这样做可以在发布前进行最终测试，确保版本的稳定性。</li></ol><p>总的来说，Git 分支是一种非常灵活且强大的工具，可以支持多种开发工作流程，帮助团队更高效地管理代码的开发和维护。在 Web3 项目开发中，合理使用 Git 分支可以大大提高代码管理的效率和项目的质量。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密货币行业交易现状</title>
      <link href="/2024/6ac08c19.html"/>
      <url>/2024/6ac08c19.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><details class="toggle" ><summary class="toggle-button" style="">tl;dr</summary><div class="toggle-content"><p>目前市场都是的股民都是笨蛋，人家讲什么就投资什么。所以市场波动超级无敌大。</p><p>比如说 A 和 B 说这个很赚钱，B 就去买了，没有去关注它为什么赚钱，甚至还教唆 C 去买</p><p>结果一堆人去买，市值就起来了，但是没有东西去支撑它，最后一定会有人高价卖掉，市值就掉回来了。比如 A 和 B 最高点卖掉了，C 以为可以再等等，最后等崩了</p><p>然后那些听别人话的笨蛋，以为市值会一直涨，但是没有关注相关信息。就亏半死</p><p>然后这个相关信息不是“技术突破”，更多时候是某个名人去买了这个，跟风效应产生的虚假市值</p></div></details><p>这个行业现阶段很重要的点，整个交易环境还是处于一种很浮躁的状态，大部分的交易都是由【叙事 和 情绪】主导的。这也会导致市值上下波动非常大，这就是为什么总会看到报纸上“谁谁谁被骗 / 损失多少钱”相关新闻。</p><p>理论上区块链技术应该是以【技术】为主导，技术决定市值，因为区块链的底层就是代码，未来必然会奔着实用性去发展，技术价值必然存在。但是现阶段要入局需要对整个金融行业（不只是技术）有了解。</p><p>而且通过以往报纸分析，很多时候都是以“赚快钱”的角度去对待加密货币。<strong>人是很难赚到自己认知之外的钱的</strong>。这种新兴技术和股票不一样，不存在长期持有必然上涨的说法。更多时候还需要对整个技术框架进行分析，确保一个项目的提出是割韭菜还是有实际应用。</p><h1 id="叙事与情绪主导的案例"><a href="#叙事与情绪主导的案例" class="headerlink" title="叙事与情绪主导的案例"></a>叙事与情绪主导的案例</h1><p>所谓的叙事和情绪主导市值，指的是行业中（应该囊括这世界上的所有）知名人物对该技术所发表的言论 / 行为所产生的明星效应。经典案例有以下几个：</p><p>2021 年 3 月 24 日：埃隆马斯克在<a href="https://x.com/elonmusk/status/1374617643446063105">推特</a>上发推：You can now buy a Tesla with Bitcoin，导致比特币市值一度刷新大家的认知：</p><ul><li>3 月 6 日 49408 USD</li><li>4 月 17 日 62006 USD 达到峰值</li></ul><p>2021 年 5 月 13 日：埃隆马斯克在<a href="https://x.com/elonmusk/status/1392602041025843203">推特</a>上发表一篇文章，关于“特斯拉暂停使用比特币购买车辆”，导致比特币的市值直降</p><ul><li>5 月 8 日 57694 USD</li><li>5 月 15 日 49186 USD</li><li>5 月 22 日 35208 USD</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要试图去赚你认知之外的钱。可能会存在侥幸让你大赚一笔，但是会因为认知不足导致贪婪爆发，最后赔的血本无归。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://coinank.com/zh/indexdata/feargreedIndex">比特币恐惧和贪婪指数查询-比特币恐慌指数网址-比特币贪婪指数查看-coinank</a></li><li><a href="https://www.theverge.com/2021/3/24/22347905/tesla-bitcoin-payment-us-cryptocurrency-elon-musk">You can now buy a Tesla with bitcoin in the US - The Verge</a></li><li><a href="https://www.thestreet.com/crypto/innovation/elon-musk-dismisses-bitcoin-because-it-cant-be-used-on-mars">Elon Musk dismisses bitcoin because ‘you couldn’t use’ it on Mars - TheStreet Crypto: Bitcoin and cryptocurrency news, advice, analysis and more</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链交易的安全须知</title>
      <link href="/2024/904904c6.html"/>
      <url>/2024/904904c6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>谁也不想自己辛辛苦苦赚的钱被盗走，这里是我这几天参考资料后做的一些总结。当然，道高一尺魔高一丈，不确定的事情就再三通过 Discord / Twitter / 官网 等官方渠道去获取信息。</p></blockquote><p><a href="https://hacked.slowmist.io/zh/statistics/">SlowMist Hacked 区块链被黑档案库</a> 统计，截止 2024 年 1 月 13 日，加密货币被黑所造成的损失达到了 314 亿美金</p><p><img src="/uploads/区块链交易的安全须知/SlowMistHacked-stat-2024-01.png" alt="Hacked BlockChain Amounts - SlowMist"></p><h1 id="无燃料签名类型"><a href="#无燃料签名类型" class="headerlink" title="无燃料签名类型"></a>无燃料签名类型</h1><ol><li>Identity Proof ✅ - 安全的<ol><li>一般上 ”连接钱包“ 和登录都会是这个界面</li><li>你的虚拟资产不会被转移</li></ol></li><li>Seaport ⚠️ - 如果在非官方网站，那这是非常危险的<ol><li>如果不是在 OpenSea 或者其他可信任的交易场所发现的，<strong>不要签</strong></li><li>难以阅读里边的内容究竟发生什么</li><li>可以使用 <a href="join.pocketuniverse.app/ref/8WS7">Pocket Universe</a>（邀请码：8WS7）去解读内容</li></ol></li><li>Hex Message ⚠️ - 避开这个<ol><li>这种签名方式不能直接转移资产</li><li>但是可以通过之前用户之前允许的权限进行间接的转移</li><li>基本上没有理由会让一个交易信息以十六进制（Hex）的形式呈现</li></ol></li><li>Eth_Sign ⛔ - 不要签！<ol><li>这是一个”空头支票“，可以让对方代表你执行任何交易</li><li>这肯定不会在有名望的项目团队中出现，所以<strong>不要签</strong>！</li><li><img src="/uploads/区块链交易的安全须知/PocketUniverse-GaslessSignatures.png" alt="Gasless Signature - Pocket Universe"></li></ol></li></ol><h1 id="Discord-假链接"><a href="#Discord-假链接" class="headerlink" title="Discord 假链接"></a>Discord 假链接</h1><p>Discord 的消息编辑器是基于 Markdown 的，这意味着用户可以通过 Markdown 的形式编辑一个隐藏的链接，然后用一个正常的链接去骗过用户。所以这点也是要非常注意的！比如你可以点击我的主页链接试试这个功能：<a href="https://opensea.io">https://kingsmai.github.io</a>，会跳到 OpenSea 平台。</p><p><img src="/uploads/区块链交易的安全须知/discord-hidden-link.png" alt="Discord Hidden Link - Pocket Universe"></p><p>点击 Discord 的链接会出现相关提示，确保你要访问的网站是正确的网站</p><p><img src="/uploads/区块链交易的安全须知/discord-open-url-confirmation.png" alt="Discord Hidden Link - Pocket Universe"></p><p>以上是一些区块链交易的注意事项，后续可能还会更新其他的套路。请大家持续关注！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么快速的做好一份战略计划</title>
      <link href="/2024/b6bd7002.html"/>
      <url>/2024/b6bd7002.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>想知道怎么在 1 个小时内撰写一份战略计划并进行汇报吗？这篇文章保证效率 UP！（作者提醒：本文适合初入职场的大学生食用）。</p><blockquote><p>前情提要：昨晚，我在办公室的静谧中（并非加班，只是钟爱这里的氛围）接到了领导的紧急任务：探索并测试 Aleo 区块链的 Prover 节点部署，以便未来的大规模应用。今天，我将分享在短短一小时内如何高效完成这一任务的心得。</p></blockquote><p>食用前须知：</p><ol><li>建议读者具备基本的 Markdown 撰写技能（若无也不妨，重要的是理解思路）。</li><li>开始计划前，对相关知识有所了解是必要的。</li><li>领导交付的任务通常在你的能力范围之内，但也需注意超出范围的知识点。</li></ol><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>在明确了与领导的沟通后，我们需要全面理解任务需求。以本案例为例，关键点包括：理解云服务器上部署节点的流程、简化操作步骤、以及未来的大规模部署计划。</p><p>在捋清楚需求之后，我们就可以对项目进行策划了。对于一件要做的事情，不该是进行全方位的策划，我们需要对该事情有一个大致框架。人的专注力是有限的，要有效的<strong>利用你的三分钟热度</strong>，才能不停的进行工作。一个项目，主要的过程就是：</p><ol><li>我们要做什么？</li><li>如何去做？</li><li>所需条件是什么？</li><li>需要的资金有多少？</li><li>实施策略是什么？</li></ol><p>需求分析阶段已经回答了前两个问题，接下来是对项目流程和需求的详细了解。</p><h1 id="了解具体的整个流程与需求"><a href="#了解具体的整个流程与需求" class="headerlink" title="了解具体的整个流程与需求"></a>了解具体的整个流程与需求</h1><blockquote><p>这里的需求指的是：<strong>如果需要顺利运行这个东西，我需要最起码具备什么条件？</strong></p></blockquote><p>以我们的案例，那么运行一个区块链节点，他是有一定的算力需求的，我们在官方文档中找到的配置资料如下：</p><p><img src="/uploads/how-to-write-a-plan-swiftly/example-requirement.png" alt="项目需求案例"></p><p>在我撰写的文档中，我清晰的列出了整个项目所需要的最低配置。这里因为 Validator 的配置要求高于 Prover，所以只写出差异性，这么做可以减少计划书篇幅，毕竟<strong>计划书是给人看的，从来不是形式主义拼字数的畸形产物</strong>。</p><p>当然，根据自身对行业的了解，以可靠资料作为支撑去对一些点做出分析及建议。比如在文档中，我在配置需求下附加了一项声明，表示项目配置需求会有所增加，并附上了参考资料来源。</p><hr><p>除了列出具体需要的配置之外，我也通过官网查阅了资料（这边我疏忽了，并没有列出我的资料来源），目的是为了了解我接下来需要做的东西具体是什么，它所能给公司带来的贡献是什么。同时在查阅的过程中，我也了解关于 Validator 是有一定的门槛才能参与的。如果没有去进行详细分析的话，可能我会在之后购买 Validator 的配置，却只能运行 Prover 节点，<strong>造成不必要的损失</strong>。</p><p>而虽然说这是后面才查阅到的资料，但是它属于很重要的信息，所以我将其放在文档的开头。</p><h1 id="货比三家"><a href="#货比三家" class="headerlink" title="货比三家"></a>货比三家</h1><p>选择云服务时，我对不同地区的服务器价格进行了比较，以寻找性价比最高的选项。同时，我注意到服务器的国内外差异，这是在选择服务时需要考虑的重要因素。</p><p><img src="/uploads/how-to-write-a-plan-swiftly/example-comparing-servers.png" alt="比较每个服务器价格"></p><p>同样的，这里我犯了一个错误，就是忘记了服务器有分国内外，所以一开始选择了南京的服务器，虽然价格相对便宜，但是硬性条件却不满足我们的业务需求。</p><h1 id="战略策划与可视化流程图"><a href="#战略策划与可视化流程图" class="headerlink" title="战略策划与可视化流程图"></a>战略策划与可视化流程图</h1><p>借助数据分析，我制定了整体项目的战略规划，并使用了 Mermaid 工具将计划转化为直观的流程图，从而更清晰地展示项目执行步骤。</p><p>这是整个流程图的 mermaid 源码：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">````mermaid</span></span><br><span class="line"><span class="code">graph TD</span></span><br><span class="line"><span class="code">  START([开始]) --&gt; A</span></span><br><span class="line"><span class="code">  A[租赁服务器] --&gt; B[运行测试]</span></span><br><span class="line"><span class="code">  B --&gt; C&#123;块挖掘成功？&#125;</span></span><br><span class="line"><span class="code">  C -- 是 --&gt; D[判断出块速度]</span></span><br><span class="line"><span class="code">  C -- 否 --&gt; E[升级服务器]</span></span><br><span class="line"><span class="code">  E --&gt; A</span></span><br><span class="line"><span class="code">  D --&gt; F[计算每小时租金花费]</span></span><br><span class="line"><span class="code">  F --&gt; G&#123;继续项目？&#125;</span></span><br><span class="line"><span class="code">  G -- 是 --&gt; H[保存当前配置快照]</span></span><br><span class="line"><span class="code">  G -- 否 --&gt; I[结束项目]</span></span><br><span class="line"><span class="code">  H --&gt; J[租赁更多同性能服务器]</span></span><br><span class="line"><span class="code">  J --&gt; K[部署]</span></span><br><span class="line"><span class="code">````</span></span><br></pre></td></tr></table></figure><p><img src="/uploads/how-to-write-a-plan-swiftly/example-strategy-plan.png" alt="战略规划"></p><h1 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h1><p>鉴于时间紧迫和任务繁重，我制作了一个待办事项清单，以便在项目进展中逐步调整和完善。</p><p><img src="/uploads/how-to-write-a-plan-swiftly/example-todos.png" alt="待办事项"></p><h1 id="列出参考文献"><a href="#列出参考文献" class="headerlink" title="列出参考文献"></a>列出参考文献</h1><p>最后，我列出了用于支持我的分析和决策的所有参考文献，增强了论述的可信度。</p><p><img src="/uploads/how-to-write-a-plan-swiftly/example-references.png" alt="参考资料"></p><p>以上就是我如何在短时间内有效制定和执行开发计划的过程。若您喜欢我的分享，欢迎赞助一杯奶茶。祝大家职场顺利，让我们在顶峰相见！</p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fuel 区块链开发并部署智能合约</title>
      <link href="/2024/798b701e.html"/>
      <url>/2024/798b701e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天需要尝试部署一个智能合约（Smart Contract），使用的是 Fuel 平台。本文将不探讨 Fuel 的底层逻辑，注重在从 0 配置环境到将智能合约部署到测试链上的过程和心得。</p><blockquote><p>使用的开发环境是：</p><ul><li>Ubuntu 22.04（在 Parallel Desktop 上运行）</li><li>Mac OS M2 Chip</li></ul></blockquote><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>首先需要安装几个必备工具件，截至我写这篇文章的时候，他们的版本号如下所示：</p><ol><li>Rust - 1.75.0 (82e1608df 2023-12-21)</li><li>Cargo - 1.75.0 (1d8b05cdd 2023-11-20)</li><li>Fuel 工具链 - 0.20.0</li><li>Cargo Generate（后续测试用） - 0.19.0</li></ol><h2 id="安装-Rust"><a href="#安装-Rust" class="headerlink" title="安装 Rust"></a>安装 Rust</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><h2 id="安装-Fuel-Toolchain"><a href="#安装-Fuel-Toolchain" class="headerlink" title="安装 Fuel Toolchain"></a>安装 Fuel Toolchain</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://install.fuel.network/fuelup-init.sh | sh</span><br></pre></td></tr></table></figure><h2 id="安装-Cargo-Generate"><a href="#安装-Cargo-Generate" class="headerlink" title="安装 Cargo Generate"></a>安装 Cargo Generate</h2><p>Cargo Generate 是为了后续我们需要测试我们写的代码，因为智能合约更像是一种后端，<strong>而且是没有终端输出（Console）的后端系统（至少目前我的认知是这样）</strong>。所以我们需要编写测试样例，来确保我们写的智能合约能够顺利的执行。</p><p>我们在终端中执行以下的指令来安装 cargo-generate。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install cargo-generate</span><br></pre></td></tr></table></figure><p>当然，在安装 cargo generate 的过程中我们遇到了很多问题，因此我也写了一篇文章 <a href="/2024/77854802.html" title="[How-To Fix] Error while installing cargo-generate">[How-To Fix] Error while installing cargo-generate</a> 来解决该问题，可以移步阅读。</p><h1 id="创建-Sway-项目"><a href="#创建-Sway-项目" class="headerlink" title="创建 Sway 项目"></a>创建 Sway 项目</h1><blockquote><p>你们可以根据自己的理解去探索整个流程，自主探索是创新的必要条件</p></blockquote><p>在你自己常用的工作目录下创建一个目录（这是因为我们后面如果需要构建前端界面的话，一些指令需要相对路径，别担心，后续我们会表明出来可以自己 DIY 的点），然后进入该目录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> fuel-project <span class="comment"># fuel-project 可以改成您自己想要的名称</span></span><br><span class="line"><span class="built_in">cd</span> fuel-project</span><br></pre></td></tr></table></figure><p>然后创建一个智能合约项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forc new counter-project <span class="comment"># counter-project 可以改成您自己想要的项目名称，这里是因为接下来我们需要创建一个计数器智能合约，所以姑且叫这个名字</span></span><br></pre></td></tr></table></figure><p>这时候会发现我们的项目目录中会出现几个文件，主要是 <code>main.sw</code> 和 <code>Forc.toml</code>。其中，<code>Forc.toml</code> 相当于 NodeJS 中的 package.json 文件，用于管理我们的项目的依赖。<code>main.sw</code> 是我们主要的智能合约源码。</p><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>打开 <code>main.sw</code> 删除里面出现的所有代码然后复制粘贴以下代码。这个代码将实现一个计数器，这个计数器的数据将会保存在链上，而整个区块链就是我们的数据库。是的，这听起来超级酷！别担心，我们将会在这个示例代码中详细的写出整个程序的代码及注释。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract; // 声明我们写的代码是一份智能合约</span><br><span class="line"></span><br><span class="line">// 创建一个 storage，用来保存我们的计数器。</span><br><span class="line">storage &#123;</span><br><span class="line">    // 定义一个 计数器</span><br><span class="line">    // 数据类型是 u64（等效于 unsigned int-64）</span><br><span class="line">    // 初始化 0 给该变量</span><br><span class="line">    counter: u64 = 0,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个 ABI，理解成一个 Interface</span><br><span class="line">// ABI 用来定义我们的 Contract 中有多少个函数</span><br><span class="line">abi Counter &#123;</span><br><span class="line">    // fn 用来定义一个函数，这里我们定义一个 increment（增量）函数。</span><br><span class="line">    #[storage(read, write)]</span><br><span class="line">    fn increment();</span><br><span class="line">    </span><br><span class="line">    // 定义一个 count 函数，返回一个 u64 的值</span><br><span class="line">    #[storage(read)]</span><br><span class="line">    fn count() -&gt; u64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们刚刚定义了各种函数在 ABI 中，现在将其实现，也就是写函数</span><br><span class="line">// 这里能理解为，我们将 Counter 以 Contract 的形式实现</span><br><span class="line">impl Counter for Contract &#123;</span><br><span class="line">    // 首先实现读取计数器的函数</span><br><span class="line">    // 我们需要照抄 storage 的权限、函数名以及返回值</span><br><span class="line">    #[storage(read)]</span><br><span class="line">    fn count() -&gt; u64 &#123;</span><br><span class="line">        // 这个就是读取 storage 中 counter 的值</span><br><span class="line">        storage.counter.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：</p><ul><li>ABI 可以理解为一个接口（Interface），它应该被保存在一个独立的文件中，这里为了简易起见，我们将其直接写在我们的源码中。</li><li><code>#storage[(read, write)]</code> 这里暂时不明白 storage 的作用，姑且觉得是可以从 storage 访问数据<ul><li>read 和 write 用于设定我们对 storage 的操作权限</li></ul></li><li><code>storage.counter.read();</code> 其实是一个隐式返回值，<code>return</code> 关键字被隐式编写了，可以省略 <code>return</code> 关键字</li></ul><h2 id="构建智能合约"><a href="#构建智能合约" class="headerlink" title="构建智能合约"></a>构建智能合约</h2><p>请确保你现在是处于你的项目目录下的。然后运行以下指令来构建我们的智能合约</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forc build</span><br></pre></td></tr></table></figure><p>这时候项目中会自动创建 Forc.lock 和 构建好的位于 <code>./out/debug/</code> 下的可执行（在区块链中执行）文件。</p><blockquote><p>如果在这个过程中出现问题，多半是因为上方的代码有问题，需要进行调整。请发邮件和报错信息给我知道。或者参考<a href="https://docs.fuel.network/docs/intro/quickstart-contract">官方文档</a> 进行调整。</p></blockquote><h2 id="测试智能合约"><a href="#测试智能合约" class="headerlink" title="测试智能合约"></a>测试智能合约</h2><p>前面我们已经下载好了测试工具 <code>cargo-generate</code> 接下来运行这段指令以创建测试文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo generate --init fuellabs/sway templates/sway-test-rs --name counter-contract <span class="comment"># counter-contract </span></span><br></pre></td></tr></table></figure><p>执行完成后，会在 <code>test/</code> 目录下创建一个 <code>harness.rs</code> 文件，这是我们的自动化测试代码。在<strong>代码的末端</strong>添加以下代码，用于测试我们的计数器</p><figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[tokio::test]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">test_increment</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (instance, _id) = <span class="title function_ invoke__">get_contract_instance</span>().<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加计数器</span></span><br><span class="line">    instance.<span class="title function_ invoke__">methods</span>().<span class="title function_ invoke__">increment</span>().<span class="title function_ invoke__">call</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前计数器的数值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = instance.<span class="title function_ invoke__">methods</span>().<span class="title function_ invoke__">count</span>().<span class="title function_ invoke__">call</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言当前数值为 1</span></span><br><span class="line">    <span class="comment">// 因为我们在 storage 创建的计数器数值初始值为 0，计数过程为 + 1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(result.value, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在终端执行以下指令进行测试。</p><p>如果顺利的话，底下会出现类似 <code>test ... ok</code> 的字段。如果在这个过程中</p><h1 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h1><p>根据官方文档说明，我们也可以通过 Rust SDK 或 TypeScript SDK 进行操作，这里我们选择和官方相同的 forc。其他方法请参考<a href="https://docs.fuel.network/docs/intro/quickstart-contract/#deploy-the-contract">官方文档</a>进行学习。</p><h2 id="创建-导入钱包"><a href="#创建-导入钱包" class="headerlink" title="创建 / 导入钱包"></a>创建 / 导入钱包</h2><p>如果你们已经拥有钱包，可以直接通过以下指令进行钱包导入，然后通过助记词（mnemonic）来导入钱包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forc wallet import</span><br></pre></td></tr></table></figure><p>如果尚未拥有电子钱包，可以通过以下指令来创建一个新钱包。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forc wallet new</span><br></pre></td></tr></table></figure><h2 id="创建-刷新钱包账号"><a href="#创建-刷新钱包账号" class="headerlink" title="创建 / 刷新钱包账号"></a>创建 / 刷新钱包账号</h2><p>在创建 / 导入钱包之后，会发现钱包是空的（就算你是导入钱包，通过 <code>forc wallet accounts</code> 也无法列出你所拥有的钱包账户。这是因为 forc wallet 会将钱包缓存在本地中，而导入钱包并不会刷新本地缓存。这时候我们需要执行以下指令来创建 / 刷新钱包账号</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forc wallet account new</span><br></pre></td></tr></table></figure><h2 id="获取测试代币"><a href="#获取测试代币" class="headerlink" title="获取测试代币"></a>获取测试代币</h2><p>到 <a href="http://faucet-beta-4.fuel.network">faucet</a> 领取测试代笔，输入你的钱包地址，就可以获得 0.5 ETH 进行测试</p><h2 id="发布到测试网"><a href="#发布到测试网" class="headerlink" title="发布到测试网"></a>发布到测试网</h2><p>最后一步了！我们可以通过以下指令将合约部署到测试网上，在这之前我们需要配置 fuelup 工具链，使其默认使用 beta-4 作为工具链</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fuelup toolchain install beta-4</span><br><span class="line">fuelup default beta-4</span><br><span class="line"></span><br><span class="line"># 发布智能合约</span><br><span class="line">forc deploy --testnet</span><br></pre></td></tr></table></figure><p>执行完这个指令之后，会出现 <code>Contract deploy-to-beta-4 Deployed!</code> 字眼。接下来就能去区块链上查看自己的合约是否部署成功啦！鉴于官方给出的 Network Explorer 还是很烂，所以建议直接用该 Explorer 查询自己的钱包是否有交易记录</p><p><a href="https://fuellabs.github.io/block-explorer-v2/">Network Explorer 链接点此</a></p><blockquote><p>嗯是的，那个 Explorer 烂的很，只显示一个钱包最早的 10 条记录，没错！是<strong>最早</strong>的……</p></blockquote><h1 id="总结和不足"><a href="#总结和不足" class="headerlink" title="总结和不足"></a>总结和不足</h1><p>在开发过程中，经常会出现很多“玄学”的报错，代码完全相同，但就是在 <code>cargo test</code> 的过程中总是出错。以下是几个根据实际情况判断的可能发生的问题，还未经验证：</p><ol><li>由于我们开发环境是运行于 MacOS 上的 Ubuntu 虚拟机，而我们的计算机架构是 ARM64，可能在构建的时候会出现问题。</li><li>国内网络环境问题</li><li>开发者技术问题，Programmers are also a human and can make mistake。程序员也是人，也会犯错。可能是 Fuel 开发者的问题，期待后续的修复。</li></ol><p>后续需要再尝试几次构建，然后才能更加熟练的去编程及部署智能合约。不过基于现在还是在 Testnet 测试网的过程，所以不建议花费太长时间专研某种语言。更重要的是了解整个区块链的开发技术。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
          <category> Sway </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 Ubuntu 系统中安装 Node JS</title>
      <link href="/2024/ef0ee0b3.html"/>
      <url>/2024/ef0ee0b3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天需要尝试学习 Solidity 智能合约开发。需要在 Linux Ubuntu 环境下安装 Node JS，但是发现通过 Ubuntu 包管理器下载的 Node JS 已经过时，而官网下载的包是 <code>.tar.xz</code> 格式。这篇文章就来分享怎么讲 .tar.xz 的软件安装在 Ubuntu 系统中，并通过终端进行调用。</p><blockquote><p><strong>前提条件：</strong></p><p>我的开发环境如下：</p><ul><li>Ubuntu 22.04（在 Parallel Desktop 上运行）</li><li>Mac OS M2 Chip</li></ul></blockquote><p>由于使用 <code>sudo apt install nodejs</code> 安装的 NodeJS 版本为 12.x，稍显过时。为了获取 20 版本的 NodeJS，我们需要前往 <a href="https://nodejs.org/en/download/">NodeJS 官网</a> 进行下载。选择适用于我们的开发环境 Ubuntu 22.04，且<strong>运行于 ARM 架构</strong>上（M2 芯片为 ARM 架构）的 Linux Binaries (ARM) 发行包。在我的情况中，我下载了 ARMv8 版本，下载完成后，文件夹中将出现 <code>node-v20.11.0-linux-arm64.tar.xz</code>。</p><p>首先卸载之前安装的旧版本 NodeJS：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove nodejs</span><br></pre></td></tr></table></figure><p>然后使用 <code>tar</code> 命令解压：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据实际情况修改文件名称</span></span><br><span class="line">tar -xsf node-v20.11.0-linux-arm64.tar.xz</span><br></pre></td></tr></table></figure><p>接下来更改解压得到的文件夹名称，我个人习惯更改为避免影响 <code>/usr/</code> 下的 node 目录名：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据实际情况修改文件名称</span></span><br><span class="line">sudo <span class="built_in">cp</span> -r ./node-v20.11.0-linux-arm64.tar.xz/ ./node/</span><br></pre></td></tr></table></figure><p>将 node 添加到 bin 目录下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为我们上面改了 node 文件夹名称，所以这里直接用 node</span></span><br><span class="line">sudo <span class="built_in">cp</span> -r ./node/&#123;bin,include,libs,share&#125; /usr/</span><br></pre></td></tr></table></figure><p>将可执行文件添加到 PATH 中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/node/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>最后，检查你的 node 版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 系列 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
          <category> Linux Ubuntu </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node JS </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> ARM架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[How-To Fix] Error while installing cargo-generate</title>
      <link href="/2024/77854802.html"/>
      <url>/2024/77854802.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Troubleshooting-Cargo-Generate-Installation-for-Sway-Smart-Contract-Deployment"><a href="#Troubleshooting-Cargo-Generate-Installation-for-Sway-Smart-Contract-Deployment" class="headerlink" title="Troubleshooting Cargo Generate Installation for Sway Smart Contract Deployment"></a>Troubleshooting Cargo Generate Installation for Sway Smart Contract Deployment</h1><p>When deploying a Sway Smart Contract, an essential step is to test the contract using <code>cargo test</code>. To facilitate this, we first need to generate the default test harness, which requires installing <code>cargo generate</code>. However, you might encounter errors during the installation process. Here’s how to resolve them.</p><h2 id="Installing-Cargo-Generate"><a href="#Installing-Cargo-Generate" class="headerlink" title="Installing Cargo Generate"></a>Installing Cargo Generate</h2><p>Begin by installing <code>cargo generate</code> using the following command:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install cargo-generate</span><br></pre></td></tr></table></figure><h2 id="Error-Solutions"><a href="#Error-Solutions" class="headerlink" title="Error Solutions"></a>Error Solutions</h2><h3 id="Error-Linker-cc-Not-Found"><a href="#Error-Linker-cc-Not-Found" class="headerlink" title="Error: Linker cc Not Found"></a>Error: Linker cc Not Found</h3><p>The first error you might encounter an error stating <code>Linker cc not found</code>. This can be resolved by installing <code>build-essential</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><h3 id="Error-openssl-sys-V0-9-98-Build-Failed"><a href="#Error-openssl-sys-V0-9-98-Build-Failed" class="headerlink" title="Error: openssl-sys V0.9.98 Build Failed"></a>Error: openssl-sys V0.9.98 Build Failed</h3><p>After fixing the linker <code>cc</code> error, you might encounter another error related to <code>openssl-sys</code> failing to build. Resolve this by installing the necessary libraries:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt install pkg-config</span><br><span class="line">sudo apt-get install libudev-dev </span><br></pre></td></tr></table></figure><h2 id="Final-Steps"><a href="#Final-Steps" class="headerlink" title="Final Steps"></a>Final Steps</h2><p>Once these issues are resolved, you can proceed with reinstalling <code>cargo generate</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install cargo-generate</span><br></pre></td></tr></table></figure><p>After successfully executing these steps, your development environment should be set up to test and deploy Sway Smart Contracts.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 系列 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
          <category> Linux Ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[How-To Fix] VS Code Installation Failure on Ubuntu</title>
      <link href="/2024/27ee556c.html"/>
      <url>/2024/27ee556c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Error-while-Installing-VSCode-on-Ubuntu"><a href="#Error-while-Installing-VSCode-on-Ubuntu" class="headerlink" title="Error while Installing VSCode on Ubuntu"></a>Error while Installing VSCode on Ubuntu</h1><p>Many users encounter challenges when installing Visual Studio Code (VS Code) on Ubuntu, especially when running it on a virtual machine. This article addresses a common error and provides a step-by-step solution.</p><h2 id="My-Environment"><a href="#My-Environment" class="headerlink" title="My Environment"></a>My Environment</h2><p>I am using Ubuntu 22.04, running on Parallel Desktop on a MacOS with an M2 Chip.</p><h2 id="The-Issue"><a href="#The-Issue" class="headerlink" title="The Issue"></a>The Issue</h2><p>While attempting to install VS Code, downloaded from the <a href="https://code.visualstudio.com/Download">official website</a>, using the following command:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install ./code_1.85.1-1702462158_amd64.deb</span><br></pre></td></tr></table></figure><p>I encountered dependency errors:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree... Done</span><br><span class="line">Reading state information... Done</span><br><span class="line">Note, selecting &#x27;code:amd64&#x27; instead of &#x27;./code_1.85.1-1702462158_amd64.deb&#x27;</span><br><span class="line">Some packages could not be installed. This may mean that you have</span><br><span class="line">requested an impossible situation or if you are using the unstable</span><br><span class="line">distribution that some required packages have not yet been created</span><br><span class="line">or been moved out of Incoming.</span><br><span class="line">The following information may help to resolve the situation:</span><br><span class="line"></span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> code:amd64 : Depends: libasound2:amd64 (&gt;= 1.0.17) but it is not installable</span><br><span class="line">              Depends: libatk-bridge2.0-0:amd64 (&gt;= 2.5.3) but it is not installable</span><br><span class="line">              Depends: libatk1.0-0:amd64 (&gt;= 2.2.0) but it is not installable</span><br><span class="line">              Depends: libatspi2.0-0:amd64 (&gt;= 2.9.90) but it is not installable</span><br><span class="line">              Depends: libc6:amd64 (&gt;= 2.14) but it is not installable</span><br><span class="line">              Depends: libc6:amd64 (&gt;= 2.16) but it is not installable</span><br><span class="line">              Depends: libc6:amd64 (&gt;= 2.17) but it is not installable</span><br><span class="line">              Depends: libc6:amd64 (&gt;= 2.2.5) but it is not installable</span><br><span class="line">              Depends: libcairo2:amd64 (&gt;= 1.6.0) but it is not installable</span><br><span class="line">              Depends: libcurl3-gnutls:amd64 but it is not installable or</span><br><span class="line">                       libcurl3-nss:amd64 but it is not installable or</span><br><span class="line">                       libcurl4:amd64 but it is not installable or</span><br><span class="line">                       libcurl3:amd64 but it is not installable</span><br><span class="line">              Depends: libdbus-1-3:amd64 (&gt;= 1.5.12) but it is not installable</span><br><span class="line">              Depends: libdrm2:amd64 (&gt;= 2.4.75) but it is not installable</span><br><span class="line">              Depends: libexpat1:amd64 (&gt;= 2.0.1) but it is not installable</span><br><span class="line">              Depends: libgbm1:amd64 (&gt;= 17.1.0~rc2) but it is not installable</span><br><span class="line">              Depends: libglib2.0-0:amd64 (&gt;= 2.37.3) but it is not installable</span><br><span class="line">              Depends: libgssapi-krb5-2:amd64 but it is not installable</span><br><span class="line">              Depends: libgtk-3-0:amd64 (&gt;= 3.9.10) but it is not installable</span><br><span class="line">              Depends: libgtk-3-0:amd64 (&gt;= 3.9.10) but it is not installable or</span><br><span class="line">                       libgtk-4-1:amd64 but it is not installable</span><br><span class="line">              Depends: libkrb5-3:amd64 but it is not installable</span><br><span class="line">              Depends: libnspr4:amd64 (&gt;= 2:4.9-2~) but it is not installable</span><br><span class="line">              Depends: libnss3:amd64 (&gt;= 2:3.30) but it is not installable</span><br><span class="line">              Depends: libnss3:amd64 (&gt;= 3.26) but it is not installable</span><br><span class="line">              Depends: libpango-1.0-0:amd64 (&gt;= 1.14.0) but it is not installable</span><br><span class="line">              Depends: libx11-6:amd64 but it is not installable</span><br><span class="line">              Depends: libx11-6:amd64 (&gt;= 2:1.4.99.1) but it is not installable</span><br><span class="line">              Depends: libxcb1:amd64 (&gt;= 1.9.2) but it is not installable</span><br><span class="line">              Depends: libxcomposite1:amd64 (&gt;= 1:0.4.4-1) but it is not installable</span><br><span class="line">              Depends: libxdamage1:amd64 (&gt;= 1:1.1) but it is not installable</span><br><span class="line">              Depends: libxext6:amd64 but it is not installable</span><br><span class="line">              Depends: libxfixes3:amd64 but it is not installable</span><br><span class="line">              Depends: libxkbcommon0:amd64 (&gt;= 0.4.1) but it is not installable</span><br><span class="line">              Depends: libxkbfile1:amd64 but it is not installable</span><br><span class="line">              Depends: libxrandr2:amd64 but it is not installable</span><br><span class="line">              Recommends: libvulkan1:amd64 but it is not installable</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure><h1 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h1><p>The key to resolving this issue lies in matching the architecture of your operating system with the correct VS Code build. Since my setup involves an ARM64 architecture on MacOS, I needed to download the ARM64 version of VS Code.</p><p>I downloaded the ARM64 .deb version from the Official Website and installed it using the terminal. This resolved the problem.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>By downloading the correct version of VS Code that matches the system’s architecture, I successfully resolved the installation issue. This solution is particularly relevant for those running Ubuntu on virtual machines with different underlying hardware architectures. Always ensure to check the compatibility of your system with the software version you’re attempting to install.</p><hr><p>For more tips and tricks on software installation and troubleshooting, stay tuned to this blog!</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Linux Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leo 语言 Hello World 的学习心得</title>
      <link href="/2024/d4d355b7.html"/>
      <url>/2024/d4d355b7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>先打个强心针，我目前涉及的行业只能说和之前所学的大不相同——区块链。</p></blockquote><p>今天接到一个任务：将 Leo 语言学会，然后短时间内创建一个简单的区块链框架。以下文章作为今天的学习心得。项目已经开源到 <a href="https://github.com/hubei-xhjy/hello">hubei-xhjy</a> 的仓库中，需要的同学自取。</p><h1 id="安装-Leo"><a href="#安装-Leo" class="headerlink" title="安装 Leo"></a>安装 Leo</h1><p>这个过程主要看网络环境，我下了半小时左右，期间利用时间来查询一些相关资料及文档，我的环境是 MacOS，需要安装 git 和 rust。git 的安装很简单（Mac OS 自带），而 rust 则需要执行以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure><p>通过以下指令来查看环境是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">cargo --version</span><br></pre></td></tr></table></figure><p>然后在你习惯的 working directory （比如说我 <code>cd ~/src/</code>） 克隆 Leo 项目，并安装 Leo</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AleoHQ/leo</span><br><span class="line"><span class="built_in">cd</span> leo</span><br><span class="line"></span><br><span class="line">cargo install --path .</span><br></pre></td></tr></table></figure><p>执行完这一步之后，将会在 <code>~/.cargo/bin/leo</code> 创建一个可执行文件。</p><p>可以通过在终端运行以下指令来验证安装是否成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leo</span><br></pre></td></tr></table></figure><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>我使用的开发环境是 VSCode，直接在应用商店搜寻 <code>Leo</code> 然后安装第一个插件（作者：<code>aleohq</code>，识别号：<code>aleohq.leo-extension</code>）</p><h1 id="创建第一个-Leo-项目"><a href="#创建第一个-Leo-项目" class="headerlink" title="创建第一个 Leo 项目"></a>创建第一个 Leo 项目</h1><p>回到你的 working directory（这一步很重要！），通俗点就是 terminal 的位置要在你平时放代码的目录。leo 创建的项目和其他编程环境一样（如 Node JS），会创建一个项目文件夹。</p><p>然后执行以下指令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leo new hello</span><br><span class="line"><span class="built_in">cd</span> hello</span><br></pre></td></tr></table></figure><p>这时候会创建一个 leo 项目目录，并将其命名为 hello，然后我们进入 hello 文件夹中。里边的文件列表是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello/</span><br><span class="line">├── .env          # 程序的环境配置</span><br><span class="line">├── program.json  # 程序的 Manifest 文件</span><br><span class="line">├── README.md     # 文件文档</span><br><span class="line">├── build/        # 构建出的可执行文件</span><br><span class="line">├── inputs/       # 文件的输入</span><br><span class="line">│ ├── hello.in    # 程序的输入参数在这里设置</span><br><span class="line">└── src/          # 源程序</span><br><span class="line">  └── main.leo    # 程序源代码</span><br></pre></td></tr></table></figure><h1 id="执行项目"><a href="#执行项目" class="headerlink" title="执行项目"></a>执行项目</h1><p>因为创建的项目中已经有一个写好的 example 文件，所以我们可以通过以下指令编译并运行程序</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leo run main</span><br></pre></td></tr></table></figure><blockquote><p>一些细节上的内容可以直接查看<a href="https://developer.aleo.org/leo/hello">官方文档</a>，由于篇幅限制就不再赘述</p></blockquote><h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><p>源程序给出了这么一段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The &#x27;hello&#x27; program.</span><br><span class="line">program hello.aleo &#123;</span><br><span class="line">    transition main(public a: u32, b: u32) -&gt; u32 &#123;</span><br><span class="line">        let c: u32 = a + b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>hello.aleo</code> 是我们的程序名称，他必须和我们的 Manifest 文件中的 <code>program</code> 字段相对应。</li><li><code>transition</code> 的意思是构建了一个 transition 函数，目前尚未对 <code>transition</code> 函数有了解，但是本文后面有对该函数的猜想<ul><li>然后 <code>main</code> 函数中携带了两个参数：</li><li><code>public a: u32</code>: <ul><li>u32 初步判断为其他编程语言中 <code>unsigned int32</code> 类型</li><li>public 指的是这个函数的可见性是公共的。</li></ul></li><li><code>b: u32</code>: <ul><li>这个是私有变量，默认变量作用域就是私有变量</li></ul></li><li><code>-&gt; u32</code>:<ul><li>这个写法说明 main 函数返回一个 u32 的值</li></ul></li></ul></li><li>理论上 <code>main</code> 可以是任何一个英文单词（在本文后面会讲解关于：关键字、输入文件等相关概念）</li><li>函数中使用 <code>let</code> 语法定义了一个 c 变量，类型也为 u32（和我们的返回值相同）<ul><li>它的值就是 <code>a + b</code>。由此可见我们的 main 函数执行的功能就是两数相加</li></ul></li><li>最后再通过 <code>return</code> 语法返回 c 变量。</li></ul><blockquote><p>官方提到，由于开发者也是人类，也会犯错，所以他们将该编程语言设计成强类型编程语言。</p><p>但是我在这里吐槽一下，这种类型的语法未免也太魔鬼了吧。第一眼看到这个写法我的直觉是好复杂。</p></blockquote><h1 id="文件输入"><a href="#文件输入" class="headerlink" title="文件输入"></a>文件输入</h1><p>我们来观察 <code>hello.in</code> 文件，这将是我们 <code>hello.aleo</code> 程序的输入。</p><blockquote><p>暂时不知道作者这么操作的意图（或者说输入文件存在的意义）是什么，正如我一开始所说，区块链是我最近才深入接触的领域。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">public a: u32 = 1u32;</span><br><span class="line">b: u32 = 2u32;</span><br></pre></td></tr></table></figure><p>可以看到，<code>[main]</code> 代指以下的信息是会传递给 main 函数的，其中传递：<code>public a: u32</code> （这个值和上面函数定义的值相同），而它的值为：<code>1u32</code>。如果将其置换为其他编程语言表示，应该是这样：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UInt32 a = <span class="number">32</span>; </span><br></pre></td></tr></table></figure><p>换言之，它的数据表达应该是 【值 类型】。</p><h1 id="验证猜想"><a href="#验证猜想" class="headerlink" title="验证猜想"></a>验证猜想</h1><p>有了上面的实操经验，接下来我来验证一些我在学习中的猜想</p><h2 id="猜想：一个-program-中可以有多个函数"><a href="#猜想：一个-program-中可以有多个函数" class="headerlink" title="猜想：一个 program 中可以有多个函数"></a>猜想：一个 program 中可以有多个函数</h2><p>因为我注意到我们是通过 <code>leo run main</code> 指令来执行程序，而非 <code>leo run</code> 或者 <code>leo run hello.aleo</code>。这样我猜测 <code>leo run main</code> 其实是执行 <code>main</code> 函数。这就是说，一个 Leo 程序可以拥有多个 transition 函数。于是我增加了这么一句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transition substract(public a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    let c: i32 = a - b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到：我增加了一个 <code>substract</code> 函数，参数需求和 main 函数几乎相同，不同的是数据类型由 <code>u32</code> 变为 <code>i32</code>。也就是一般编程语言中的 <code>int</code>。返回值也同样变成了整型。而函数执行的是 <code>a - b</code> 并将其返回。</p><p>我们先不急着执行这个函数，别忘了我们还需要去定义函数的输入，现在渠道 <code>hello.in</code> 文件。</p><h2 id="猜想：hello-文件中可以对不同的函数定义不同的输入"><a href="#猜想：hello-文件中可以对不同的函数定义不同的输入" class="headerlink" title="猜想：hello 文件中可以对不同的函数定义不同的输入"></a>猜想：hello 文件中可以对不同的函数定义不同的输入</h2><p>上面我们定义了一个 <code>[main]</code> 函数的输入，那么在这里，函数中我们创建了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[substract]</span><br><span class="line">public a: i32 = 4i32;</span><br><span class="line">b: i32 = 2i32;</span><br></pre></td></tr></table></figure><p>因为我们创建的是 substrate 函数，所以这里也需要写上 <code>[substract]</code>，让程序知道这个输入是给 substract 函数使用的。</p><p>同样的，我们要给对应的变量定义正确的数据类型，在这里是 <code>i32</code>。</p><h2 id="猜想：除了-main-函数，我们也可以执行别的函数"><a href="#猜想：除了-main-函数，我们也可以执行别的函数" class="headerlink" title="猜想：除了 main 函数，我们也可以执行别的函数"></a>猜想：除了 main 函数，我们也可以执行别的函数</h2><p>上面学的是 <code>leo run main</code>，然后它执行的是 main 函数嘛。那我们可以通过修改 run 之后的值，来执行别的函数，如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">leo run substract</span><br></pre></td></tr></table></figure><p>执行这段指令之后，会执行我们自定义的 substract 函数。并执行减法输出。</p><h2 id="猜想：leo-程序的执行顺序"><a href="#猜想：leo-程序的执行顺序" class="headerlink" title="猜想：leo 程序的执行顺序"></a>猜想：leo 程序的执行顺序</h2><p>当我们执行 <code>leo run xxx</code> 时，它会运行 <code>xxx</code> 函数，然后再去 input 文件夹找到对应 <code>[xxx]</code> 的输入，并执行计算然后输出结果。</p><h1 id="验证过程中的意外收获"><a href="#验证过程中的意外收获" class="headerlink" title="验证过程中的意外收获"></a>验证过程中的意外收获</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>为什么我们创建的是 <code>substract</code> 函数而不是 <code>sub</code> 函数。我已经尝试过了，最后得出的结论：</p><blockquote><p>在执行 <code>leo run xxx</code> 之后 leo 将会把我们的源码打包成 <code>aleo</code>。一种类似汇编语言的代码，位于 <code>build/</code> 文件夹中。而 <code>sub</code> 正是 “汇编” 语言中的其中一个关键词。所以我们不能通过 <code>sub</code> 作为函数。</p></blockquote><p>如果在定义用户标识符使用关键字，那么 leo 会报出：<code>Failed to parse string</code> 报错。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于 Leo 语言，可能是新兴编程语言的缘故，想要做出差异化。反而使得代码更加的晦涩难懂。何况这种直接转义成“汇编语言”的骚操作，导致一些代码会变得更加冗余。后续的文章中将会对区块链的各种开发语言进行学习与比较。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> 我在 Web3 行业摸爬滚打的日子 </category>
          
          <category> 区块链 </category>
          
          <category> Leo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学网页设计 3 让网页变成响应式页面</title>
      <link href="/2024/2d85c0dd.html"/>
      <url>/2024/2d85c0dd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="视口-Viewport"><a href="#视口-Viewport" class="headerlink" title="视口 Viewport"></a>视口 Viewport</h1><p>在我们开始使我们的着陆页面响应式之前，我们需要了解一些概念。</p><p>第一个概念是视口 (Viewport) ：网页的可见区域。</p><p>通常，具有固定宽度的网页在小屏幕上，如移动设备或平板电脑上，变得太大而无法适应视口。为了解决这个问题，这些设备上的浏览器会缩小整个网页以适应屏幕。</p><p>在HTML5中，您可以使用 meta 标签控制视口：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>width=device-width</code> 设置页面的宽度以适应设备的屏幕宽度。<code>initial-scale=1.0</code> 设置页面在浏览器首次加载时的初始缩放级别。</p><div class="note info flat"><p>您还可以在视口标签中使用自定义值，但在大多数情况下，建议使用 <code>device-width</code> 值来使用默认设置。</p></div><h1 id="媒体查询-Media-Queries"><a href="#媒体查询-Media-Queries" class="headerlink" title="媒体查询 Media Queries"></a>媒体查询 Media Queries</h1><p>媒体查询提供了为视口不同宽度或其他规格指定不同CSS样式的能力。</p><p>这使得网页能够为不同屏幕尺寸定义不同的布局样式，使页面响应式！</p><p>您可以使用现有样式表中的 @media 规则定义媒体查询：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">   <span class="selector-tag">body</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@media 规则后跟我们要定位的媒体类型（在我们的例子中是屏幕），并设置规则适用的条件（在我们的例子中是 <code>max-width:600px</code> ）。</p><div class="note info flat"><p>因此，现在样式将在页面宽度最大为600px时应用。</p></div><details class="toggle" ><summary class="toggle-button" style="">对于 Media Query 的实例</summary><div class="toggle-content"><p>实例在这里 <a href="https://kingsmai.github.io/resp-web-design/">https://kingsmai.github.io/resp-web-design/</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>理解响应式设计<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1. 调整屏幕大小以查看变化</span></span><br><span class="line"><span class="comment">    2. 检查底部的CSS，我已经解释了代码的所有内容。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#373737</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">max-width: 500px; 意味着它将</span></span><br><span class="line"><span class="comment">从0像素到500像素开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: teal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">min-width: 600px; 意味着它将</span></span><br><span class="line"><span class="comment">从600像素开始，直到更高，除非设置了某个断点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: crimson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">min-width: 700px 和 max-width: 900px</span></span><br><span class="line"><span class="comment">意味着它将从700像素开始，当屏幕尺寸超过900像素时停止</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">700px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: tomato;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整屏幕大小以查看变化 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果您的屏幕尺寸保持在501到599之间，它将显示黑色背景颜色。实际上不是黑色，而是十六进制码为#373737。</span></span><br><span class="line"><span class="comment">请看body样式的顶部。默认的背景颜色是#373737。</span></span><br><span class="line"><span class="comment">所以总结一下，当您的屏幕尺寸为0到500时，它将显示蓝绿色背景颜色，当保持在501到599之间时，它将显示黑色背景颜色。</span></span><br><span class="line"><span class="comment">当您的屏幕尺寸为600像素时，它将显示深红色背景颜色。当您的屏幕尺寸为700到900时，它将显示番茄色背景颜色。</span></span><br><span class="line"><span class="comment">当屏幕尺寸超过900像素时，它将再次显示深红色背景颜色。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我有任何错误，请告诉我。</span></span><br><span class="line"><span class="comment">照顾好自己，也照顾好您的灵魂。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div></details><p>您还可以定义多个条件，例如视口的最小和最大宽度：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">   <span class="selector-tag">body</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，这个样式将适用于屏幕宽度从 800 到 1024 像素的范围内。</p><p>您还可以为单个网页定义多个媒体查询。</p><div class="note info flat"><p>媒体查询允许您定义页面布局和样式应该何时更改的断点，以及定义这些断点的相应CSS样式。</p></div><div class="note warning flat"><p>不要被您设备的屏幕分辨率搞混了！像素作为测量单位相当于1⁄96英寸，所以：1英寸 = 96像素，这意味着这些宽度相当于：</p><ul><li>480 像素 / 96 = 5 英寸（例如移动电话）</li><li>768 像素 / 96 = 8 英寸（例如平板电脑）</li><li>1200 像素 / 96 = 12.5 英寸（例如显示器）</li></ul><p>（在我的理解中应该是这样的：具有QHD分辨率的移动电话：1440 × 2560像素，尺寸为5英寸，像素密度约为580像素每英寸。因此，它的宽度为：1440 像素 / 580 像素约为 2.5 英寸，乘以像素作为单位：2.5 * 96 = 240 像素）</p></div><h1 id="响应式页眉-Header-Part"><a href="#响应式页眉-Header-Part" class="headerlink" title="响应式页眉 Header Part"></a>响应式页眉 Header Part</h1><p>现在，我们知道如何为不同屏幕尺寸定义 CSS 样式，我们可以开始使我们的着陆页面具有响应性！</p><p>移动屏幕的典型断点是 480 像素宽度。</p><p>让我们为我们的着陆页面定义视口和空的媒体查询目标：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在屏幕宽度低于 480 像素时，我们将为各个部分创建单独的样式。</p><div class="note info flat"><p>480 像素是移动设备的典型断点。</p><p>这些是用于不同屏幕尺寸的媒体查询的一些示例：</p><ul><li>320px — 480px: 适用于大多数移动设备。</li><li>481px — 768px: 适用于iPad、平板电脑。</li><li>769px — 1024px: 适用于小屏幕，如笔记本电脑。</li><li>1025px — 1200px: 适用于台式机、较大屏幕。</li></ul></div><p>在移动屏幕上，我们希望更改标题文本的文字大小，并使“立即下载”按钮跨足容器的整个宽度。</p><p>为实现这一目标，我们在媒体查询中定义相应的样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">0</span> <span class="number">15px</span> <span class="number">0</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所见，我们更改了一些 font-size 属性，更改了 section 容器的内边距，并将按钮的 display 属性更改为 block，使其成为块级元素，占据其容器的整个宽度。</p><p>在移动屏幕上的结果：</p><p><img src="/uploads/sololearn/responsive-web-design/mobile-screen-header.png" alt="Mobile Screen Header"></p><p>在较大屏幕上的相同标题：</p><p><img src="/uploads/sololearn/responsive-web-design/large-screen-header.png" alt="Large Screen Header"></p><div class="note info flat"><p>请注意，我们无需在媒体查询中重新定义元素的整个样式。我们只需定义我们想要更改的样式。</p></div><h1 id="响应式功能部分-Features-Part"><a href="#响应式功能部分-Features-Part" class="headerlink" title="响应式功能部分 Features Part"></a>响应式功能部分 Features Part</h1><p>是时候使功能部分具有响应性了！它包含三个并排对齐的功能。</p><p>在小屏幕上，我们希望它们水平排列，每个功能占据容器的整个宽度。</p><p>以下是我们将在媒体查询中使用的样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.feature</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.feature</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">15%</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将每个功能div的宽度更改为 100％，并将 display 属性设置为 flex，使 div 成为 flexbox 容器。这使我们能够水平定位子功能，并使用 align-items 和 justify-content 属性设置其子元素（图标和文本）的对齐方式。</p><p>我们还设置了图标的宽度并定义了一些边距。</p><div class="note info flat"><p>现在，在较大屏幕上，功能将并排对齐，在较小屏幕上，它们将垂直排列。</p></div><h2 id="弹性盒子-Flexbox"><a href="#弹性盒子-Flexbox" class="headerlink" title="弹性盒子 Flexbox"></a>弹性盒子 Flexbox</h2><p>弹性盒子（Flexbox）布局模型允许轻松创建灵活的布局，无需使用CSS定位和浮动。</p><p>让我们使用一个简单的例子来演示它的工作原理：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要使用Flexbox，我们首先定义一个容器并将其display属性设置为flex。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以通过使用Flexbox属性调整子div元素的对齐方式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-items</span>: stretch;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">line-height</span>: <span class="number">75px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">30px</span>; </span></span><br><span class="line"><span class="language-css">      <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这将使所有子元素具有相同的宽度（flex: 1）并填充整个容器宽度。</p><p>查看这里的<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">完整Flexbox指南</a>。</p><h1 id="响应式引用部分-Quote-Part"><a href="#响应式引用部分-Quote-Part" class="headerlink" title="响应式引用部分 Quote Part"></a>响应式引用部分 Quote Part</h1><p>对于我们的引用部分，我们将只更改文本大小和一些内边距：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.quote</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">cite</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不需要更改部分元素的位置，因为它们已经对齐到屏幕的中央。</p><h1 id="响应式页脚-Footer-Part"><a href="#响应式页脚-Footer-Part" class="headerlink" title="响应式页脚 Footer Part"></a>响应式页脚 Footer Part</h1><p>最后但同样重要的是，我们需要更改我们的页脚部分。</p><p>我们需要将菜单链接放置在彼此下方：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行<br>display:block; 样式使列表项成为块级元素，因此它们将占据其容器的整个宽度。这使得项目在彼此下方对齐：</p><p><img src="/uploads/sololearn/responsive-web-design/mobile-screen-footer.png" alt="Mobile Screen Footer"></p><p>在大屏幕上的相同页脚：</p><p><img src="/uploads/sololearn/responsive-web-design/large-screen-footer.png" alt="Large Screen Footer"></p><p>现在我们的着陆页面是完全响应式的，适用于移动和桌面屏幕。</p><div class="note info flat"><p>定制着陆页面，添加更多部分和断点，并在下方的评论部分分享您的创作！示例：</p><p><a href="https://code.sololearn.com/WE9JO3XT9v9m/?ref=app">https://code.sololearn.com/WE9JO3XT9v9m/?ref=app</a> This code is responsive but done without @media queries.</p></div><h1 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h1><p>在我们的布局中，一个重要的部分是没有使用任何固定单位来定义宽度。</p><p>我们使用了百分比值，这使得元素相对于其父元素的宽度进行伸展。</p><p>这种方法使得元素更加灵活，这在创建响应式设计时至关重要。</p><p>CSS 还允许您为字体大小定义相对单位大小：</p><p>em 单位大小将相对于父元素的字体大小。</p><p>例如，如果我们页面的 body 具有 16 像素的字体大小，使用 1.5em 将等于 24 像素（16 * 1.5）：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击运行<br>这很有用，因为当您需要更改字体大小时，您只需在顶级父元素上更改它。所有子元素将使用em单位从中获取相应的相对大小。</p><div class="note info flat"><p>然而，当您使用 em 定义所有大小时，您可能会受到级联效应的影响。在这种情况下，您有许多嵌套的元素，它们使用相对于其相应父级的字体大小，这导致难以控制的单位大小。</p></div><h2 id="CSS-单位的练习"><a href="#CSS-单位的练习" class="headerlink" title="CSS 单位的练习"></a>CSS 单位的练习</h2><p>在使用以下CSS的情况下，一个位于div元素内的段落的字体大小是多少？</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是：<span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">15px</span></span></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><p>em 单位相对于父元素的字体大小值。这里 div 的父元素是 body。因此，</p><ul><li>对于div <ul><li>=&gt; 1em == 父元素的字体大小 == 10 像素；</li><li>0.5 em == 5 像素。</li></ul></li></ul><p>现在p的父元素是div。因此，</p><ul><li>对于p <ul><li>=&gt; 1em == 父元素的字体大小 == 5 像素，</li><li>3em == 15 像素。</li></ul></li></ul><p>这就是答案为15像素的原因。</p></div></details><h2 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h2><p>另一个相对单位是 rem。它代表 根 em（Root Em），意味着它只关注根元素的字体大小，即 html 元素。<br>这使得它比 em 更容易使用。</p><p>让我们将着陆页面的字体大小更改为rem单位：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">3rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将html元素的字体大小设置为 16px，并使用它来使用 rem 设置所有其他字体大小。</p><p>您还可以在边距和内边距中使用相对的 CSS 单位。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Sololearn 自学网页设计 </category>
          
          <category> HTML, CSS, JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【话题】编程语言的未来 一个以自然语言作为编程语言的构思</title>
      <link href="/2024/f1de6892.html"/>
      <url>/2024/f1de6892.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>文章目录</strong></p><ul><li><a href="#前言">前言</a></li><li><a href="#现阶段的-ai-能力">现阶段的 AI 能力</a></li><li><a href="#基于-ai-的自然语言编程构思">基于 AI 的自然语言编程构思</a><ul><li><a href="#编程语言设计">编程语言设计</a></li><li><a href="#与现阶段-ai-产品的不同之处">与现阶段 AI 产品的不同之处</a></li></ul></li><li><a href="#预计的技术屏障">预计的技术屏障</a><ul><li><a href="#生成的代码效率不高">生成的代码效率不高</a></li><li><a href="#无法符合用户预期">无法符合用户预期</a></li><li><a href="#自然语言处理的注意力与记忆不足">自然语言处理的注意力与记忆不足</a></li><li><a href="#人工智能没有想象力">人工智能没有想象力</a></li><li><a href="#ai-需要的知识点更加庞大了可能目前的大语言模型都无法满足">AI 需要的知识点更加庞大了，可能目前的大语言模型都无法满足</a></li><li><a href="#消费型计算机算力不高">消费型计算机算力不高</a></li><li><a href="#多文件处理能力">多文件处理能力</a></li></ul></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着 2022 年 11 月 30 日 ChatGPT 横空出世以来，各行各业都受到或多或少的冲击，很多外行人都觉得在某些领域中不再是那么的高深莫测，不理解的知识点，都可以通过 ChatGPT 或者类似的 chat bot 进行“搜索”并获得摘要。对于咱们程序员来说，最大的改变莫过于是“人人都可以写代码了”。确实，对于一个外行来说，只要你具备自己手动配置环境的能力（随便搭一个 Python 环境很简单吧？），再加上一定的想象力以及对自己想象出来的产品的表达能力，基本上可以通过 ChatGPT 完成一个简单的程序 Demo。于是乎，要自己手动做一个软件产品，应该至少具备以下两种基本能力：</p><ul><li>有 DIY 的能力（至少能够搭建一个简单的开发环境）</li><li>比较强的表达能力（至少能够精确的说出你要做什么，应该怎么做，期望得到的结果）</li></ul><p>而我所构思的项目，则是面向同时具备这两种特征的人。尤其是具备第二点的人。</p><p>更正一下，我并不赞同“人人都可以写代码了”这个说法，确切的说，应该是指“人人都有机会构建自己的 demo 了”。得益于 ChatGPT 的帮助，我们确实可以在开发中进行加速，甚至我们可以使用 AutoGPT 让计算机自动的进行搜索，并构建出一个简单的软件。但是还远没有达到我所构想的“AI 编程语言”这种存在于科幻片中的终极编程语言。</p><p><img src="/uploads/images/auto-gpt.png" alt="AutoGPT"></p><h1 id="现阶段的-AI-能力"><a href="#现阶段的-AI-能力" class="headerlink" title="现阶段的 AI 能力"></a>现阶段的 AI 能力</h1><p>现阶段，人工智能更多的是以“助理”的身份存在于人们的生活中。偶尔帮忙处理数据分析、文案润色、绘图等。虽说有 AutoGPT 的存在，但是通过林亦所展示的视频来看，AutoGPT 执行到一半就会陷入一种诡异的死循环。明知道做错了，但还是一直重复错误的操作。这个问题姑且算作是“AI 的注意力与记忆力不足”所产生的问题。由此可见，AI 在进行开发过程还是有很大的技术问题的。</p><h1 id="基于-AI-的自然语言编程构思"><a href="#基于-AI-的自然语言编程构思" class="headerlink" title="基于 AI 的自然语言编程构思"></a>基于 AI 的自然语言编程构思</h1><p>我所构想的 AI 编程语言是这样的：用户作为产品经理对整个项目进行构思，并将想要的产品效果以图文形式发给 AI 处理。AI 直接通过人们输入的自然语言，将其进行理解并自动输出成源码。</p><h2 id="编程语言设计"><a href="#编程语言设计" class="headerlink" title="编程语言设计"></a>编程语言设计</h2><p>用户在开发过程中，可以使用自己所常用的语言进行“编程”。编程语言以白话文为主，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[软件简介]: 用于让 AI 确定整个软件的基础设计，页面及模块数量等。</span><br><span class="line">[页面 1]: 页面的设计，上面有多少按钮，分别进入哪些子页面 / 进行哪些操作</span><br><span class="line">    [组件]:</span><br><span class="line">        [子组件 1]: 页面中按钮、输入框等组件的操作逻辑</span><br><span class="line">    [功能]:</span><br><span class="line">        [子功能 1]: 页面中的功能，包含其处理逻辑等。</span><br><span class="line">    [效果]:</span><br><span class="line">        [效果 1]: 页面中对应组件的一些视觉上的特效</span><br></pre></td></tr></table></figure><p>而以上“编程语言”都能让用户自由的使用人类自然语言进行描述。产品的质量取决于用户的描述详细程度。用户所描述的文件，将成为项目中的“源码”。</p><h2 id="与现阶段-AI-产品的不同之处"><a href="#与现阶段-AI-产品的不同之处" class="headerlink" title="与现阶段 AI 产品的不同之处"></a>与现阶段 AI 产品的不同之处</h2><p>现阶段 AI 产品还是在用户给出想法之后，使用某一编程语言将该算法写出来。而本项目直接将二进制文件进行输出。</p><h1 id="预计的技术屏障"><a href="#预计的技术屏障" class="headerlink" title="预计的技术屏障"></a>预计的技术屏障</h1><p>一款新的产品，以现在人类的技术未能将其实现，必然有它的道理，以下是我能想出的目前比较算得上是技术瓶颈的事项：</p><h2 id="生成的代码效率不高"><a href="#生成的代码效率不高" class="headerlink" title="生成的代码效率不高"></a>生成的代码效率不高</h2><p>由于是 AI 将自然语言进行摘要之后，直接生成二进制文件，而用户无法查看<strong>真正意义上的源码</strong>，所以可能会导致 AI 所生成出来的代码的执行效率低下。这点可能需要对模型进行训练才能得到更好的代码性能。</p><h2 id="无法符合用户预期"><a href="#无法符合用户预期" class="headerlink" title="无法符合用户预期"></a>无法符合用户预期</h2><p>这个问题在于现阶段中也经常出现甲方与开发商无法有效沟通，目前 ChatGPT 也会因为用户的表达不够精确，而给出完全不同领域但同样词汇的解释。所以如果是表达能力不是很优秀的用户可能会对此产品所构建出来的可执行文件不满意。当然一款以自然语言为编程语言的产品本身就会出现这种问题。真实的编程应该还是<strong>程序员通过自己的专业知识所构建出来的一个产品</strong>。</p><h2 id="自然语言处理的注意力与记忆不足"><a href="#自然语言处理的注意力与记忆不足" class="headerlink" title="自然语言处理的注意力与记忆不足"></a>自然语言处理的注意力与记忆不足</h2><p>一个完整的大型项目，其策划案以及设计图必然不是短短的几句话能够解决的。肯定是一个或多个文件所组成的大文件。而现阶段 AI 尚存在记忆力不足的现象，所能处理的用户 Token 有限，经常和 AI 聊着聊着就开始跑题。所以对于庞大的项目来说，以目前的技术还是需要去深入优化 AI 的算法以及开发更为先进的 AI 记忆模块。</p><h2 id="人工智能没有想象力"><a href="#人工智能没有想象力" class="headerlink" title="人工智能没有想象力"></a>人工智能没有想象力</h2><p>如果有了解 Stable Diffusion 等绘图 AI 的读者应该知道，人工智能是无法从 0 - 1 创造一个产品的。它需要用户不断地引导才能构建出一幅画。SD 所能绘图，得益于它的底层原理：<strong>扩散</strong>。所以是现有一幅画，对其进行降噪以及加噪过程后，得出最终结果。如果需要解决该问题，可能就需要用到量子计算机了。</p><h2 id="AI-需要的知识点更加庞大了，可能目前的大语言模型都无法满足"><a href="#AI-需要的知识点更加庞大了，可能目前的大语言模型都无法满足" class="headerlink" title="AI 需要的知识点更加庞大了，可能目前的大语言模型都无法满足"></a>AI 需要的知识点更加庞大了，可能目前的大语言模型都无法满足</h2><p>有自己手动进行编程的读者应该知道，编程其实只是一门技术。一个程序员应该需要去<strong>了解不同的 / 所从事领域的相关知识点</strong>，才能构建出符合实际情况的软件。而如果需要将 AI 变成一款编程语言，那么他除了要懂得“写代码（转换自然语言为机器语言）”之外，还需要了解各行各业中的核心知识点，而且有关知识点还会随着时间的推移不断地更新，模型需要不断地去更新自己，还需要去了解互联网中哪些文章是无用文章（水论文）<del>比如说这篇文章</del></p><h2 id="消费型计算机算力不高"><a href="#消费型计算机算力不高" class="headerlink" title="消费型计算机算力不高"></a>消费型计算机算力不高</h2><p>前面提到，人工智能没有想象力，需要解决这个问题可能需要用到量子计算机。显然量子计算机不属于消费计算机的一种。而这么庞大的模型，消费型计算机应该也无法满足其算力需求吧。</p><h2 id="多文件处理能力"><a href="#多文件处理能力" class="headerlink" title="多文件处理能力"></a>多文件处理能力</h2><p>前面提到，一个完整的大项目，其所包含的文件必然不止一个，这也需要这个模型需要在不同的文件中进行了解，且他也不像目前的编程语言拥有 Intellisense（人类自然语言千奇百怪，应该很难做 Intellisense 吧），所以这也是其中一个关键的技术瓶颈。</p><hr><p>以上就是一种未来的编程语言的构思。欢迎大家在评论区对此概念进行更深入的讨论！感谢您的阅读。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 话题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么二进制文件内容是乱码</title>
      <link href="/2024/9aed2ce9.html"/>
      <url>/2024/9aed2ce9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>不知道大家有没有一个经验，就是忍不住好奇想打开二进制文件（就是 .exe, .gif, .docx, .xlsb… 等一系列不是明文 plaintext 的文件）一探究竟。结果打开一看都是乱码。那么这篇文章将会满足你的好奇心，并附上正确开启方式哦！</p><p>本文参考资料来自 Stack Overflow 帖子 <a href="https://stackoverflow.com/questions/216066/what-exactly-causes-binary-file-gibberish">What exactly causes binary file “gibberish”?</a> 的高赞回答。如有错误，请发送您的观点到我的邮箱中，我会对文章进行更新。</p><p>当然，我还通过 ChatGPT 去了解相关资料，以下是对话内容（仅供参考）。</p><details class="toggle" ><summary class="toggle-button" style="">ChatGPT Conversation Record</summary><div class="toggle-content"><p><strong>Why the content of binary files look so gibberish while using text editor to open it?</strong></p><p>二进制文件中的内容在文本编辑器中看起来像乱码，是因为文本编辑器尝试解释二进制数据为文本，导致显示不可读的字符。二进制文件包含非文本的二进制数据，不应以文本方式打开。</p><p><strong>Can you explain what exactly the text editor done while opening the binary files?</strong></p><p>文本编辑器在打开二进制文件时会尝试将文件内容解释为文本字符集。它通常使用特定的字符编码（如ASCII或UTF-8）来解释字节并显示对应的字符。由于二进制文件包含各种非文本数据，这样的解释会导致不可读的字符显示，因此内容看起来像乱码。实际上，二进制文件可能包含字节序列，代表图像、音频、程序代码等，而这些内容在文本编辑器中以文本形式展示并不合适。</p><p><strong>Can you show me the original content of a binary file?</strong></p><p>抱歉，由于文本界面的限制，我无法直接显示二进制文件的原始内容。二进制文件通常包含不可打印的字符和二进制数据，无法在文本格式中直接呈现。如果您需要查看二进制文件的内容，您可能需要使用专门的二进制文件查看器或编辑器。</p><p><strong>just show the code in binary format?</strong></p><p>Certainly, here’s an example of binary code:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001</span><br></pre></td></tr></table></figure><p>This is a simple greeting, “Hello, world!” represented in binary. Each group of 8 bits corresponds to a character based on ASCII encoding.</p><p><strong>So why these code become unreadable code when it is open by text editor? Can you show it step by step?</strong></p><p>Certainly, let’s break down the binary code “01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001” step by step:</p><ol><li><p><strong>Original Binary Code:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01001000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00100001</span><br></pre></td></tr></table></figure></li><li><p><strong>ASCII Conversion:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H   e   l   l   o   ,       w   o   r   l   d   !</span><br></pre></td></tr></table></figure></li></ol><p>When you open a binary file in a text editor, it attempts to interpret these binary sequences as character encodings like ASCII. In this case, the binary code represents ASCII characters, and the text editor displays the corresponding characters (“Hello, world!”). However, not all binary files follow character encodings, leading to unreadable characters or gibberish when opened in a text editor.</p><p><strong>Is it possible to convert the view to display raw binary values?</strong></p><p>在大多数文本编辑器中，你通常无法直接以原始二进制值的形式查看文件内容。文本编辑器主要设计用于显示和编辑文本数据，而不是二进制数据。</p><p>要以原始二进制形式查看文件内容，你可能需要使用专门的二进制文件查看器或编辑器。这些工具允许你以字节或位为单位查看文件，而不会将其解释为字符。你可以尝试使用诸如Hex编辑器之类的工具，这样你就能够以更底层的方式查看文件的二进制表示。</p></div></details><p>我们将对这个话题进行以下探究：</p><ul><li><a href="#为什么使用文本编辑器打开二进制文件的内容是乱码">为什么使用文本编辑器打开二进制文件的内容是乱码</a></li><li><a href="#有没有办法以可读的方式打开二进制文件">有没有办法以可读的方式打开二进制文件</a></li><li><a href="#有没有办法通过二进制文件确定该文件属于什么类型">有没有办法通过二进制文件确定该文件属于什么类型</a></li><li><a href="#其他回答">其他回答</a></li><li><a href="#参考资料">参考资料</a></li></ul><h1 id="为什么使用文本编辑器打开二进制文件的内容是乱码"><a href="#为什么使用文本编辑器打开二进制文件的内容是乱码" class="headerlink" title="为什么使用文本编辑器打开二进制文件的内容是乱码"></a>为什么使用文本编辑器打开二进制文件的内容是乱码</h1><p>要解释这个问题，首先得了解一个概念 <strong>文本编辑器是为了显示文本</strong>。所以文本编辑器将二进制文件的内容解释为文本格式，而不是二进制格式。二进制文件包含的数据是为计算机而非人类设计的，因此不适合用文本编辑器打开<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is the difference between binary and text files?](https://fileinfo.com/help/binary_vs_text_files)">[1]</span></a></sup>。</p><p>通常使用特定的字符编码（如 ASCII 或 UTF-8）来解释字节并显示对应的字符。由于二进制文件包含各种非文本数据，这样的解释会导致不可读的字符显示，因此内容看起来像乱码。实际上，二进制文件可能包含字节序列，代表图像、音频、程序代码等，而这些内容在文本编辑器中以文本形式展示并不合适。</p><h1 id="有没有办法以可读的方式打开二进制文件"><a href="#有没有办法以可读的方式打开二进制文件" class="headerlink" title="有没有办法以可读的方式打开二进制文件"></a>有没有办法以可读的方式打开二进制文件</h1><p>想要直接打开二进制文件（以显示其中的 0 和 1）是不可取的，因为这样会显示整个代码难以阅读，毫无意义。所以要想打开二进制文件，可以使用十六进制编辑器 Hex Editor。它可以显示二进制文件的原始内容，而不是将其解释为文本格式。</p><p>十六进制编辑器是一种特殊的编辑器，它可以将二进制文件的内容以十六进制格式显示出来。十六进制是一种数字表示法，它使用16个数字（0-9和A-F）来表示数据。每个数字对应于二进制数据的4个位。因此，十六进制编辑器可以将二进制数据转换为易于阅读的格式，以便您可以更轻松地查看和编辑数据<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[What is a Hex Editor and How to Use It?](https://blog.ultraedit.com/hex-editor/)">[2]</span></a></sup>。</p><h1 id="有没有办法通过二进制文件确定该文件属于什么类型"><a href="#有没有办法通过二进制文件确定该文件属于什么类型" class="headerlink" title="有没有办法通过二进制文件确定该文件属于什么类型"></a>有没有办法通过二进制文件确定该文件属于什么类型</h1><p>在确定数据文件类型的过程中，可以使用类似于 Linux 中的命令行程序 <code>file</code> 的工具。该程序尝试分析文件（通常查找常见的文件头模式），并告诉你文件的类型（如文本、音频、视频、XML等）。虽然这个程序的输出只是一个猜测，但在不了解文件格式的情况下，它可以非常有用。在 Windows 平台是否有类似的程序尚不确定。</p><p>Windows 种已经将 <code>file</code> 指令进行移植，我们可以在 Cygwin 中找到其实例。其中一个很好的 <code>file</code> 移植功能可以在 sourceforge 中找到<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="The \(well, one\) Windows port of `file` is [here](http://gnuwin32.sourceforge.net/packages/file.htm)">[3]</span></a></sup></p><h1 id="其他回答"><a href="#其他回答" class="headerlink" title="其他回答"></a>其他回答</h1><p>A binary file appears as gibberish because the data in it is designed for the machine to read and not for humans. Sadly, some of us get used to interpreting gibberish - albeit with somewhat specialized tools to help see the data better - but most people should not need to know.</p><p>Each byte in the file is treated as a character in the current code set (probably CP1252 on Windows). Byte value 65 is ‘A’, for example; you can find illustrative examples easily on the web. So, the bytes that make up the binary data are displayed according to the code set - as best as the text editor can. It doesn’t try to convert the binary - it doesn’t know how (only the original program does).</p><p>As to how to detect what program created the file - you may be able to do that sometimes, but not easily and reliably. On Unix (or with Cygwin on Windows) the ‘file’ program may be able to help. This program looks at the first few bytes to try and guess the program.</p><p>Encrypted data is supposed to look like gibberish. If it doesn’t look like gibberish, then it probably isn’t very well encrypted<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="What exactly causes binary file "gibberish"? [Answered by Jonathan Leffler](https://stackoverflow.com/a/216085/19872253)">[4]</span></a></sup>.</p><blockquote><p>以上回答版权信息为 CC BY-SA 2.5，原文已标注在 参考资料中。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://fileinfo.com/help/binary_vs_text_files">What is the difference between binary and text files?</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://blog.ultraedit.com/hex-editor/">What is a Hex Editor and How to Use It?</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">The (well, one) Windows port of <code>file</code> is <a href="http://gnuwin32.sourceforge.net/packages/file.htm">here</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">What exactly causes binary file &quot;gibberish&quot;? <a href="https://stackoverflow.com/a/216085/19872253">Answered by Jonathan Leffler</a><a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 16 K-Fold 交叉验证</title>
      <link href="/2024/4137e8ad.html"/>
      <url>/2024/4137e8ad.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>k-fold 交叉验证是一种评估机器学习模型性能的方法。在训练和验证过程中，数据集被分成 k 个折叠，模型 k 次训练和验证，每次使用不同的折叠作为验证集，其余作为训练集。这有助于更准确地评估模型的性能。</p><h1 id="关于训练集和测试集的担忧"><a href="#关于训练集和测试集的担忧" class="headerlink" title="关于训练集和测试集的担忧"></a>关于训练集和测试集的担忧</h1><p>我们进行评估是因为我们想要准确地衡量模型的性能。如果我们的数据集很小，那么我们的测试集就会很小。因此，它可能不是数据点的良好随机分配，并且由于随机原因最终在我们的评估集中得到易于或难以处理的数据点。</p><p>由于我们的目标是获得我们度量指标（准确度 Accuracy、精确度 Precision、召回率 Recall 和 F1 分数）的最佳度量，我们可以比单一训练和测试集做得更好一些。</p><p>回顾一下我们的训练和测试集拆分如下。</p><p><img src="/uploads/sololearn/machine-learning/training%20and%20testing%20split%20datasets.png" alt="Train Test Split"></p><p>正如我们所见，训练集中的所有值都没有用于评估。使用训练集构建模型然后用训练集进行评估是不公平的，因为这样我们无法得到模型性能的完整图片。</p><p>为了从经验上看到这一点，让我们尝试运行 <a href="/2023/d24f091e.html" title="Sololearn 自学机器学习 13 训练与测试">13 训练与测试</a> 中执行训练/测试拆分的代码。我们将重新运行它几次并查看结果。每一行都是不同的随机训练/测试拆分的结果。</p><div class="table-container"><table><thead><tr><th>Rum times</th><th>Accuracy</th><th>Precision</th><th>Recall</th><th>F1 Score</th></tr></thead><tbody><tr><td>1</td><td>0.83</td><td>0.79</td><td>0.75</td><td>0.77</td></tr><tr><td>2</td><td>0.79</td><td>0.80</td><td>0.63</td><td>0.71</td></tr><tr><td>3</td><td>0.79</td><td>0.79</td><td>0.68</td><td>0.73</td></tr><tr><td>4</td><td>0.84</td><td>0.75</td><td>0.73</td><td>0.74</td></tr><tr><td>5</td><td>0.80</td><td>0.81</td><td>0.60</td><td>0.69</td></tr></tbody></table></div><p>您可以看到每次运行时，我们得到的度量值都不同。准确度从 0.79 到 0.84，精确度从 0.75 到 0.81，召回率从 0.63 到 0.75。这些是广泛范围的值，仅取决于测试集中最终包含哪些数据点是幸运还是不幸运。</p><p>如果您想自己运行并查看指标的变化值，以下是代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://sololearn.com/uploads/files/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行多次训练/测试拆分</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建模型</span></span><br><span class="line">    model = LogisticRegression()</span><br><span class="line">    model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 评估模型</span></span><br><span class="line">    y_pred = model.predict(X_test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; accuracy: &#123;0:.5f&#125;&quot;</span>.<span class="built_in">format</span>(accuracy_score(y_test, y_pred)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;precision: &#123;0:.5f&#125;&quot;</span>.<span class="built_in">format</span>(precision_score(y_test, y_pred)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;   recall: &#123;0:.5f&#125;&quot;</span>.<span class="built_in">format</span>(recall_score(y_test, y_pred)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; f1 score: &#123;0:.5f&#125;&quot;</span>.<span class="built_in">format</span>(f1_score(y_test, y_pred)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;------------&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>&#123;0: .5f&#125;</code> 是使用 Python 的字符串格式的占位符。Python将使用 <code>.format(*args)</code> 的参数从提交的值替换这些占位符，其中：</p><ul><li><code>0</code> 表示将此占位符替换为第一个参数。从 Python 3.1 开始，您无需包括此 0，但如果要在字符串中多次使用相同的参数，则这些是必需的。</li><li><code>:</code> 将替换字段名称与格式规范分隔开。</li><li><code>.5</code> 表示将小数部分四舍五入到5位数字，</li><li><code>f</code> 表示我们正在处理浮点数。</li></ul><p>在大多数情况下，Python 最新的 f-strings 是更好的字符串格式选择。以下是相同行的 f-string 格式：<code>print(f&quot;precision: &#123;precision_score(y_test, y_pred):.5f&#125;&quot;)</code></p><p>有关字符串格式的更多信息：<a href="https://realpython.com/python-formatted-output/">https://realpython.com/python-formatted-output/</a></p></blockquote><div class="note info flat"><p>与单一训练 / 测试拆分不同，我们将数据多次拆分为训练集和测试集。</p></div><h1 id="多个训练和测试集"><a href="#多个训练和测试集" class="headerlink" title="多个训练和测试集"></a>多个训练和测试集</h1><p>我们在前面的部分学到，根据我们的测试集，我们可以得到评估指标的不同值。我们希望获得对我们的模型整体表现的度量，而不仅仅是在一个特定的测试集上表现如何的度量。</p><p>与其只将数据的一部分作为测试集，不如将我们的数据集分成5个部分。假设我们的数据集中有200个数据点。</p><p><img src="/uploads/sololearn/machine-learning/dataset-split-into-5-parts.png" alt="Dataset split into 5 parts"></p><p>这5个部分中的每一个都将作为一个测试集。当第1个部分是测试集时，我们将剩下的4个部分作为训练集。因此，我们有5个训练和测试集，如下所示。</p><p><img src="/uploads/sololearn/machine-learning/test-set-in-5-datasets.png" alt="Test Set in 5 datasets"></p><p>每一次我们都有一个20%的测试集（40个数据点）和一个80%的训练集（160个数据点）。</p><div class="note info flat"><p>每个数据点都恰好在一个测试集中。</p></div><h1 id="建立和评估多个训练和测试集"><a href="#建立和评估多个训练和测试集" class="headerlink" title="建立和评估多个训练和测试集"></a>建立和评估多个训练和测试集</h1><p>在前一部分，我们看到如何创建5个不同训练集的测试集。</p><p>现在，对于每个训练集，我们构建一个模型并使用相关的测试集进行评估。因此，我们构建5个模型并计算5个分数。</p><p>假设我们正在尝试计算模型的准确度分数。</p><p><img src="/uploads/sololearn/machine-learning/accuracy-of-5-datasets.png" alt="Accuracy of 5 datasets"></p><p>我们将准确度报告为这5个值的平均值：</p><script type="math/tex; mode=display">(0.83 + 0.79 + 0.78 + 0.80 + 0.75) / 5 = 0.79</script><p>如果我们只进行了单一的训练和测试集，并且随机选择了第一个，我们将报告准确度为0.83。如果我们随机选择了最后一个，我们将报告准确度为0.75。对所有这些可能的值取平均有助于消除数据点落入哪个测试集的影响。</p><blockquote><p>只有在数据集较小的情况下，您才会看到这么大的差异。对于较大的数据集，我们通常只是简单地进行训练和测试集的划分。</p></blockquote><p>创建多个训练和测试集的这个过程称为 k 折交叉验证 (k-fold cross validation) 。k 是我们将数据集分成的块数。标准数是 5，就像我们在上面的示例中所做的那样。</p><div class="note info flat"><p>我们在交叉验证中的目标是获得我们度量指标（准确度、精确度、召回率）的准确度量。我们构建额外的模型，以便对我们计算和报告的数字感到有信心。</p></div><h1 id="在k折交叉验证中的最终模型选择"><a href="#在k折交叉验证中的最终模型选择" class="headerlink" title="在k折交叉验证中的最终模型选择"></a>在k折交叉验证中的最终模型选择</h1><p>现在我们建立了 5 个模型而不只是一个。我们如何决定使用哪个单一模型？</p><p>这 5 个模型仅用于评估目的，以便我们可以报告度量值。实际上，我们并不需要这些模型，而是想要构建可能的最佳模型。可能的最佳模型将是一个<strong>使用所有数据的模型</strong>。因此，我们跟踪我们计算的评估指标的值，然后使用所有数据构建一个模型。</p><p>这可能看起来非常浪费，但计算机有大量的计算能力，因此值得多使用一些来确保我们报告了正确的评估指标值。我们将使用这些值来做出决策，因此正确计算它们非常重要。</p><div class="note info flat"><p>在构建模型时，计算能力 (computing power) 对于大型数据集可能是一个问题。在这些情况下，我们只是进行训练测试拆分。</p></div><h1 id="在-SkLearn-中的-KFold-类"><a href="#在-SkLearn-中的-KFold-类" class="headerlink" title="在 SkLearn 中的 KFold 类"></a>在 SkLearn 中的 <code>KFold</code> 类</h1><p>Scikit-learn 已经实现了将数据集分成k个块并创建k个训练和测试集的代码。</p><p>为简单起见，让我们以一个只有 6 个数据点和2个特征的数据集为例，并在该数据集上进行 3 折交叉验证。我们将从 Titanic 数据集中取前 6 行，只使用 Age 和 Fare 列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = df[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values[:<span class="number">6</span>]</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values[:<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>我们首先实例化一个 KFold 类对象。它接受两个参数：<code>n_splits</code>（这是 k，要创建的块数）和 <code>shuffle</code> （是否对数据的顺序进行随机化）。通常最好对数据进行洗牌，因为数据集经常处于排序的状态。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kf = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><blockquote><p>为了实现相同的随机状态，您可以将<code>random_state=value</code>作为参数传递给KFold，其中<code>value</code>是用于确定k-fold拆分的随机状态的固定数字。</p></blockquote><p>KFold类有一个 <code>split</code> 方法，用于为我们的数据创建 3 个拆分。</p><p>让我们看一下 <code>split</code> 方法的输出。 <code>split</code> 方法返回一个生成器，因此我们使用 <code>list</code> 函数将其转换为列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(kf.split(X))</span><br></pre></td></tr></table></figure><blockquote><p><code>kf.split(X)</code> 返回的是索引，而不是数据点。</p></blockquote><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">X = df[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values[:<span class="number">6</span>]</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values[:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">kf = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> train, test <span class="keyword">in</span> kf.split(X):</span><br><span class="line">    <span class="built_in">print</span>(train, test)</span><br></pre></td></tr></table></figure><p>正如我们所看到的，我们有 3 个训练和测试集，符合预期。第一个训练集由数据点 0、2、3、5 组成，测试集由数据点 1、4 组成。</p><div class="note info flat"><p>拆分是随机进行的，因此每次运行代码时都可以看到不同的数据点集。</p></div><h1 id="使用-Folds-创建训练和测试集"><a href="#使用-Folds-创建训练和测试集" class="headerlink" title="使用 Folds 创建训练和测试集"></a>使用 Folds 创建训练和测试集</h1><p>我们使用 KFold 类和 split 方法获取了每个拆分中的索引。现在让我们使用该结果来获得我们的第一个（共3个）训练 / 测试拆分。</p><p>首先，让我们取出第一个拆分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">splits = <span class="built_in">list</span>(kf.split(X))</span><br><span class="line">first_split = splits[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(first_split)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># (array([0, 2, 3, 5]), array([1, 4]))</span><br></pre></td></tr></table></figure><p>第一个数组是训练集的索引，第二个是测试集的索引。让我们创建这些变量。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_indices, test_indices = first_split</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;training set indices:&quot;</span>, train_indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test set indices:&quot;</span>, test_indices)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># training set indices: [0, 2, 3, 5]</span><br><span class="line"># test set indices: [1, 4]</span><br></pre></td></tr></table></figure><p>现在我们可以根据这些索引创建 X_train、y_train、X_test 和 y_test。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = X[train_indices]</span><br><span class="line">X_test = X[test_indices]</span><br><span class="line">y_train = y[train_indices]</span><br><span class="line">y_test = y[test_indices]</span><br></pre></td></tr></table></figure><p>如果我们打印出每个变量，我们将看到 X_train 中有四个数据点及其目标值，而剩下的两个数据点在 X_test 中，它们的目标值在 y_test 中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X_train&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_train&quot;</span>, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X_test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_test&quot;</span>, y_test)</span><br></pre></td></tr></table></figure><div class="note info flat"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">X = df[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values[:<span class="number">6</span>]</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values[:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">kf = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">splits = <span class="built_in">list</span>(kf.split(X))</span><br><span class="line">first_split = splits[<span class="number">0</span>]</span><br><span class="line">train_indices, test_indices = first_split</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;training set indices:&quot;</span>, train_indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test set indices:&quot;</span>, test_indices)</span><br><span class="line"></span><br><span class="line">X_train = X[train_indices]</span><br><span class="line">X_test = X[test_indices]</span><br><span class="line">y_train = y[train_indices]</span><br><span class="line">y_test = y[test_indices]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X_train&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_train&quot;</span>, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;X_test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y_test&quot;</span>, y_test)</span><br></pre></td></tr></table></figure><p>运行此代码以查看结果。在这一点上，我们有与使用 train_test_split 函数相同格式的训练和测试集。</p><div class="note warning flat"><p>这可能会让人感到困惑。个人而言，我在提供的代码中添加了一些打印语句，以便更容易看到每个步骤的发生情况：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这提供了索引，而不是实际值。</span></span><br><span class="line">kf = KFold(n_splits=<span class="number">3</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">splits = <span class="built_in">list</span>(kf.split(X))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;splits:&quot;</span>, splits)</span><br><span class="line"></span><br><span class="line">first_split = splits[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first split:&quot;</span>, first_split)</span><br><span class="line"></span><br><span class="line">train_indices, test_indices = first_split</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;training set indices:&quot;</span>, train_indices)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test set indices:&quot;</span>, test_indices)</span><br></pre></td></tr></table></figure><p>这段代码将打印出每个步骤中发生的情况，包括拆分的索引和训练/测试集的索引。</p></div></div><h1 id="构建模型"><a href="#构建模型" class="headerlink" title="构建模型"></a>构建模型</h1><p>现在我们可以使用训练和测试集构建模型并进行预测，就像之前一样。让我们回到使用整个数据集（因为4个数据点不足以构建一个像样的模型）。</p><p>以下是构建并在5折交叉验证的第一个折叠上评分模型的完整代码。请注意，拟合和评分模型的代码与使用train_test_split函数时完全相同。</p><p>请尝试运行它：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">kf = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">splits = <span class="built_in">list</span>(kf.split(X))</span><br><span class="line">train_indices, test_indices = splits[<span class="number">0</span>]</span><br><span class="line">X_train = X[train_indices]</span><br><span class="line">X_test = X[test_indices]</span><br><span class="line">y_train = y[train_indices]</span><br><span class="line">y_test = y[test_indices]</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(model.score(X_test, y_test))</span><br></pre></td></tr></table></figure><div class="note info flat"><p>到目前为止，我们基本上只是进行了一次训练 / 测试拆分。为了进行 k 折交叉验证，我们需要使用其他 4 个拆分中的每一个来构建模型并评分模型。</p></div><h1 id="循环遍历所有的折叠"><a href="#循环遍历所有的折叠" class="headerlink" title="循环遍历所有的折叠"></a>循环遍历所有的折叠</h1><p>我们之前是一次处理一个折叠，但实际上我们希望循环遍历所有的折叠以获取所有的值。我们将前面部分的代码放在for循环中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = []</span><br><span class="line">kf = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(X):</span><br><span class="line">    X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">    y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">    model = LogisticRegression()</span><br><span class="line">    model.fit(X_train, y_train)</span><br><span class="line">    scores.append(model.score(X_test, y_test))</span><br><span class="line"><span class="built_in">print</span>(scores)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [0.75847, 0.83146, 0.85876, 0.76271, 0.74011]</span><br></pre></td></tr></table></figure><p>由于我们有 5 个折叠，我们得到 5 个准确度值。回想一下，为了得到一个单一的最终值，我们需要取这些值的平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.mean(scores))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 0.79029</span><br></pre></td></tr></table></figure><p>现在我们已经计算了准确度，我们不再需要我们构建的 5 个不同模型。对于将来的使用，我们只想要一个单一的模型。为了获得可能的最佳单一模型，我们在整个数据集上构建一个模型。如果有人问起这个模型的准确度，我们使用通过交叉验证计算的准确度（0.79029），即使我们实际上还没有使用测试集测试过这个特定模型（Model built with whole dataset）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">final_model = LogisticRegression()</span><br><span class="line">final_model.fit(X, y)</span><br></pre></td></tr></table></figure><blockquote><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">scores = []</span><br><span class="line">kf = KFold(n_splits=<span class="number">5</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> kf.split(X):</span><br><span class="line">   X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">   y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">   model = LogisticRegression()</span><br><span class="line">   model.fit(X_train, y_train)</span><br><span class="line">   scores.append(model.score(X_test, y_test))</span><br><span class="line"><span class="built_in">print</span>(scores)</span><br><span class="line"><span class="built_in">print</span>(np.mean(scores))</span><br><span class="line">final_model = LogisticRegression()</span><br><span class="line">final_model.fit(X, y)</span><br></pre></td></tr></table></figure></blockquote><div class="note info flat"><p>每次运行代码都可以期望得到稍微不同的值。KFold 类每次都会随机拆分数据，因此不同的拆分将导致不同的分数，尽管你应该期望这 5 个分数的平均值通常大致相同。</p></div><h1 id="cross-val-score"><a href="#cross-val-score" class="headerlink" title="cross_val_score"></a>cross_val_score</h1><p>sklearn 中的 <code>cross_val_score</code> 函数是一种方便的方法，可以在不必手动迭代折叠的情况下进行交叉验证。以下是使用 <code>cross_val_score</code> 的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cross_val_score进行5折交叉验证并获取准确度分数</span></span><br><span class="line">scores = cross_val_score(model, X, y, cv=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印每个折叠的准确度分数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;每个折叠的准确度分数:&quot;</span>, scores)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有折叠的平均准确度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均准确度:&quot;</span>, np.mean(scores))</span><br></pre></td></tr></table></figure><p>这种方法简化了代码，并提供了一种简洁的方式来执行交叉验证。<code>cv</code>参数指定了折叠的数量，<code>cross_val_score</code>负责拆分数据，训练模型并计算每个折叠的准确度。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言笔记复盘 2 C 语言的特点</title>
      <link href="/2024/c895ec1a.html"/>
      <url>/2024/c895ec1a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇文章呢，我们介绍了 C 语言的由来。是怎么从机器语言一直转变到 C 语言的。那么这一篇文章我们将会开始的去学习 C 语言的特点。</p><h1 id="C-语言的特点"><a href="#C-语言的特点" class="headerlink" title="C 语言的特点"></a>C 语言的特点</h1><p>下面呢，我将用一张表来说明 C 语言的优点和缺点。</p><div class="table-container"><table><thead><tr><th>优点 Pros</th><th>缺点 Cons</th></tr></thead><tbody><tr><td>C 语言语句简洁紧凑使用方便灵活</td><td>对语法检查不严格</td></tr><tr><td>运算符丰富，表达能力强</td><td>运算符较多，初学者很难掌握</td></tr><tr><td>C 语言程序可移植性好</td></tr><tr><td>生成的目标代码质量高，运行效率高</td></tr><tr><td>语言处理能力强</td></tr><tr><td>C 语言是一种结构化语言</td></tr></tbody></table></div><h1 id="C-语言的约定"><a href="#C-语言的约定" class="headerlink" title="C 语言的约定"></a>C 语言的约定</h1><p>上一篇提到 C 语言是一个结构化编程语言，而且它 “类似” 人类的自然语言，但对语法的检查不严格。所以需要程序员之间达成一些约定，好让彼此之间的代码互相看得懂，接下来我们聊聊 C 语言的约定。</p><h2 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符 Identifier"></a>标识符 Identifier</h2><p>标识符是指一个自定义的标识，用于标识数据类型，包括：变量、函数等。在 C 语言中（或者对于之后面对的每一门语言），对一个数据定义标识符时，应该做到<strong>见字知意</strong>，一个标识符应该是使用英语写出其所对应的现实世界的名词。并且使用<strong>小驼峰命名</strong>。比如：对一条公路上汽车的计数器的变量标识符命名为 <code>carsCounter</code>。</p><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>C 语言中有 32 个关键字是我们在定义标识符时不能使用的。这些关键字是保留给 C 语言做某些操作所需要用到的，他们的分类如下表所示：</p><div class="table-container"><table><thead><tr><th>分类（Categories）</th><th>关键字（Keywords）</th></tr></thead><tbody><tr><td>数据类型</td><td>char, double, enum, float, int, long, short, signed, unsigned, struct, union, void</td></tr><tr><td>控制语句</td><td>break, continue, case, do, default, else, for, goto, if, return, switch, while</td></tr><tr><td>存储类型</td><td>auto, extern, register, static</td></tr><tr><td>其他</td><td>const, sizeof, typedef, violate</td></tr></tbody></table></div><h2 id="用户自定义标识符"><a href="#用户自定义标识符" class="headerlink" title="用户自定义标识符"></a>用户自定义标识符</h2><p>包括程序中定义的变量名、数据类型名（使用 typedef 语法）、函数名和符号常量名。一般来说，通常使用有意义的英文单词作为用户自定义标识符。</p><h2 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h2><p>通常我们可以使用 C 语言自带的运算符完成基本操作，但是我们还是需要进行某些特定的操作，如获取用户输入及输出。这时候我们就要用到预定义标识符。C 语言提供的大量的<strong>头文件和库函数</strong>，如我们常用的 <code>printf</code>, <code>scanf</code> 等，都是引用了 <code>stdio.h</code> 这个头文件中的函数。</p><p>C 语言中允许用户自定义标识符与预定义标识符同名，但是这会使原有标识符失去作用，不推荐这样做。</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>在 C 语言中，我们需要使用分隔符，如：<code>` 空格和</code>,` 来构成完整的一个语句。比如说</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;</span><br></pre></td></tr></table></figure><p>以上语句的完整结构是：关键字 <code>int</code> + 标识符 <code>a, b, c</code> + 分隔符 <code>,</code> + 语句结束 <code>;</code></p><h1 id="C-语言的语法成分"><a href="#C-语言的语法成分" class="headerlink" title="C 语言的语法成分"></a>C 语言的语法成分</h1><p>C 语言的语法成分包含了常量、变量、运算符、表达式、语句、函数定义与调用、输入与输出。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>整形常量如 <code>2</code>；实型常量如 <code>2.0</code>；字符型常量如 <code>&#39;2&#39;</code>；字符串常量如 <code>&quot;C Programming&quot;</code>。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的定义形式为：<code>类型名 变量名;</code> 如：<code>int a, b, c;</code>。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>C 语言有多达 34 种运算符。其中操作 1 个数据对象的称为<strong>单目运算符</strong>；操作 2 个数据对象的称为<strong>双目运算符</strong>，如 <code>2 + 2</code>、<code>a = 10</code>，操作三个数据对象的称为<strong>三目运算符</strong>，如 <code>a &gt; b ? a : b</code></p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>由运算符、变量、常量、函数组合而成的有意义的使之成为表达式。表达式中可以包含多种数据类型的运算符，运算符有优先级。例如，表达式 <code>b * b - 4 * a * c &gt; 0</code> 种，由于算术运算符优先于关系运算，所以先计算 <code>b * b - 4 * a * c</code>，再做关系比较运算 <code>&gt;</code></p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>C 语言中，语句是最基本的执行单位，以分号 <code>;</code> 结尾。</p><h2 id="函数的定义与调用"><a href="#函数的定义与调用" class="headerlink" title="函数的定义与调用"></a>函数的定义与调用</h2><p>对于一些代码，我们可能会重复的去写，我们可以将这些重复的功能提取成函数。函数就是完成特定功能的小模块。一般情况下，C 语言程序包含多个函数。对于初学者，最常见的函数应该是：<code>printf</code>、<code>scanf</code>、<code>puts</code>、<code>gets</code> 等。</p><p>一般情况下，函数拥有零个或多个参数，并拥有零个或一个返回值。我们可以用 <code>return</code> 语句来讲函数中处理好的值进行返回。</p><p>C 语言的入口函数 <code>int main()</code> 就是一个函数，在执行完 main 函数后，程序会返回 0 (<code>return 0;</code>)，说明程序顺利执行。非 0 值代表程序执行过程中出现问题。</p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>C 语言是没有提供用于数据输入与输出的语句，所有的输入与输出都是通过系统提供的有关函数（如 <code>scanf()</code> 和 <code>printf()</code>）函数来实现的</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C 语言笔记复盘 </category>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C 语言笔记复盘 1 初识 C 语言</title>
      <link href="/2023/9e7729ba.html"/>
      <url>/2023/9e7729ba.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这几天在学机器学习，可能太浮躁了，学到 k-fold 交叉验证有点学不下去了。正好看到大一自己写的 C 语言笔记，大概有 $2^6$ 这么多页。从 C 语言的由来一直讲到函数（似乎是老师也就说了这么多，后面的指针全是带过的），内容蛮全的。试试看自己能不能将他完全写进我的博客里吧~</p><blockquote><p>机器学习和 C 语言笔记将会同步更新。理论上不会弃坑</p></blockquote><p>因为笔记上面好多地方都是用符号标记的，有些忘记了的地方，还请各位多多指教~</p><h1 id="C-语言的由来"><a href="#C-语言的由来" class="headerlink" title="C 语言的由来"></a>C 语言的由来</h1><p>在计算机诞生以来，是不像现在一样拥有各式各样的编程语言供大家根据不同的场景选择最合适的语言。当时候的计算机只认得 0 和 1 两种变量的输入，计算结果也是 0 和 1 组成的一串数据。这时候我们管这个编程语言叫 <strong>机器语言 Machine Language</strong>。</p><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p>他是由一组二进制 (<code>0</code>, <code>1</code>) 组成的，它的优点有：计算机能直接识别、编写的程序直接就是 <strong>目标程序</strong> 可以被直接执行，所以它的运行效率也是最高的。但是缺点也非常显而易见的：难学、难记、难写、难改。而且呀，当时不同计算机的指令系统 command system 有差别，这也导致了不同机器之间代码移植性低。</p><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p>后来，出现了一种语言那就是 <strong>汇编语言 Assembly Language</strong>。他是属于低级语言的一种，也是编程语言中的第二代语言。当时的程序员 / 工程师们将二进制串转换成助记符，这两者之间可以相互转换，即：程序员在编写程序时使用的是助记符（也就是汇编语言），而计算机则将助记符翻译成二进制串（binary）再进行执行。而他的原理是将计算机的各种指令（二进制串，后续我会抽空说明 CPU 的原理）烧录到 CPU 中，以让 CPU 去识别这些助记符。</p><div class="note info flat"><p>挖个坑，后续如果我们需要讲解 Turing Complete 游戏的时候会讲到这个。</p></div><p>如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD # 加法</span><br><span class="line">SUB # 减法</span><br><span class="line">MOV # 在内存之间传送数据</span><br></pre></td></tr></table></figure><p>汇编语言的好处就是：易懂、方便修改和维护、有效发挥硬件的功能和特长、程序精炼、质量高。但是上面提到，工程师得先将指令烧录进 CPU 才能让计算机取识别这类型代码，所以汇编语言也 <strong>依赖机器硬件</strong>，同样的，移植性也不好。</p><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><p>这时候，人类就在想，能不能有一门计算机语言，能够接近于数学语言或者人类的自然语言（当然，也就是英语），而且不再依赖于计算机硬件，同时解决这两个缺点的编程语言。这时候，就出现了最早的高级语言：</p><h3 id="FORTRAN"><a href="#FORTRAN" class="headerlink" title="FORTRAN"></a>FORTRAN</h3><p>FORTRAN 的全称是 Formula Translator，公式翻译器。它的优点就是：功能强大、易学、易懂、易维护，这简直解决了当时程序员狂掉头发的问题，让更多的程序员拥有一头还算乌黑的头发。但是这种语言，由于他已经经过了多层包裹，导致她不能直接被计算机运行，需要经过翻译，也就是我们熟悉的 Compile 编译。</p><p>这时候，我们对高级语言编写出来的代码称之为源程序（Source Program）而源程序就需要翻译成目标程序，这个过程我们就叫他编译程序（compiling program）。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>当 FORTRAN 问世的时候，他还是属于 <strong>非结构化的语言</strong>。</p><h3 id="非结构化语言"><a href="#非结构化语言" class="headerlink" title="非结构化语言"></a>非结构化语言</h3><p>非结构化语言是什么呢？也就是说这类型的语言风格随意、他没有编程规范可以遵循流程、可以随意的跳转、难阅读以及维护。这就好比你拿到一本故事书然后你看着看着，作者让你跳到第 100 页去看，然后再从一百页翻回来 60 页去看接下来的故事。显而易见的，这类型的语言非常的难以被人理解，尤其是如果没有良好的编程习惯的话，那情况会更加糟糕。这类型的语言以 FORTRAN、ALGOL 以及 BASIC 等为代表。</p><h3 id="结构化语言"><a href="#结构化语言" class="headerlink" title="结构化语言"></a>结构化语言</h3><p>到了大约 1969 ~ 1970 年代，人们创造出了结构化语言。那么这类型的语言的特点，就是它规定程序必须要有良好的基本结构，比如说顺序、分支、循环结构等。他不允许程序随意的跳转。程序是由上而下，一行一行顺序的执行的。这类型的语言有 QBasic，Pascal 和 C 语言为代表。其中 Pascal 是这类型语言的第一个，也就是鼻祖。</p><h3 id="面向对象语言"><a href="#面向对象语言" class="headerlink" title="面向对象语言"></a>面向对象语言</h3><p>而后来大约在二十世纪八十年代开始出现了面向对象语言，这类型语言呢有 C++、C#、Visual Basic、Java 等。这些类型的语言让我们能够将现实世界的实体抽象成代码中的一个个<strong>类</strong>和<strong>对象</strong>。使代码更加容易地被阅读以及操作。</p><h2 id="程序设计语言的功能"><a href="#程序设计语言的功能" class="headerlink" title="程序设计语言的功能"></a>程序设计语言的功能</h2><p>程序设计语言是人类与计算机之间进行交流的桥梁。我们需要让计算机按照自己的意愿处理数据，就必须用程序设计语言表达所要处理的数据与即控制数据处理的流程。因此，程序设计语言必须要具有数据表达。（就是变量定义）与数据处理（就是流程控制）的能力。</p><p>除了要有数据表达的能力之外，程序设计语言还需要具备流程控制的能力。其中包括了<strong>顺序控制</strong>、<strong>分支控制</strong>，也就是 if、else 或者是 switch 分支，以及循环控制，如 for 循环，while 循环 do while 循环等。这三种结构的特点是：</p><ul><li>单一的入口和出口</li><li>结构中的每个部分都有被执行的可能</li><li>结构内不应该出现永不终止的死循环</li></ul><p>而程序设计方法就是结构化程序设计 (structured programming)，C 语言就是典型的结构化程序设计语言。</p><h2 id="程序的算法表示"><a href="#程序的算法表示" class="headerlink" title="程序的算法表示"></a>程序的算法表示</h2><p>计算机科学家尼·沃斯 (N · Wirth) 表示，<strong>计算机科学就是研究算法的学问</strong>。算法的特点就是：</p><ul><li>确定性</li><li>有穷性</li><li>可行性</li><li>有零个或多个输入</li><li>有一个或多个输出</li></ul><p>而一个算法，我们可以通过四个步骤来实现。</p><ol><li>用文字描述算法，把所要进行的算法写出来</li><li>用流程图去描述，绘制流程图是程序员应该要具备的一项技能</li><li>伪代码表示，计算机无法运行伪代码</li><li>所以最后一步我们还需要把它转换成程序设计语言</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C 语言笔记复盘 </category>
          
          <category> C </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学网页设计 2 使用 HTML 和 CSS 构建页面</title>
      <link href="/2023/cdbf2aa6.html"/>
      <url>/2023/cdbf2aa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇文章我们学习了关于Web响应式设计的基础知识，了解了如何构建适应各种设备和屏幕尺寸的网站。现在，让我们进一步深入，开始学习如何使用HTML和CSS构建页面，为我们的响应式设计奠定坚实的基础。在这篇文章中，我们将逐步了解页面的结构、样式和布局，让你能够创建出令人印象深刻的用户界面。让我们开始吧！</p><h1 id="构建页眉"><a href="#构建页眉" class="headerlink" title="构建页眉"></a>构建页眉</h1><p>现在我们已经有了页面的基本结构，我们可以开始构建每个部分。让我们从页眉开始：</p><p><img src="/uploads/sololearn/responsive-web-design/header.png" alt="页眉成果"></p><p>我们使用 h1 和 h2 标签来表示文本，使用 a 标签来创建按钮。同时，我们使用一个包裹整个页眉的容器 div，以便我们可以通过CSS进行样式设置：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Awesome App<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This app will change your life!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>Download Now<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们为容器 div 和 “Download Now” 链接定义了相应的类。</p><div class="note info flat"><p>现在是时候添加一些CSS样式了！</p></div><p>现在是时候为我们的页眉元素添加一些CSS样式了。让我们从 <code>h1</code> 和 <code>h2</code> 标签开始：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">16px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">300</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">16px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们定义了字体大小和边距。</p><div class="note info flat"><p>回想一下边距值的工作方式：第一个值是上边距，第二个值是右边距，第三个是下边距，最后一个定义左边距。这意味着值按顺时针方向排列，从上方开始。</p></div><p>对于我们的容器 (<code>container</code>) div，我们将定义以下样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">900px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们的页眉占据了浏览器的整个宽度，我们使用 <code>max-width</code> 属性将文本容器的最大宽度限制为900px。这使得 <code>div</code> 停止扩展，以防止文本变得过于宽广。由于我们将重用 <code>container</code> 类于其他部分，我们定义了一些左右填充 (paddings)，以确保子元素离屏幕边缘有20px的距离。</p><div class="note info flat"><p><code>margin: 0 auto;</code> 确保内容保持在 <code>container</code> 的中心，不考虑其大小。在宽度大于 900px 的屏幕上，容器 div 的宽度将为 900px，因此我们将其居中对齐。</p></div><h2 id="设定按钮样式"><a href="#设定按钮样式" class="headerlink" title="设定按钮样式"></a>设定按钮样式</h2><p>我们的页眉 (header) 几乎准备好了！</p><p>然而，目前我们的 <code>Download Now</code> 按钮只是一个没有任何样式的链接。为了使其看起来像一个按钮，我们需要添加以下样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#549DA0</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>display</code> 属性指定元素的显示行为 (display behaviour) 。我们将其设置为 <code>inline-block</code>，以使链接表现为内联块容器 (inline block container)。</p><div class="note info flat"><p>我们还设置了颜色 <code>color</code>、字体大小 <code>font-size</code> 以及 <code>border-radius</code>，以实现圆角效果。</p></div><p>我们的按钮还需要一个悬停 (hover) 效果，以便在鼠标悬停在上方时改变其背景颜色。</p><p>为了定义样式，我们将使用 <code>:hover</code> 选择器：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#468486</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当光标悬停在按钮上时，按钮的背景颜色会改变。</p><div class="note info flat"><p>你还可以使用 CSS 的 <code>transition</code> 属性来使变化更加平滑。例如：<code>transition: background 0.5s;</code></p></div><h1 id="构建特性-Features-部分"><a href="#构建特性-Features-部分" class="headerlink" title="构建特性 Features 部分"></a>构建特性 Features 部分</h1><p>让我们开始构建我们的特性部分：</p><p><img src="/uploads/sololearn/responsive-web-design/features.png" alt="特性部分"></p><p>这个部分包含三个特性，每个特性都有一个图像和文本，它们水平排列在一起。</p><p>我们将重用我们的容器 div 来包裹特性部分的所有元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;features&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feature&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img_blue_pin.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>An awesome feature<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feature&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img_blue_chart.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>An awesome feature<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;feature&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img_blue_msg.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>An awesome feature<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个特性都被包裹在一个带有类名 <code>feature</code> 的 div 中，我们将使用这个类来定位特性。它包含一个图像和一个文本段落。目前，它们只是垂直排列在一起，因此我们需要添加一些 CSS 样式来修复它。</p><div class="note info flat"><p>我们使用了一些我们上传到源码中的示例图像文件。如果要上传自己的图片，可以<a href="https://code.sololearn.com/WW6t4B73kJVz/">参考使用 Dropbox</a></p></div><div class="note warning flat"><p>请始终记住，大型图像会减缓您的网站并增加加载时间。因此，在设计网站时，尽量优化和压缩图像，以确保更快的加载速度和更好的用户体验。</p></div><p>为了让特性 div 水平排列在一起，我们将使用 <code>display: inline-block</code> 来使它们成为内联级块容器并提供一个宽度：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.feature</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.feature</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们有 3 个特性，我们给每个特性 div 分配了其容器宽度的 32%。剩余的空间将留给元素之间的间隔。我们还将图像的宽度设置为其容器宽度的 40%。</p><p>通过仅使用百分比值作为宽度，特性将始终保持在一起，水平排列，不受浏览器宽度的影响。</p><h1 id="构建引用-Quotes-部分"><a href="#构建引用-Quotes-部分" class="headerlink" title="构建引用 Quotes 部分"></a>构建引用 Quotes 部分</h1><p>我们的引用部分 (Quotes) 包含一位满意客户的推荐语：</p><p><img src="/uploads/sololearn/responsive-web-design/quotes.png" alt="引用部分"></p><p>让我们使用语义标签构建 HTML：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;quote&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&quot;Some great quote!&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cite</span>&gt;</span>Satisfied Customer<span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们使用 <code>blockquote</code> 标签作为容器，并在其上重复使用我们的 container 类。在 <code>blockquote</code> 内部，我们有一个表示引用的文本段落和一个 <code>cite</code> 标签，包含客户的姓名。</p><div class="note info flat"><p><code>blockquote</code> 元素指定引用的部分，而 <code>cite</code> 用于定义标题。</p><p><code>&lt;blockquote&gt;</code> 是块级元素，而 <code>&lt;q&gt;</code> 是内联元素。</p><ul><li><code>&lt;blockquote&gt;</code>：表示一块引用内容，通常用于长引用，可以包含段落等其他块级元素。</li><li><code>&lt;q&gt;</code>：表示一个短的内联引用，通常用于包裹短句或短语。</li></ul><p>因此，如果引用是一整段文字，可以使用 <code>&lt;blockquote&gt;</code>，如果引用只是一个短语或一句话，可以使用 <code>&lt;q&gt;</code>。</p><p>根据 W3S，<code>&lt;cite&gt;</code> 标签应该用于定义“创意作品的标题（例如书籍、诗歌、歌曲、电影、绘画、雕塑等）。注意：个人的名字不是作品的标题。”</p><p>这可能是在 HTML 中处理这种内容的正确方式：<a href="https://css-tricks.com/quoting-in-html-quotations-citations-and-blockquotes/#hey-what-about-the-figure-element">Quoting in HTML: Quotations, Citations, and Blockquotes</a>。</p></div><p>是时候定义样式了！</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">cite</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">cite</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;–&#x27;</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们需要重置 blockquote 元素的 padding / margin，因为浏览器对它们有一些默认值。我们还为元素定义了字体大小和边距。</p><p>最后但同样重要的是，我们使用 <code>:before</code> 选择器在 cite 元素之前设置了一个短横线。</p><div class="note info flat"><p>我们本可以在 cite 标签的文本中添加短横线 <code>&amp;mdash;</code>，但这是以一种更炫的方式完成相同的事情。</p><ul><li>双冒号用于伪元素 <code>::pseudo-element</code>！</li><li>单冒号用于伪类 <code>:pseudo-class</code>！</li></ul></div><h1 id="构建页脚"><a href="#构建页脚" class="headerlink" title="构建页脚"></a>构建页脚</h1><p>我们着陆页的最后一部分是页脚：</p><p><img src="img-component" alt="页脚部分"></p><p>它包含一个菜单和版权文本。</p><p>使用列表来表示菜单项是常见做法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Contacts<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>© All rights reserved<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们重用了 container div 以提供必要的内边距和居中对齐。</p><p>每个菜单链接都包含在列表项中。</p><p>版权文本是一个简单的段落。</p><div class="note info flat"><p>默认情况下，列表项被样式化为垂直项目符号列表。我们将在本课程的下一部分中使用 CSS 更改该样式。</p></div><p>这是CSS代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#353535</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">32px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#868686</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c3c3c3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了使菜单列表水平，并移除项目符号，我们对 ul 元素使用了 <code>list-style: none;</code>。</p><p>我们还为列表项设置了 <code>display: inline-block;</code>，使它们成为内联级块容器，从而水平排列在一起。</p><p>其余的样式是简单的文本和背景颜色，以及文字大小。</p><div class="note info flat"><p>我们已经完成了构建着陆页桌面版本的工作！</p><p>然而，尽管它始终占据整个浏览器宽度，但它并不是真正响应式的，因为对于较小的屏幕，布局保持不变，不太适合移动设备。</p><p>我们将在下一模块中使其具备响应式设计！</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Sololearn 自学网页设计 </category>
          
          <category> HTML, CSS, JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学网页设计 1 响应式页面设计</title>
      <link href="/2023/7bb5faec.html"/>
      <url>/2023/7bb5faec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Web 响应式设计 (Responsive web design) 是一种构建可以适应每台设备和每个屏幕尺寸的网站的实践。在本系列文章中，我们将学习如何使用 HTML 和 CSS 构建现代、响应式的网站。我们将从零开始构建一个网站，并在课程结束时使用 JavaScript 为其添加一些功能作为奖励！</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>欢迎来到我们的响应式 Web 设计系列文章！</p><p>如果您对基本的 HTML / CSS 语法不熟悉，我们建议您先参考互联网上关于 HTML 和 CSS 的课程，然后再开始阅读这篇文章。</p><p>这门课程非常精彩，你可以从中学到以下内容：</p><ul><li>媒体查询</li><li>rem 单位</li><li>如何设计页脚</li><li>如何设计标题</li><li>如何设计按钮</li><li>如何制作子菜单（又称下拉菜单）</li><li>引入 flexbox</li></ul><p>如果你想擅长制作漂亮的网站，这门课程绝对会有所帮助！👏👏</p><h1 id="响应式Web设计"><a href="#响应式Web设计" class="headerlink" title="响应式Web设计"></a>响应式Web设计</h1><p>响应式Web设计是一种构建能够适应各种设备和屏幕尺寸的网站的实践。</p><p>一个响应式网站可以在不同的屏幕尺寸上使用，从大型桌面到小型移动屏幕。</p><div class="note info flat"><p>响应式Web设计的主要概念是通过适应和改变页面样式来响应屏幕大小的变化，从而构建具有适应性的布局。</p></div><h1 id="我们的学习成果"><a href="#我们的学习成果" class="headerlink" title="我们的学习成果"></a>我们的学习成果</h1><p>课程项目</p><p>让我们来看一下我们将构建的项目：一个通用的应用程序落地页。<br>在桌面上，它的样子如下：</p><p><img src="/uploads/sololearn/responsive-web-design/landing-page.png" alt="落地页面"></p><p>正如你所看到的，这个落地页 (landing-page) 有许多部分：</p><ul><li>一个带有文本和按钮的页眉 (header)</li><li>一个特性部分 (features)</li><li>一个引用部分 (quote)</li><li>一个带有菜单的页脚 (footer)</li></ul><div class="note info flat"><p>落地页 (landing-page) 是用户在点击促销 (promotional) / 营销 (marketing) 链接时着陆的地方。<br>例如，当你想推广你的应用时，你会在社交媒体和其他媒体上分享其落地页的 URL。</p></div><p>我们将创建一个响应式的落地页，使其能够适应不同的屏幕尺寸。<br>例如，在移动设备上的显示如下：</p><p><img src="/uploads/sololearn/responsive-web-design/landing-page-mobile.png" alt="移动端落地页面"></p><div class="note info flat"><p>正如你所看到的，一些部分在移动设备上会改变它们的布局。例如，特性部分和页脚菜单变成垂直列表，下载按钮变得更宽等。</p></div><h1 id="HTML-结构"><a href="#HTML-结构" class="headerlink" title="HTML 结构"></a>HTML 结构</h1><p>让我们从构建落地页的基本 HTML 结构开始。我们将首先构建桌面版本，然后将其调整为移动设备并使其响应式。<br>我们将使用 HTML5 语义标签来定义各个部分：</p><div class="note primary flat"><p>所有的代码将会发布在我的 GitHub 上，仓库暂定为 <a href="https://github.com/kingsmai/resp-web-design">resp-web-design</a> 页面参考<a href="https://kingsmai.github.io/resp-web-design">在这</a></p></div><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Landing Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      header</span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;features&quot;</span>&gt;</span></span><br><span class="line">      features</span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;quote&quot;</span>&gt;</span></span><br><span class="line">      quote</span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">      footer</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们为页眉使用了 <code>&lt;header&gt;</code> 标签，对于特性和引用部分使用了 <code>&lt;section&gt;</code> 标签，并为特性和引用部分分别赋予了相应的类名，以便我们可以为它们定义 CSS 样式。</p><div class="note info flat"><p>目前我们还没有定义任何 CSS 样式，因此这些部分只是带有虚拟文本的白色块。</p></div><p>现在，我们需要添加一些基本的 CSS 样式，为我们的各个部分增加一些颜色和大小。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#284b63</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">80px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.features</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.quote</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#549DA0</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#353535</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">32px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#868686</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 padding 属性为各个部分增加一些高度。</p><div class="note info flat"><p>由于我们仅为 padding 提供了两个值，它将同时将上下 padding 设置为提供的值（padding: 40px 0; 相当于 padding: 40px 0 40px 0;）。</p></div><p>我们还为各个部分定义了背景和文字颜色。</p><p>我们没有给各个部分指定宽度，因此它们将占用整个可用宽度。这意味着当屏幕被调整大小时，各个部分的宽度将始终保持为可用宽度的 100%。由于我们计划创建一个响应式页面，我们不会为各个部分设定任何固定的宽度值；相反，我们让它占据整个屏幕的宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Sololearn 自学网页设计 </category>
          
          <category> HTML, CSS, JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速开发十款游戏系列（1）：飞机大战 策划篇</title>
      <link href="/2023/215fd6fd.html"/>
      <url>/2023/215fd6fd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在游戏设计界流传着这么一段话：“要快速的做完你的前十款游戏，你的前十款游戏都是垃圾”。是的，不要幻想着你的第一部作品就需要怎么样怎么样好玩。先做，再评估，才是学习和完成一个目标的根本。</p><p>那么我选的第一款被我拿来嚯嚯的游戏就是《飞机大战》。</p><div class="note primary flat"><p>打飞机街机游戏是一种以飞行射击为主题的街机游戏，通常需要玩家投入硬币或代币来开始游戏。这种游戏的历史可以追溯到20世纪80年代，当时的代表作有《1942》和《雷电》。打飞机街机游戏的特点是画面精美，音效震撼，操作简单，难度递增，玩家需要不断地消灭敌人，获得道具，升级武器，挑战更高的关卡和得分。打飞机街机游戏的类型有很多，比如横版，纵版，弹幕，模拟，即时战略等。打飞机街机游戏的题材也很丰富，有以第二次世界大战为背景的，有以未来科幻为主题的，有以动漫人物为角色的，等等。打飞机街机游戏是一种经典的街机游戏类型，至今仍有很多爱好者和收藏者，不断寻找和保存这些游戏的机台和软件。🕹️</p></div><p>本篇文章就是本系列中的第一篇 ——《飞机大战游戏开发之策划篇》</p><h1 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h1><p>既然是快速开发，那一切从简。以下就是一个简单的飞机射击游戏的策划概要：</p><p><strong>游戏名称：</strong> 天空之战</p><p><strong>游戏类型：</strong> 射击游戏</p><p><strong>故事背景：</strong></p><p>在未来的科技世界中，地球面临外星入侵。玩家将扮演宇宙飞行员，驾驶先进的战机，保卫地球免受外星生物的入侵。</p><p><strong>游戏玩法：</strong></p><ul><li><strong>飞行控制：</strong> 玩家可以通过键盘或触屏控制飞机的飞行方向，以躲避敌人的攻击。</li><li><strong>武器系统：</strong> 玩家的战机配备多种武器，包括机枪、导弹和激光炮。玩家可以根据情况切换不同的武器。</li><li><strong>关卡设计：</strong> 游戏包含多个关卡，每个关卡有不同的地貌和敌人。随着关卡的升级，敌人的种类和攻击方式也会增加。</li><li><strong>升级系统：</strong> 玩家通过击败敌人或完成任务可以获得积分，用于升级飞机性能、武器火力或解锁新的战机。</li><li><strong>Boss战：</strong> 每个关卡结束时，玩家将面对一名强大的Boss敌人，需要运用战术和技能来击败它。</li></ul><p><strong>美术设计</strong></p><ol><li><strong>风格：</strong> 选择明亮而动感的画面风格，突显飞机飞行的刺激感。</li><li><strong>敌人设计：</strong> 设计各种外星生物，每种都有独特的外观和攻击方式。</li><li><strong>场景设计</strong> 不同的关卡应具有多样性的地貌，例如城市、山脉、海洋等，以增加游戏的趣味性。</li></ol><p><strong>音效设计</strong></p><ul><li><strong>引人入胜的音乐：</strong> 选择激动人心的背景音乐，增强玩家的游戏体验。</li><li><strong>音效效果：</strong> 设计真实的飞机引擎声、武器射击声和敌人爆炸声，以提高游戏的沉浸感。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 快速开发十款游戏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 15 ROC 曲线</title>
      <link href="/2023/787a0c90.html"/>
      <url>/2023/787a0c90.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="如何构建ROC曲线"><a href="#如何构建ROC曲线" class="headerlink" title="如何构建ROC曲线"></a>如何构建ROC曲线</h1><p>ROC曲线是特异性和敏感性（Specificity vs Sensitivity）的图表。我们构建一个逻辑回归模型，然后计算每个可能阈值的特异性和敏感性。每个预测概率都是一个阈值。如果我们有5个数据点，其预测概率分别为：0.3, 0.4, 0.6, 0.7, 0.8，我们将使用这 5 个值作为阈值。</p><p>请注意，实际上我们绘制的是敏感性与（1 - 特异性）的关系图。这样做的主要原因是标准化。</p><p>让我们首先看一下构建 ROC 曲线的代码。Scikit-learn 有一个 <code>roc_curve</code> 函数让我们使用。该函数接受模型的真实目标值和预测概率。</p><p>我们首先使用模型上的 <code>predict_proba</code> 方法获取概率。然后调用 <code>roc_curve</code> 函数。<code>roc_curve</code> 函数返回一个假阳性率 (False Positive) 数组，一个真阳性率 (True Positive) 数组和阈值 (Threshold)。假阳性率是 1 - 特异性（ x 轴 ），真阳性率是敏感性的另一种表达（ y 轴 ）。图中不需要阈值值。</p><p>这是在 matplotlib 中绘制 ROC 曲线的代码。请注意，我们还有绘制对角线的代码。这可以帮助我们直观地看出我们的模型离随机预测的模型有多远。</p><p>我们假设我们已经有了一个已分割成训练集和测试集的数据集。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">y_pred_proba = model.predict_proba(X_test)</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba[:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(fpr, tpr)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;1 - 特异性&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;敏感性&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>You have to import roc_curve to run the code</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br></pre></td></tr></table></figure></div><p><img src="/uploads/sololearn/machine-learning/the%20roc%20curve.jpg"/></p><div class="note info flat"><p>因为我们不使用阈值来构建图形，所以图形并不能告诉我们每个可能模型的阈值是多少。</p></div><div class="note warning flat"><p>In case you are having issues understanding the concept of ROC curves, watch the video in the link below 👇 </p><p><a href="https://m.youtube.com/watch?v=4jRBRDbJemM">https://m.youtube.com/watch?v=4jRBRDbJemM</a></p></div><h1 id="ROC曲线解释"><a href="#ROC曲线解释" class="headerlink" title="ROC曲线解释"></a>ROC曲线解释</h1><p>ROC曲线显示的不是单个模型的性能，而是许多模型的性能。每个阈值的选择对应一个不同的模型。</p><p>让我们看一下突出显示这些点的ROC曲线。</p><p><img src="/uploads/sololearn/machine-learning/the%20roc%20curve%20with%20points.jpg"/></p><p>每个点 A、B 和 C 表示具有不同阈值的模型。</p><p>模型A的敏感性为 0.6，特异性为 0.9（请记住图表显示的是 1 减去 特异性）。<br>模型B的敏感性为 0.8，特异性为 0.7。<br>模型C的敏感性为 0.9，特异性为 0.5。</p><p>在这些模型之间如何选择将取决于我们情境的具体情况。</p><div class="note info flat"><p>曲线越靠近左上角，性能越好。曲线不应该低于对角线，因为那意味着它的性能比随机模型还差。</p></div><div class="note primary flat"><p>请记住，我们的目标是最大化这两个值。一个理想的模型将具有敏感性为 1 和特异性为 1，因此敏感性 + 特异性的总和为2。</p><ul><li>模型A的敏感性为 0.6，特异性为 0.9，总和为 1.5；</li><li>模型B的敏感性为 0.8，特异性为 0.7，总和为 1.5；</li><li>模型C的敏感性为 0.9，特异性为 0.5，总和为 1.4。</li></ul><p>因此，我们可以说模型 A 和模型 B 的表现相当，但模型 C 稍逊一筹，因为其敏感性和特异性之和较低。你可以看到 A 和 B 都与左上角等距，而 C 则更远。我猜你可能仍然会选择使用 C，这取决于具体情况。例如，如果你确实需要一个敏感性（召回率）更高的模型，即使特异性 / 精确度较低。</p><p>我认为这确实取决于具体情况，不一定是敏感性和特异性之和越高模型就越好。在某些情况下，你可能只需要高特异性，而不关心敏感性。最终取决于目标。</p></div><h1 id="从-ROC-曲线中选择一个模型"><a href="#从-ROC-曲线中选择一个模型" class="headerlink" title="从 ROC 曲线中选择一个模型"></a>从 ROC 曲线中选择一个模型</h1><p>当我们准备最终确定我们的模型时，我们必须选择一个单一的阈值来进行预测。ROC 曲线是帮助我们为我们的问题选择理想阈值的一种方式。</p><p>让我们再次看一下我们突出显示三个点的 ROC 曲线：</p><p><img src="/uploads/sololearn/machine-learning/the%20roc%20curve%20with%20points.jpg"/></p><p>如果我们处于一个情况：其中所有正类别的预测都正确更重要，而不是我们捕捉所有正类别的情况（这意味着我们要正确预测大多数负类别），我们应该选择特异性较高的模型（模型 A）。</p><p>如果我们处于一个情况，其中尽可能多地捕捉正类别的情况更为重要，我们应该选择敏感性较高的模型（模型 C）。</p><p>如果我们希望在敏感性和特异性之间取得平衡，我们应该选择模型 B。</p><details class="toggle" ><summary class="toggle-button" style="">原文</summary><div class="toggle-content"><p>If we are in a situation where it’s more important that all of our positive predictions are correct than that we catch all the positive cases (meaning that we predict most of the negative cases correctly), we should choose the model with higher specificity (model A).</p><p>If we are in a situation where it’s important that we catch as many of the positive cases as possible, we should choose the model with the higher sensitivity (model C).</p><p>If we want a balance between sensitivity and specificity, we should choose model B.</p></div></details><div class="note info flat"><p>跟踪所有这些术语 (terms) 可能有点棘手。即使是专业人士也不得不再次查阅它们，以确保他们正确解释这些值。</p></div><h2 id="从-ROC-曲线中选择一个模型的练习"><a href="#从-ROC-曲线中选择一个模型的练习" class="headerlink" title="从 ROC 曲线中选择一个模型的练习"></a>从 ROC 曲线中选择一个模型的练习</h2><p>假设我们有一个用于预测信用卡欺诈的模型。如果我们在某人的账户上检测到欺诈交易，我们将禁用他们的信用卡。因此，我们希望确保在做出正类别预测时我们是准确的。在ROC图中的这三个模型中，哪一个在这种情况下更可取？</p><details class="toggle" ><summary class="toggle-button" style="">查看答案和解释</summary><div class="toggle-content"><p>A</p><p>In the case of predicting credit card fraud, where it’s crucial to ensure accuracy when making positive predictions (minimizing false positives), a higher specificity is preferred. Therefore, Model A, which has higher specificity, would be preferred in this scenario. This is because a higher specificity indicates a lower false positive rate, meaning that the model is less likely to incorrectly flag legitimate transactions as fraudulent.</p><p>在预测信用卡欺诈的情况下，当确保在进行正类别预测时的准确性至关重要（最小化假正例），更高的特异性是首选的。因此，在这种情况下，更倾向于选择具有较高特异性的模型 A。这是因为较高的特异性表示较低的假正例率，意味着该模型更不太可能将合法交易错误地标记为欺诈。</p></div></details><h1 id="曲线下面积-Area-Under-the-Curve"><a href="#曲线下面积-Area-Under-the-Curve" class="headerlink" title="曲线下面积 Area Under the Curve"></a>曲线下面积 Area Under the Curve</h1><p>有时我们希望使用ROC曲线来比较两个不同的模型。这里是两个模型的ROC曲线比较。</p><p><img src="/uploads/sololearn/machine-learning/roc%20curve%20of%20two%20models.jpg"/></p><p>你可以看到蓝色曲线的性能优于橙色曲线，因为蓝线几乎总是在橙线上方。</p><p>为了获得这个的经验性度量，我们计算曲线下面积，也称为 AUC（Area Under the Curve）。这是 ROC 曲线下面的面积，取值范围在 0 到 1 之间，数值越高越好。</p><p>由于 ROC 是各种具有不同阈值的逻辑回归模型的图表，AUC 并不衡量单个模型的性能。它提供了逻辑回归模型的整体性能的一般概念。要获得单一模型，仍然需要找到问题的最佳阈值。</p><p>让我们使用 scikit-learn 帮助我们计算曲线下面积。我们可以使用 <code>roc_auc_score</code> 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line">roc_auc_score(y_test, y_pred_proba[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里是两条曲线的AUC值：</p><ul><li>蓝色 AUC：0.8379</li><li>橙色 AUC：0.7385</li></ul><p>你可以通过经验性的方式看到蓝色的效果更好。</p><p>我们可以使用 <code>roc_auc_score</code> 函数计算 Titanic 数据集上逻辑回归模型的 AUC 分数。我们构建了两个逻辑回归模型，model 1 具有 6 个特征，model 2 只有 Pclass 和 male 两个特征。我们看到 model 1 的 AUC 分数更高。</p><p>运行此代码以查看结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"></span><br><span class="line">model1 = LogisticRegression()</span><br><span class="line">model1.fit(X_train, y_train)</span><br><span class="line">y_pred_proba1 = model1.predict_proba(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;model 1 AUC score:&quot;</span>, roc_auc_score(y_test, y_pred_proba1[:, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">model2 = LogisticRegression()</span><br><span class="line">model2.fit(X_train[:, <span class="number">0</span>:<span class="number">2</span>], y_train)</span><br><span class="line">y_pred_proba2 = model2.predict_proba(X_test[:, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;model 2 AUC score:&quot;</span>, roc_auc_score(y_test, y_pred_proba2[:, <span class="number">1</span>]))</span><br></pre></td></tr></table></figure><div class="note info flat"><p>重要的是要注意，这个指标告诉我们逻辑回归模型在我们的数据上总体表现如何。由于 ROC 曲线显示了多个模型的性能，AUC 并不衡量单个模型的性能。</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈编程中的学习路线 - 我的学习经历</title>
      <link href="/2023/8855a9f7.html"/>
      <url>/2023/8855a9f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天看到一个很有意思的视频回复：</p><p><img src="/uploads/images/bilibili-comment-20231226.png" alt="某网友在 B 站上的疑问"></p><p>现在回想起来，编程这个领域到底有没有一个学习路线呢？现在的我给出的回答是：</p><blockquote><p>没有，要什么学什么。</p></blockquote><p>很多时候，我遇到的情况都是这样：</p><ol><li>欸 ~ 小麦，可以帮我开发个小程序嘛</li><li>啊？小程序啊，我没啥经验咧，不过可以试试。你想做什么类型的小程序？</li><li>啊我想做这样这样的……</li><li>哦哦，这样啊，那行，我试试看吧</li></ol><p>然后我就开始敲代码了，并且某些东西不清楚怎么实现的时候，就去搜索</p><p>但是转念一想……<strong>真的是这样吗？</strong></p><h1 id="编程中有学习路线吗"><a href="#编程中有学习路线吗" class="headerlink" title="编程中有学习路线吗"></a>编程中有学习路线吗</h1><p>要搞清楚这个问题，首先要了解：<strong>一个领域，是分为很多不同的阶段的</strong>。在不同的阶段，得出的答案必然不同。这样，以下就用我的故事来为大家说说我从懵懂无知到能够独立开发一个项目的心路历程。</p><h2 id="我的故事：初识编程"><a href="#我的故事：初识编程" class="headerlink" title="我的故事：初识编程"></a>我的故事：初识编程</h2><div class="note success flat"><p>省流：渴望拥有学习路线</p></div><p>一开始，我们都是懵懂无知的小白。那时候，一个网站上酷炫的动画、一个 RPG Maker 制作出来的游戏、一个 Flash 写几行 Action Script 做出来的可交互动画。对于我来说都是很有冲击力的科技产物。那时候的我，是<strong>渴望拥有一条学习路线的</strong>。我们一定会羡慕所有大佬，信手拈来一个很牛的项目、一个很帅的动画。自己也想学，奈何根本就无从下手。</p><p>有时候。</p><p>你想学，都不知道从哪里开始学。你想通过阅读来提升自己的知识，但却不知道应该读哪一本书。你想搜索某些资料，都不知道输入哪些关键字。</p><div class="note danger flat"><p>甚至，你都不知道有这篇文章的存在。。。</p></div><p>我第一次接触编程，就是在我小学的时候上的电脑课、通过 YouTube 学的 Visual Basic。当时通过。时间太遥远了，依稀记得，当时候搜索的关键字应该是：<code>How to program</code> 或者 <code>How to crack a game</code> 所推送的衍生作品。总之，当时那段接触编程的机遇真的很魔幻。</p><p>可能你们是幸福的，还能接触科技产物，学习一些新的事物。至少当时我家是不让我碰电脑的，这种编程上的东西，更是被我爸认为是<strong>迟早让电脑中病毒</strong>的歪门邪道。我被摔过游戏机（当时喜欢破解游戏，有了台 PSP 就成天琢磨着怎么给游戏设置金手指）、被剪过数据线（反正我只要打开电脑，不管是在写代码还是真的在打游戏，家里都会觉得我一定是在打游戏），也被灌输过<strong>什么时候应该做什么事情</strong>，是的，我的成绩非常的糟糕，非常！糟糕！</p><p>不夸张的说，我整个中学生涯，从入学初中平均在 70%，排名全班中央，但到了高中甚至降到了 50% 以下，甚至不让毕业的那种。。。这段历史，现在翻回去看确实不忍直视。所以这篇文章也是我的<strong>逆袭人生笔记</strong>。我现在的总平均在 88.98%，GPA 3.93，是学校的年级第 15 名，获奖无数。<strong>看到这篇文章的家长，可以适当的培养孩子自身的兴趣</strong>。</p><hr><p>到了初中，学校有电脑课，恰巧学校的电脑课是编程教学的。这一下就感觉：嗷~ 我的恋爱时刻来了！这不排除在编程领域上是需要<strong>天赋</strong>，但是你不试试怎么知道你不行呢？我当时是这样的：我整个中学生涯，成绩虽然说不达标，但是电脑课每一次考试，必定拿 95% 以上，6 年成绩至少在 97% 以上（前一两次可能是平时分拉低了，后来在班上表现良好，每一次考试都是 100%）。平时考试也是最早睡觉那个家伙。平均一门电脑考试，我估计只用 30 分钟（考试时长 2 小时）就能睡觉。成绩不差！</p><p>这时候，我开始接除了 Flash、接触了 RPG Maker。。。我了解了代码中是一行一行由上往下执行的。具体怎么了解的，忘记了（大概是初一的事情了），可能是 YouTube 学来的？也可能是不小心写错代码，然后 Debug 的时候发现卡在那里了，着重研究了一下。</p><p>所以在我初中的阶段，我对编程开始培养了兴趣，开始对代码感兴趣。我的学习路线，就是 YouTube 上东拼西凑的 Tutorials。你说有用吧。。。好像当时学的又不是正确的东西，你说没用吧。。。那它确实是我的编程启蒙教育。</p><p>就这样，我的中学生涯就结束了</p><h2 id="我的故事：初学编程"><a href="#我的故事：初学编程" class="headerlink" title="我的故事：初学编程"></a>我的故事：初学编程</h2><div class="note success flat"><p>省流：拥有学习路线</p></div><p>这时候，我进入了大学。别问成绩差怎么进来的。天选之子（完了会被打，总之就是有点幸运）。。。而且我在统考的时候确实努力了，考的确实比以往所有的考试都还要好（虽然都是在及格线，但是还是顺利毕业了）<strong>逆袭经验 + 1</strong>。也很幸运，我选择了计算机科学与技术这门专业。那么这部分就是重点了，大家所说的学习路线应该就是从这里出来的。大学里系统性的教学确实是一个很不错的入门手段。我们的学习课程是这样安排的，你们可以参考。当然，对于某些重点课程，我将会跳出来精讲，剩下的自己悟。</p><p>当然，我的大学生活也很悲惨，正好撞上了 2 年半的疫情。一切都靠自学。</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>整个大一，第一学期学习了：C 语言、计算机导论、网页设计与开发、JavaScript 程序设计以及数字逻辑。</p><h4 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h4><p>这门课一直以来都作为程序员的启蒙课程而存在，从编程的概念，到变量，再到函数，最后再到指针。。。这些一系列的概念。但是最重要的一个，也是很多老师会忽略的点 —— 培养学生们对于编程的思维能力。编程这个领域就是训练思维的。思维才是重中之重。</p><p>为什么？设想今天你拿到一个编程题目，或者说需要你实现某个功能。光靠编程课所学的概念是行不通的。就算你懂循环、懂得判断。但是你不懂应该怎么<strong>处理问题</strong>那他永远都不可能去解决问题。当然，我遇到过我的师弟是这样的，今天一个问题不会解决，但是给他说了思路之后，他把代码敲错了（这里的错指的是 <code>main</code> 写成 <code>mian</code>、<code>void main</code> 的返回值是 <code>return 0</code> 这类型算是基础的错误），这就代表他不仅没学会编程思维，连编程基础都不会。</p><p>编程这块，对我来说就是水到渠成的事情，比如说 <code>main</code> 函数，就是英文里 “主要” 的意思，主要的函数。要将这类型的相关知识点融会贯通，才能实现所谓的：Good Code Is Easily Read and Understood, in Part and in Whole。所以对于那些说 “我英文不好，学不来编程”，以我的角度，就是一个逃避的藉口，学习永远是提升自己而不是让别人受惠的过程。</p><h4 id="计算机导论"><a href="#计算机导论" class="headerlink" title="计算机导论"></a>计算机导论</h4><p>这门课就是让学生了解一个电脑中的软硬件分别进行什么操作，计算机是怎么工作的。这是计算机科学与技术这门专业的核心课程，你得了解 CPU 是怎么运作的，才能去了解你的代码究竟在电脑里执行了什么操作。为什么某些代码被称之为<strong>屎山代码</strong>？他到底对 CPU 进行了哪些摧残。。。</p><h4 id="网页设计与开发"><a href="#网页设计与开发" class="headerlink" title="网页设计与开发"></a>网页设计与开发</h4><p>这门课我觉得是大一里面比较有趣的一门课，不是因为他多么的深奥，而是这是一门<strong>前端开发</strong>的课。这就意味着，我再也不需要对着那个黑屏控制台输入输出一堆奇怪的数学题了！！！这门课主要在于学习 HTML 以及 CSS 如何对网页进行设计。虽然现在我们也不怎么会去用纯 HTML 来构建一个前端页面了，但是这是基础。和纯 C 语言不再用于构建某个功能很强大的应用是一样的道理。现阶段都有更优秀的框架进行前端开发，如 Vue、Angular、React 等等。</p><h4 id="JavaScript-程序设计"><a href="#JavaScript-程序设计" class="headerlink" title="JavaScript 程序设计"></a>JavaScript 程序设计</h4><p>这门课嘛，简直就是给网页设计与开发这门课叠加了 BUFF，此话怎讲？因为 JavaScript 是用于给静态页面做交互的，这就意味着我可以让我的页面动起来了。这其实就是学习中很重要的一点：奖励机制。欸！我的页面动起来了欸！听起来就特别兴奋不是嘛？</p><h4 id="数字逻辑"><a href="#数字逻辑" class="headerlink" title="数字逻辑"></a>数字逻辑</h4><p>来到了一门比较枯燥但是也同样很重要的课程。我觉得这门课程的前置课程应该是计算机的导论，学什么？学逻辑电路。这门课将学习到各种各样的逻辑门、时序电路、基本芯片等。这门课学好了，以后可以去硬件开发试试？</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>到了大二，我们开始学习 Java 程序设计、Android 移动应用开发、数据结构、React 程序设计等课程。</p><h4 id="Java-程序设计"><a href="#Java-程序设计" class="headerlink" title="Java 程序设计"></a>Java 程序设计</h4><p>Java，可以说是中国整个编程业界最通用的语言了。反正在我的认知中，Java 一直被灌输着 “月薪过万，岗位需求大” 等标签。事实上我们在找工作的时候也确实是这样。但是找工作是后话，不在这里谈。那么从这里开始，我们学到了面向对象思想，了解了怎么将现实世界的东西抽象到编程世界中去。</p><p>也就是这里，我开始进入无休止的网课阶段。我的 Java 编程知识都是从 B站 学来的。应该大家都差不多，听过这么一句话：“零基础，学 IT，月薪过万，就来黑马程序员！”。伴随着我的整个疫情生活。强烈推荐去学黑马的课程，我的评价是：它的公开课比学校教的知识更精深多了。从中我学到了，多线程、抽象、继承等概念。</p><h4 id="React-程序设计"><a href="#React-程序设计" class="headerlink" title="React 程序设计"></a>React 程序设计</h4><p>这门课是我挺痛苦的一门课，因为 React 在国内的材料（当时）是真的很少，这是一个 Facebook 框架，而国内主流框架则是 Vue。我当时不明白为什么学校要交这么一个框架来学习，真难！还不如 Vue 舒服。但是这是我第一次接触 “框架” 确实体验到了用框架开发的香（他确实可以快速开发），和臭（主要前期开发有点麻烦，因为某些概念如生命周期啥的很绕）。</p><h4 id="Android-移动应用开发"><a href="#Android-移动应用开发" class="headerlink" title="Android 移动应用开发"></a>Android 移动应用开发</h4><p>这门课应该是各位能认识我的契机了。基本上安卓这门课说难不难，说简单也并不简单。原因是国内基本很难搜到 Android 的最新文档，很多文档都是镜像搬运的，历史悠久。而你也不可能去学习一些已经淘汰的东西吧？我当时学的时候老师还让开发 Android 4.1。好在最近看学弟学的是 Android Oreo+。再加上国内对 Google 一直是封锁状态，想要完好无损的下载 SDK，简直就是玄学一般的存在。而我当时 “有幸” 因为疫情被困在国外，从而可以无阻获取到最新 Google Developer 的文档。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>重中之重！重中之重！重中之重！</p><p>这门课是计算机中的核心课程，核心的不能再核心了！为什么，它的下一个进化形态叫做：<strong>算法</strong>！不知道各位大学生是否有幸被他摧残过。应该都有，反正很重要。至于怎么重要？老师没说是吧？来，我跟你说</p><p>我遇到一个案例是这样的：我需要为我的游戏生成地牢，我思考良久都没想出来怎么解决问题。直到看了一个<a href="https://halftheopposite.github.io/graph-dungeon-generator/">大佬的源码</a>，一目了然！就是一颗二叉树组成的，那二叉树就是数据结构的一种，而这个案例就是数据结构其中一个很直观的案例。</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>在大三，我们学了 C#，JavaWeb、操作系统、数据库原理、软件测试、以及软件工程理论等。</p><p>明显到了这里，我们已经进入了 BOSS 房。先不说两个和编程相关的东西，直接说后四个理论课：</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>这门课，我基本上上的全是网课，好在网课录播的老师是校外的资深老师，讲的课也挺精深。听得懂，实在不行，还有 BiliBili 作为我的后盾。这门课嘛，也蛮重要，等我有时间了把我的学习笔记一起放上来吧。主要说明了一个操作系统对于我们人类工作提供了哪些便利，其中实现了哪些技术、提供了哪些接口、为什么我们的程序可以在系统上运行。其实操作系统就是我们和计算机的一道桥梁，负责接收我们的输入，如何处理成计算机所理解的形式进行运算，最后再返回到各个软件中。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>这个就不用说了吧，我们的日常生活应该都离不开数据库，他是作为我们的信息存储的媒介。这门课主要是学习怎么对数据库进行管理及操作。以及数据库的一些概念。</p><h2 id="入门者"><a href="#入门者" class="headerlink" title="入门者"></a>入门者</h2><blockquote><p>省流：可以不用学习路线，需要什么学什么</p></blockquote><p>入门，其实是和初学相辅相成的。真正的入门就是在学习了基础知识之后，这门课就算是入门了。在这里，因为我们已经学习了 C 语言，知道应该怎么写代码，了解了编译器的原理。所以这时候我们<strong>需要什么就学什么</strong>而不再需要一个确切的学习路线了。</p><h3 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h3><p>我本来想说自学和大学入门一起写的，但是发现自学这块说实话，大学帮不上什么忙。更多的是靠自己，所以放到这一部分来探讨。</p><p>自学的前提，是你已经构建了基础的编程思维。通俗点说：你已经知道你要干嘛，该怎么干，拿这时候才去自学。否则就想办法去培养你的思维模式，再来谈自学。至于自学，就是缺什么补什么。比如，我喜欢研究计算机的原理，所以我去买了以下这款游戏（没有收恰饭钱！）</p><div style="display: flex; justify-content: center">    <iframe src="https://store.steampowered.com/widget/1444480/?t=%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E8%B0%9C%E9%A2%98%EF%BC%8C%E6%9D%A5%E4%BB%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%BB%E8%BE%91%E9%97%A8%EF%BC%8C%E4%B8%80%E7%9B%B4%E5%88%B0%E6%9E%84%E5%BB%BA%E5%8F%AF%E4%BB%A5%E8%BF%90%E4%BD%9C%E7%9A%84%E4%B8%80%E4%B8%AA%20CPU%E3%80%82%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%BE%E8%AE%A1%E8%AE%A9%E6%88%91%E5%8F%AF%E4%BB%A5%E7%9B%B4%E8%A7%82%E7%9A%84%E6%84%9F%E5%8F%97%E5%88%B0%E7%94%B5%E8%B7%AF%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%AE%AF%E5%8F%B7%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E9%80%92%E7%9A%84%E3%80%82" frameborder="0" width="646" height="190"></iframe></div><p>自学当然还有很多道路，比如：B站、知乎、小红书、甚至购买的各种各样编程相关书籍。。。</p><h2 id="精进者"><a href="#精进者" class="headerlink" title="精进者"></a>精进者</h2><blockquote><p>省流：在入门者的基础上，为了了解底层原理，需要系统的去学习整个技术</p></blockquote><p>我觉得这是我现在的阶段，我无法给出正确的一条路，但是我现在就是想要读研。同时也找到了自己感兴趣的点 —— 人工智能与游戏。那么在这个入门的基础上，我们需要了解其底层原理，然后系统性的去学习整个技术。包括它的衍生知识。以我为例：</p><p>在人工智能方面，我正在精进的学习：</p><ul><li>人工智能概述</li><li>机器学习</li><li>自然语言处理</li></ul><p>而在游戏开发方面，我不仅仅学习了 Unity 以及 Godot 的使用，更学习了：</p><ul><li>游戏策划</li><li>游戏构思</li><li>游戏数值设计</li><li>心理学</li><li>图形学 / Shader 编程</li></ul><p>一门科系，肯定不是学通了这门科系的所有知识就行了，一定是还需要把周围领域的知识学会，才能发挥最大的经济价值。</p><h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>学海无边，这个世界每一天都有新的技术诞生。不学只会被这个社会淘汰，做一个普通人。在编程这个领域，<strong>不存在</strong>哪个编程语言最好、我应该学习哪个语言，这类型的疑问。编程语言、乃至于我们所用的开发环境，他都是一个工具，一把铲子。怎么用不同的工具，去凿出不同的星光大道，那才是你应该关心的事情。</p><p>喜欢这篇文章的朋友可以给我进行打赏，您的支持是我创作最大的动力！谢谢。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2023 年度总结</title>
      <link href="/2023/ccc2b0d8.html"/>
      <url>/2023/ccc2b0d8.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这是一个无效的密码。请检查并重试。" data-whm="这些解密的内容无法验证，但你仍然可以查看。">  <script id="hbeData" type="hbeData" data-hmacdigest="39d79136adfac85eddc8333eedff7970ab33a41d654c45ea3126480a81e9f46c">4630436162ade97ba2718b7d0c4b3b630ef8b034c35893a7afa4c54a5752d90eba191a593f89497fdfca691efaf72d5c35796184ebf2d80300d9b43598d875a7a2ad0b9eb70415ef7e6791ce86b8d42bc2930d2449c14d85e7e73a6e9f9f15fa83d46e9ca1f99dd9edda0d8febda30264fddbaa6efcab895944ce1ae7b482fc4483a710fc7d3e9bbb96f007f13a2bf59f3d26848389daf04b46f1a095f9f9a475ade972447b0b98c0b44a3a143a6b611f105f691a7ba3cb8b12b123a01e72a0ec6dab29050550e7155bdd9d9fab8276660f047cb127d79e6203539733e3080b10671d1a6a55c647d687a46f6fe21f440510dadc723d1e78c2e5995d526054ca6e89ee578ebc5feb1572e915af05ca9d8b32a3f6c4bf5a390e721fc4eb5f0f710007c0262569b01f0fb03e76fc7a376ebc4ee1fd6cf1ba3b8bddf589b56f689ae6a7902e2f8e58de0c825910a859dce25491508e27ef48d13c10179664625042ad486eebe989eee13a1edb255d86e14565a960130abca5a751d3e1e33170409947a903c8857947c02fc46d6c5290b0be610f6f6d6938b83abf408c9c86d9eb1fdbb7874d4043c2e8d971569b5db1b21e3d82019b8a599b92b62d28c14fb8166b6d567213002f409f575af560cac136813960a2b73e6a945ede59a58219c22a637b7d051d495c1a58de70b47f809c0d13f28941db294b220ff10afeceea9049ee8107e6cdab65bf867c9c64222ee44371345ff2b67bf8aa41745becd26e76f5a5349b83fa1cc3edf81189672d40a9b64a0255a997d89db7d7b56b8e0018f737f15fcabc2b1873e407006faf801f364708163dee7d755188995a32522d75ffdb8b906c7eb6f9fff28ab2f29f951d29deca2c35f915c4c789e34f9a55292d992e1e0a679687ba9ba91e69ae4ecd7a0a2343b4516bfcd4c95349cd2fc5aad18ab2e92c8c3c6067c4e5870bf409e8f24ad2d4a2da57bf58d5f63e9dd7dcb55795d41ccdab243c0ab1220c5b1616996c75518e54112374cdc6d6bc8f0972607ab7a2560e897050ada4895b7985458874a46326f7c7dc1c250d1bb2969801de35fcd56b2962778c032e4352c270c4823b0cc8d2aa5fa1e2ce1f6db26dc147d68c3fa51e86ae3081319215da8648d63bf8f19bec75fdce24e8a3367643c7a3dc058235f2dfeb023ac6efe7a46601f3d3e4fa96bb2d4cff1bf3a0d82c53e73c987eff88c9328c1dbc6e09cdb668cf3e1ff61626832d7b4bba5f29f4b26f49519256cb15fd03a6c626d30de59305015e07f124445d03715bf0bfc196d6748a5631b97fd345bf5b0940251b0111d9c50491a432feda48ebc590be61c423854ba89054f903ed186437b51859ada1e49f2f5f9c586f8df78a331e5c04e4d3cafec6f4642a3a3feb62dba4a7667931cc52260dd5e995a21fc70095a8c5c40a00c290586cc02f97809856d05016b935ddc3dc913ad664ff01fdb04ed26b103902b15c140819bcd730c08a5408cb34c7e97fc11eaaf28f01b58395073b4b11871e9f48de628bb4266bc292fb50c77ef2e1fc8ce4b3911bdf8f45805a9a8d48410409743468fc8c65a0466421a274ff836c7deb61bb731fa820ad687edba51152138a7b41c6ca9c82f0cac43b96c151036a739c75bb91742a61eb0332e509de97bbd745b0f2b61d0783f6897c2b6acd1728ac867d12283821b26c2e9fdc1a407c770310726534616759a3a79d779d8b68b18c5a38160cdf30813e8647cd9fdb40af926b7defd7aaf919d7bd88c6ceb05f2ea8e39e3ded3af45fcabc526d7a1064372ec253d0f0ceb7c02a57f38cbb5db9b5debfb02888f6a3f2aad1bc54d7424b3005d5fe124688dde9aa1a144578bface820caf35e36754deaa1c5006cdd040c1def032bef6c0cc03650d5072ebebec27b1cd05c6727c31a49cb7e9a2cec81c450b567acbf3c6ff29f0c8de74b1d3dcb4a3726f7de135855c156bb1bc45ea712b826806a49db62278d3105e72467437cfb19c689d0431315d631a9941211789456b36e308d62353be2f0ed8bd1ac46a07666f867a22cbb8d3a17c777b16af032e68cedae13151a241bf49fa9066f953e13ec8caaef75289cbea80c27e840648dd37b6392500a7a8548ac5bc1bdfe7e709d4e6a33c799424f262f217aed9e44f4fd2c252fb7e7af7d0de71b41c5426cf6765af0cc2f9741ebb2d4c1ad4eca4c04093d9683b587b67e66e857ccec0432c75290549e7d57e5ae165becaa50f1de55e2d827a034738b7661db5a8af6255bafd790b13fee71a07cd7f9be3ee5c67bb74d8d0ecf2b2d6a00a72091f18d0210408e58f0f65a40553acd5a999a789596c3e0da0806390f8649ff429859c105176024508e4a3d2e2017b203dfc86a4d0070bfd17944090bb84c10bf7f8edde45dab3bf5c4017e5970e0f0e2e35568b3edb8e21712d1933dfa40fed9e31f4bba535f9487e58ea4470f006e63c3f6e43559692544bc511cb7586ccd73dea21db777195ec15e5fea7a0681aebfd672c4a80ccb2fbd017d1c46895c93d486b5f12bbe8a50cbbb19b506d4b52e0cb4fa930872775c694b6eb97755a866d51d943f37498f7372479f6a0a4a30801c1feb292d746dfaad88c3489020e0bb7729f991dc2e22c067c2d4f137da03140ffe129f677acb9d493161234335ef3c8715390e3e41b9e9e3b782ca773a25907421972279a821f804a6c61a16ce9938aeaa24abc599fae84895b54fe2eed4efe531101373e9f8c82ffd24500169a1be8761f48d701249ce2ce28b7e7159db78e862d6e8cc529a45090a24c17bbbd537867d467677dca17964f94b586618557aff4235b6e9a6ada6cc77aae6f7e834daa5cc502e47cdb0fe16eef367c998b3d71c0aae2cec76c016f7eb1ea2ceee3304b411a2373be3c69926284afd33c3e2ea6498a459c45a36b6b843cb7e0f2bedb882420fade736ca3e271b09f147c49ea841c273bdd46fffba6bf14b17ca21604bd1a3f2cc8c390c825d0bce660aebd280525a818740d4196462b2bbf5a5788c7ea42172d53f50a6a67547396dfc2f8dcc198b84a41516291a428c666cf7398ccda794cf5efb0b0cbdf44e51679a8abe58c6bbccb7b9706b60e7bbca8367e245c35bf7a5fdc82bab490963c2ddd501d660d52ad8dd5f6db93085486a3744ea84a5e66a2215ae63a78a60f8a7ccf41a375f42a3e434bd25e5cb1ec4bdf60e73d91c47b7244703417b06e29b6d6b3d1a0ec1bc51d61553c696e13ca8de33fccc13cd8eee081674d7a1e4e2d41255d22bc9be90e6cb653d348eceb3a7d907966b5cbd0340d0a9ca2c5b7214c5de0512450cf90a29a2066cddf1af3e54adfea2e3a0148ec35b7c9b4298a3068db04858302a223a07a30515040fd5e15f438f5c17424f384df8f826e87cac3680a3e1845feb18279bc66ab7a82ac06c9ef78a9870a1ea1e6762683d697ff207c2dbdefaed2e29464891f24f2488e5dc362d33ed5d5511403454e52e30ed19bc11ea26d98bf8e3dce295fb4fe142c65c6c216bcc22c7e4c314ef6fde5ffdca515d6b5831202004cfff3d5b35a5187da879a7f3c1f796a92bab4f4072a2b7e5370badbd4acfaebfbc5658d8337f157138bc428028b94abf0b564a32f2d3749a1b69a3c6e863f947f24f6c623e6576f64ce1e113f1073dc442a1e4f7ab7f9f64b33c06309b1db8fdd3ed77375731cd2782512bdd0e31230d7d3fa6319ae91da729b448d3e13aaf208bbd42edcba526ddd7924bdee9536b9b6ae122c8a77165b18e1f835f32f840e7370781a6f41ed39a6fff1512b785b930d237de7533175a7adabb55291e4c07abc61e236ce320fb89b4a9ce99b16b7e5e7d8cb641f8bc00063fe4c830246420779a822ad7c2ca8cd6d6b043db6afc0f61d57556b7a47810eb20232fad0703032920ddd201ae6359b9e1067f0d6645f7ad4af8f2363d03714113a6b2b38ada7d72cfef0e97b52cf4d6bef84f80ccf2f62bb1224f3cda3214ba39481184b1814d1cd7899d9c46f032c8e9c91854c0ae3c2c88fcc01b996dcd1210fc54ea0c03fc40e4e3ad8accd2c90cb0c2e4671c8eb57e08eb0b620f1b32593fc05aad06f42f99f289fcae15d64c89e3037fcead41ccf62698a6c3b7f7044c29431aba86696d633bfff446e41fccedcfc3c3b31c7d33a4a69c22cbcbe4cb4ea7d8c36ef380f3c1a0414b8024b4d5294c4f28026d6a3c0bee88273552dec39004675131698be23b22ed339690705d0d9e836592a226a13ec778c63b8c78ae2b8654ff79374dc13878ea24b19ef6cc0c2d0fd2315fa050b61f9047cecd3a1b5ab7df1f329958b3d798d9ca72ecd4a76cf9352fc90641e70af35407c2209da2182886343c150415a4129d398dfc623d854697ad94cd4005e31ca46f262e1e6b5999643159d7a7a7dde50342edf757e6832d778742c92a739c342dc2eaeac1a5621f8d4414aef95036d1fd07fb03d8dc062fe3a1ed5b7cd47890b2a7e8a7cf9e37254b81b520957b15b1c5bd4b9cee09ca2b5cc291a2f87ab0ca1ade1e8fb8798c0181a68839be16d9b9851dda119feeb62ba4dc00b88d07070f4abce0adff758be8706dc9bb2e78e097acead737411fc86b3b0d260db5cee597a97850ebb2e1a7683654c4f6965da6229c74ae5d6a4c157f55b315e48dfd81794954761b2f355d47d1c35501f74ba07040467d462a2560add4eafcedbd4f45a0a0cdc37b817bf01f56a7f2fc0187f6a9311d01ea3079505737d3354f99610268a8815ce0613754a1d03f83d2314898f6369f67f50700380a84bce9a33caa579351e4bc38473ca1f118ebfa5b4279b8d236d7ab959261ab0ee71dd72c0a584bc92bf1476d9d08d2b6f393cc6e466c5879fb07d30425c73443f0fcc97ac3105ec38c6c4c0d63b432e184d8b5f2e072a5bd02cc977715fa18e51c8c5da1618adc7ca60a96202957e5459018708d4b81d5f3901f8f0a4e0d46613d4489d99c6cd1f8c60fb1dabc1ca8130568124ec66222c681357669099fba7490003e42fc66d77fcb4d564e9c0e2a23b8ea3c6e1f9afda4b2f4996e69ce50db61f0348b6185eb5baea8ffc42ca45e938048dc15d9f4e5d68943cd4977bbeaf7db5a58d9ace6d4468dcd25a01d0edfd3fa966fd55f549c82b4759f15c2856d80774479ad2cd4e52ce8896e75d2b21aea2a747aeb48a52f667194e40d3e4cf682c293f08637f63ec34ceaca8f86ab94697d44d5a0689b2019e6ca45f0c96ce1cfc46ebf2f729b889e872ddbd7d80b10e67ba9f445ab5cbbbdf30421f6ef64ef44d4641de3019ec11154ee81600cfafd14ad5bf73bea5a0cc26bfd535e5c07f2a7d4d9030aae47b6f5074a954549dcc9ed91e077185d24359cef43ad6f7f1caaa3c2431ab22da9f33aebddd7a05e5afb064507bca8328a638154b4783e521bb6b92b886d0e2ace4600db909471b7e6446c9b2f007a0c463ffe11dd3483e316ddc49cd4b37293d9b823615552555c32b2576a49231e99c7e111e263944fd73998cae2684ab81f36b463d0dac49ad268bb845a538b9f8696e9213ae17d244878f5a5bb6f7b00bab368e0c74e987b8e78f46f82f74ba59e205bb057800f807aa4a3b7e5224970c8c676a72273da2e60529f9a3fbe948ceff76b83641d9fa70487afd0b3bb13fed64bcb7e9e2e1a14507343945c76e8c9f573f6fff50c2bf9d592dfbbfb8351d59c29f374541a2f41310dff68c10330b025f261065d18699aacecbce7bab75670c664e5b5fe717de33eea1cba57852499b4df3087e5bd0b181624e457966053cb125cc62afb519a1475b351a16d96cfd192f0d2364f363add6ee1ba3df84ff942f329ed6437fc7e031bf367f0c43f8ccb419a3313b7c30872b45757b5d03667185ebb0575dc406907fa0cf29bdde6573780bba1712fd3d3808199189423bfa8b018f20e931b7d22c78c8f9e960bf45ce4fb099d911720b05aa7fdb5b91cf2feeb0b41321c7ae4ea7955f820649bd79b4b3938e8e49736c54303961be444ec67059d6e399bb43b8d4248544e9cc11fd0f4d22d23edb36c40dbf6b5a252011cad5028b5679aaebb490e22c58b8947becaff78fa2362837843fec0d2b0528ef3cc7170ff5d905d0e5f1d887661b17dc587061c8969a97931bbb44c32553aabf90803eb9024504ada1e7b7395b2ee7b27305bf5d61f33ce9cefca60cdd8d6c56ba30a0c02f09888af82e1b3431389a77f25ec28d4d515c506af105cc8b05db87555358646495861d8ad6da710c538f06d5200898a88c0a5f2a3f6202e34704329673a294695e8c297e9e0cd3af3addfe51516c65544bc1abdce0d75988689d1f41875511546537fc7347291383767f83f4b1ba7acb1f7a1ba92cddbb5b12c130672365eb812586986f6ba316b8dacd78b424f5fdf286c545a4e906a02dc4327653823ff2fc0c6e55d51fb1533dae0d98d23ad37ebd7a1dfa23c68a7d2c358ef4203335f9252ee76b45be96cf1591aa32e06adbb4c6b2b31f49f3e6f2518f54cb36ff80aa106166e2ef6e78c89d8ca5eb0b441e38eb65830f08a570b5f625e4970d1ba545195fc42a4d263d9ba6ff3e49598622bd8eb0bb6e7da88cf341818fd9f2995d04c6bf95254e3b5e6dfe8391554490a30490a9df8384ba501d9823bf435b387cda89dd8dd7d38540f9da04b3710869a60583c51034fd81f5bc6b1fe7f1a29995c959497cdc0f7203cb547f693a2cccec93d1e7fe5c55ac33a93c18e0a56ef71bc0af8db47c57b839dbfcd3dd6ce366d49d6d676cb1946974e13baf58196fd2e67c3fad011c4cdbe0a82d6f088b8974bab42f725f92a7e91a6ee0781f775743169514627093607f26d42360af5b9d0ecd93f7b691fcf659d161fead40dcde9034dffb858ce9144f046f3bca3ce4ca080dbfe5d09fb810cd68e1265dd23c9cd128cb8862290860dcd93260945bedae2bdaf4e7bcc7e08a78abb5c4cb954a90196b8bb8e926bdfe1b9c3794594f22c85a92d438e03c031b979e78156ae86b552fc65173e9721ba999f38aafbc9774d1203cf4f5dbef356629304ad36051d80de19321edc7819491ab8c8d99c0d85e5ec165592d144572f25823e753947bdf6b79578be0823ce57075b27a709a0080bb724d4b34f06e2e0c2937d449e9cdb0061b2120bfa448fc68afb706515254a00b437d022bc9ace13dc7cf7f618928b160ec462a0823b373033a12044eb757e9aaf57ca12e8961f61c7b3463eb7f1afd5e395a11a47340e44df01517780138131952a793f564111c4296add2d96b60a5c2433b6c0ebb07672231bdeeb2bbde5d7214b00062296961529eef51a2b7e67baa66a318cedd86453b41e246efe29363889c3836d11508bbd85a671c409884232213d1c6a7b12ae0c80cdf6f1d0b49645523946f98bbaca2cfc64a0e5f9b94a7331c6f9ca308d1fed98004ab73c883f8c36a18b15fb48795a172abaa79041ff999c65ead9bb47145560dd45dfd9d44a79eb859012389ddaeb1808be74664b3c5dd0edafd77b1c92398361926712ccb666c864c3b04f86fbf65c504cf757e4ae74610e5edaeac36decdffea5e4ea06d8292ceacb7c5b5f2c6b5cd4c543739e18745c5e4b34ed2eb8d99b662fe24964fb278d0b703fb3db700e57b703bdcb40c63dba8409b2d6cfc3274dc9bf412ff6eabd6cd0b8e3b00ca3fa1816ccb51faeaba505e8a96ec35f88a2c3469a9fb396e2ce0143abd5b2036600cba03bc901e541dbe61f9cd6da7976c9e02d61a8c0b7e9bdf98f796abc5a1412ac9310074a31ae0230021f552537be7b27a4bef80fe13d7757ea31068dc25291f8386db07ec0d07f5aeb87780fdf64796c62cb0300197fe85cb686aa52f70de280e545aa74d9f824c59c2c19ef34aad899490410f901de1f457c74403e2ca0a5ee233eb51e3ccc959de4a5a6bac477d2c9bdf7a64f17362832c7ed504e50dcc7aa5ca1e025d11306afcdc60ec2f3fdffda0c97cda83c8f568d71f677e0b7bcd9c4e471651c45767943b78cd8c210fdfb982b507e577ade78e18f976ce8830b66f6c86b7a0465c73e78ed7adf8d7fc518389076a20a6518a18852816806372513b50f351601dfda20fa6331a756cdd3052dda791b7c4b9d9ec47abb8df5513d8bbeea430dce03280abb8b6fd0465081e3a4feb0e148bd4fdd4bcbf57a96f7af237df0c44bdc6b9a4e1a84179a5bbc7b89d0281b181f4e2b6a6d2acc6010d237f013bf0c34aac0c877dfb68c0d0c936feead4febaf0e4909ac47b97a1fcd3ef5b90fe7ade9f5c052ab33673b1f044ef7b5ee820af5b7e2f1904446303023cf1629adbc6cf37d2538427de9c7871b6ce00f8ed163d9fff1127574ab06c9b143f69964ae24f16cf537b332ff9cb82a08c898a2733373c991e0e5ea9f8df8e33b78a762ae01bd0d0e5c1883e8e84a761bb21c3d4d712f59002f696848b5d28773f8651369fce48f32d21f66f662dd4383e84abbdef604accc07944a74551f89c07569fa45e8af20c679c81108ca1c01ba8e9950c8fb070a8bbe3b2d1e63cff109d9012b0fee1dffffad031b46ebcef287e87e13922cdc8112987785e9914f6b7cb9c728cbde19870c64b8e183e764e5eed2fe4362e90b4807794a5d66765fbdf9ca0a786db49ff6324ced8657c69c49d9e7544627e8654ac05f0d89f400d2fae2add0f770afa61d00caa7a21d3d433bfa4119db85e6ebc146e70ffb54b723f5c7134b0333b7ba714e866363130342b88dffe040d09933f739ebb152aa3ec8098c6ae6266d7fe8480af0588e05d4d6ff99f706b12e17a04731855355236d468f578b6d25ee3d199b9a6cfaa3c97c8cd54ab541a636c54fc667d3895926288b85c7980cb7d4f51705ef6901672ee4a3e02ec169ce4e27be681f3f427bcaca8458764c4f7d677e24203273bcc95ed29e8c0010732aa6ed68e56277d4b461439903e45828272485efdc784aa407ae007c1a530758800fdba342b0504da2935ec421257b0876dfcf27cfb19991b6caea33ab4d9346d4615319f2a9d9a025608df30c0beed2b9b807f7fcb30b88df7cd3108d08b348c4ae05744e4ac102354336391aeb2d58a5ae0ebad14ca912329502a2b61bfc05ad2e60ee849ea078efcecd63c4ace0db676930f29be0d2b98a1e056811aef8d40f1476148f658e241ac3bab2dbbfdb7057a15e7d32d8100a2dfcfd62aa952cad55ea6859fd235b21deaa83e051a7dd70d288c8111f79b596a3bc72b88f78e3e8fc450ae17d360fbbc7e0482bcc72d036cfc3a91f74d68004f7d16b56bbd7f7ad67bcf644bdeb5a49fbf474149b7121ac63bf27c689937319ca066273cd9a9426fdf81c515f807a370d36736235344f4ab8fbc2890b1926a425e53e7b888c5d7d8980c71111cd30e58350655a181a564c070aa9eada731c429750cb6f42386a5e0f7ca588e427fcf9a756f828a8cc85670ddf8a9620e2f3e56e3844aab6b951871db1ce9c41c11ee08e5a75babca772739ccebec8a0cc4cb2928ac0386d126342cf65caa56b7eb5ae1077318ee9c79fa354a456fbf46f7c0ed70582f303641cf812b5de94a7c584d92ca0a10b83c5149c4c7d8b1d6f78bcc3cff3824f69c6c6ccd431ed17bdb880f2de08ffb7c68fca9855563e3deb3584040c824f156da95f72fb3eb09087ceccbc71819ebf81f7b3cd3a0d531dc2ec6106442b51744a8a37357873a1f09f6e21cb957753cd43d3a03af4f1ed7d51255e9413d7f2f3b04cded84623fcb353b1561f7b93a93626a0f2ba3520ea02a5130576d8b5d397c9871c29c1a402f186e1e0c4834276caf481b27c4e7a33fed11c5164180c95276b540d3558fccfaf8ba003323b4e32dc3bde289607230269b2d03e294fd6ace25518960dfd169c108ab3f31db6da899a5069f26a53bbfd44718f104fbc8d849cb035536325a2df8cc1c87b7cbbcd56a61b00cef48e0c4051055fd3cb09445062aab76b9de0762614d6c90da9bbde8f38bc4dc3aa136dcc8348461d020491a337fdbbd6239fd42e5fbfdcd40a9ff7411ad4ac40ae76965cc5f5e0a7fcd22f6967a1dae3fd0512b3f7684a3bc4cc2d4331f26ef5022dda66a2b7a425f5fe4d36a3e89826d68d3f47e5012a4c6e6006666d164acc7af6eec360cc61cfbd28bbef13030daee08e9074fc098f6144536184d548a3db7be6d9a616f2c74dee7f20e4eacb6182d8034a40e93dec070cd5fdc933ae9bd22ca44ce0446e49e8c3e70dac67c529ba8fefc9507144ea81aa47654cf9e0495b5f21df7cd24d7849fe2ef83bb3fd3ba431288757d2e5b1cfe389b879bfb2a6643ee86b2e0d193545f9b841fe9d9e9eb8ff011a64ea1ef6095734df219b097f594a84e231eb59f25a2d44d1ff31e584e9a0435cc3f1e3072be79508bfcb70669c2e402fd538b3f9bb8d9fb7ae8f657908fdfc8021ddb5f529645283b8ebba89a65832cf7944a251c1b2de35a75bce170b2911b397b4b0f1046cb675014f9a4398e70acfc3c7065294e368096e1e463c82f3ac5fa81afde1531c45544d47c40887a8b299b4215a1396489efd678af2edd45dca063c885c80265d24e98d1208ddabb17763466d4c395410112497d2e38848380beeb2d0ab29eea9a5a044e98aadea6a5e33ff2f4a61ae15cfe147cebb9a4acd0991ed338593668f26853db4fce6727edfc551ac90852b2ae171f0256be7338f8d868637dc9e16e60a19c84f38d114bd7154376515a39af888fad80ebf18ad105a9194b7eb8b4602add549f9ed1e4decb6bb8e3d992387de44e723b67ca30938873cfcd60370c9413809b0430922a4b3612c41b4a18bd7a3af00f627c26cc776c06e5f046b83ead92eca2d4e52db8f37711879df611960d762ad739f8ccd374c7a323e1e14bfea84a297800708d912a7fcf4a5f0c3e5708143c3b326894cb3e03c36564e645167d8ba7cdd0bf150fd8e8c78ed6df1da1627da6c974c0faba16b5b89af3b84885d92539e0efdac7d1edab058c5fad53310848d48ecdd3ea982ff0062a0d3fc80e19c600a39202edb862a2926bc0323deb8c7838c758fda01a7be79e1893865b59f1a8529d8dbaa250d93e2e58711e660fed1df520323a5fa11457df6256cee680d9318b5e189e81b0cb4e58ec717e9f739a7fa0aa34f3d1760631a78c709a984dd17f3a9418ca35eebcb1d6a1f04a87f0366c368e88e1a376a4aa29bde044620457be7373ba7f9ce00bbcfd46b854973fa1dbe23fc308087f49e6d350238c2fec287618dd1c596212b6d7173a82cc919655c7d7ef0303cd1d7b9659c9d06f6c3833a6dce387e47298dfde2724797f18ab77102cd2475a56b9b4ee042f6162c89f239c36b84e3ae26214ab406743752e21fdf9cbaadaf1f6b6b99099f724269acf802f3863d8f12c71f94d7d5fca650c5fc709c6f02daf10aa502be21b486e02808fd7a90a045e2401d8b9f62b71b42539bc97139574cf3c164a70a19bcb02e57da75ac39d56a9927b48e19b7f861f5fa0a6a8611fb38476a9fbf1e2a2adeba3ca98abe7d5234ac7200b001e1c12e6c25d699b973e8b30ce5508079df9c9b72299a9bd029fff02108e6c80d25dd6c48118ac7c25730a46fd70f65fa4f8e2577c8f2900e8057477324e1bdcdbe84b39e05fa56f829d45b2fd078131ca686b0b6f86b7f0fc9dab30095033290d87b2dc6bbe3735cef503289e350382c28c038f207b76ce147d235069902c4532bd5c033fdb3ae8e17bb95bfd019ed1f1c70b4efe2fb415c1f3516d8f4d6525557aa45d3033b7bc3374480c791529576cf2b4a1f5170d24d82a922a5b1dbf233363c5eebba2e1b4072929d74ed390d6c9e78fe6c6ca8622e5f4d7c26f74d17927d6ccab2321381350de7e72efdf9eaa2026001cc777122849ff3ac36e7fbb4581ba4ba19857c30d99c6770554ff1cf32bced9828109c9e2e9dc7cd1fee1716bb0cb6dc95f3f8cdadfa0a9903964c22628c0b0811f7717ad99d44366430328ea7ee085c393e68ac77bb8e56057c69083aab67b9806ae37596ec53a8a779a962b18689c5071351b277b5c82eb870412f95358531cc89ea32800b5d89cd277af88c27f83b95bdb31ded9066244dc4cfd8a7007fae49d74b9a0f01637e50d6018afa2170000e3e8f7688da48d113be35b7b7fa64d1660914cf612ffbb9dc6d48fc0f544948c68a18e0b9af771bc1bfec1ca00d7c17fadc62b0b8d3c4c81e7e28294b8414483369827c31948d5acd2ad5477bc9d320db7e31ce9d5ec71badd747900addc9e610b68478faea93f7ed9dc57adc5608a9adfc4c4423f6cab6b89f4dd48d9490cacf235bf7d0d8d4d60d51bc65ef35ea0a8863e28b909a62ecc57e7b2cf0734c4e592ad82055d52dd68073c5e2374366601a4894362751a02fa72a6baca743ca1604a415be9f38770e0cfb04e577d03ad2b102fc8bb65d315272cde1197fefacddb93048c723d4d1daf5fc9417f4fb713c302bf89677de10f9523f84e46b97ada6ccade500b1aa3b993c6f475486f7d725ee67e1e762e126a36e5ee3cde8114ce7151216a8fe7699aba13893c1b8918b2508af2af53f2e6bd87</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">在此输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 灵感笔记 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 14 ROC 曲线的基础知识</title>
      <link href="/2023/e08309be.html"/>
      <url>/2023/e08309be.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>受试者工作特征（ROC）曲线是模型区分正类和负类的能力在不同阈值下的图形表示。在深入研究ROC曲线之前，有一些基本概念需要了解：</p><ol><li><strong>真正例（TP）：</strong> 模型正确预测正实例。</li><li><strong>假正例（FP）：</strong> 模型错误地预测正实例（Type I 错误）。</li><li><strong>真负例（TN）：</strong> 模型正确预测负实例。</li><li><strong>假负例（FN）：</strong> 模型错误地预测负实例（Type II 错误）。</li><li><strong>灵敏度（真正例率或召回率）：</strong> 它是正确预测的正实例与总实际正实例的比率。它量化了模型捕获正实例的能力。灵敏度 = TP / (TP + FN)。</li><li><strong>特异性（真负例率）：</strong> 它是正确预测的负实例与总实际负实例的比率。它量化了模型捕获负实例的能力。特异性 = TN / (TN + FP)。</li><li><strong>精确度（正预测值）：</strong> 它是正确预测的正实例与总预测正实例的比率。精确度 = TP / (TP + FP)。</li><li><strong>假正例率（FPR）：</strong> 它是错误地预测的正实例与总实际负实例的比率。FPR = FP / (FP + TN)。</li></ol><p>这些概念对于理解ROC曲线非常重要，ROC曲线可视化了在不同分类阈值下灵敏度和特异性之间的权衡。</p><h1 id="逻辑回归阈值-Logistic-Regression-Threshold"><a href="#逻辑回归阈值-Logistic-Regression-Threshold" class="headerlink" title="逻辑回归阈值 (Logistic Regression Threshold)"></a>逻辑回归阈值 (Logistic Regression Threshold)</h1><p>如果你回忆一下<a href="/2023/a865dfe2.html" title="Sololearn 自学机器学习 11 精确度和召回率">第 11 话</a>，我们讨论了精确度 (Precision) 和召回率 (Recall) 之间的权衡。对于 Logistic Regression 模型，我们有一种简单的方法在强调精确度和强调召回率之间进行切换。Logistic Regression 模型不仅返回一个预测值，而且返回一个介于 0 到 1 之间的概率值。通常，我们说如果这个值 &gt;= 0.5，我们预测乘客幸存，如果这个值 &lt; 0.5，乘客就没有幸存。然而，我们可以选择任何介于 0 到 1 之间的阈值。</p><ul><li>如果我们将阈值设得更高，我们将有更少的正预测，但我们的正预测更有可能是正确的。这意味着精确度会更高，而召回率会更低。</li><li>如果我们将阈值设得更低，我们将有更多的正预测，因此更有可能捕捉到所有的正例。这意味着召回率会更高，而精确度会更低。</li></ul><div class="note info flat"><p>每个阈值的选择都是一个不同的模型。ROC (Receiver operating characteristic, 受试者工作特征) 曲线 (Curve) 是一个显示所有可能模型及其性能的图形。</p></div><h2 id="ROC-的历史"><a href="#ROC-的历史" class="headerlink" title="ROC 的历史"></a>ROC 的历史</h2><p>它首次在二战期间被用于分析雷达信号，以更好地检测敌机与信号噪声（如大群的鹅）之间的区别。特别是，他们使用了我们在机器学习中将要学习和使用的同一种数学，用于评估雷达接收器操作员做出重要区分的能力，比如刚刚在雷达上观察到的是敌机目标、友方船只还是噪声。因此，这就是接收器工作特征（ROC, receiver operating characteristic）的名字的由来。这个非常数学 (very math) 的理论随后被归类为“信号检测理论 (signal detection theory) ”。你可能已经听说过医学检测中的“假阳性率 (false positive rate) ”这个术语。</p><h1 id="灵敏度-Sensitivity-和-特异性-Specificity"><a href="#灵敏度-Sensitivity-和-特异性-Specificity" class="headerlink" title="灵敏度 (Sensitivity) 和 特异性 (Specificity)"></a>灵敏度 (Sensitivity) 和 特异性 (Specificity)</h1><p>ROC 曲线是<strong>灵敏度</strong>与<strong>特异性</strong>之间的图形。这些值展示了与精确度和召回率相同的权衡。</p><p>让我们回顾混淆矩阵，因为我们将使用它来定义灵敏度和特异性。</p><p><img src="/uploads/sololearn/machine-learning/confusion%20tfpn.webp"/></p><p>灵敏度 (Sensitivity) 是召回率的另一种术语，即真正例率 (True positive rate) 。回忆一下，它的计算方法如下：</p><script type="math/tex; mode=display">\begin{aligned}  \text{灵敏度} = \text{召回率} &= \frac{\text{正确预测的正类别数量}}{\text{正类别的数量}} \\               &= \frac{\text{TP}}{\text{TP + FN}}\end{aligned}</script><p>特异性 (Specificity) 是真负例率。它的计算方法如下。</p><script type="math/tex; mode=display">\begin{aligned}  \text{特异性} = \text{召回率} &= \frac{\text{正确预测的负类别数量}}{\text{负类别的数量}} \\               &= \frac{\text{TN}}{\text{TN + FP}}\end{aligned}</script><p>我们在 Titanic 数据集上进行了训练集和测试集的拆分，并得到了以下混淆矩阵。在我们的测试集中，有 96 个正例和 126 个负例。</p><p><img src="/uploads/sololearn/machine-learning/titanic%20test%20set%20confusion%20matrix.webp"/></p><p>让我们计算灵敏度和特异性。</p><script type="math/tex; mode=display">\begin{aligned}  \text{灵敏度} & = \frac{61}{96} \approx 0.6354 \\  \text{特异性} & = \frac{105}{126} \approx 0.8333 \\\end{aligned}</script><p>目标是最大化这两个值，尽管通常使一个值变大会使另一个值变小。更注重敏感性还是特异性，要根据具体情况而定。</p><div class="note info flat"><p>虽然我们通常查看精确度和召回率的值，但绘制图表的标准是使用敏感性和特异性。虽然也可以构建精确度 - 召回率曲线，但这并不常见。</p></div><h2 id="灵敏度和特异性的练习"><a href="#灵敏度和特异性的练习" class="headerlink" title="灵敏度和特异性的练习"></a>灵敏度和特异性的练习</h2><p>从以下混淆矩阵中，灵敏度和特异性分别是多少？</p><div class="table-container"><table><thead><tr><th>预测 \ 实际</th><th>实际正例</th><th>实际负例</th></tr></thead><tbody><tr><td>预测正例</td><td>30</td><td>20</td></tr><tr><td>预测负例</td><td>10</td><td>40</td></tr></tbody></table></div><details class="toggle" ><summary class="toggle-button" style="">查看答案</summary><div class="toggle-content"><p>计算：</p><script type="math/tex; mode=display">\begin{aligned}  灵敏度（召回率）&= \frac{\text{正确预测的正例}}{\text{实际正例数}} \\                &= \frac{30}{30 + 10} \\                &= 0.75 \\\\  特异性 &= \frac{\text{正确预测的负例}}{\text{实际负例数}} \\        &= \frac{40}{40 + 20} \\        &= 0.67\end{aligned}</script><p>灵敏度（召回率）= 正确预测的正例 / 实际正例数 = 30 / (30 + 10) = 0.75</p><p>特异性 = 正确预测的负例 / 实际负例数 = 40 / (40 + 20) = 0.67</p><p>因此，灵敏度为 0.75，特异性为 0.67。</p></div></details><h1 id="Sklearn-中的灵敏度和特异性"><a href="#Sklearn-中的灵敏度和特异性" class="headerlink" title="Sklearn 中的灵敏度和特异性"></a>Sklearn 中的灵敏度和特异性</h1><p>在Scikit-learn中，虽然没有专门定义灵敏度（Sensitivity）和特异性（Specificity）的函数，但我们可以自己定义。由于灵敏度与召回率相同，所以定义起来很容易。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score</span><br><span class="line">sensitivity_score = recall_score</span><br><span class="line"><span class="built_in">print</span>(sensitivity_score(y_test, y_pred)) </span><br><span class="line"><span class="comment"># 0.6829268292682927</span></span><br></pre></td></tr></table></figure><p>现在，要定义特异性，如果我们意识到它也是负类别的召回率，我们可以从sklearn的<code>precision_recall_fscore_support</code>函数中获取该值。</p><p>让我们看看<code>precision_recall_fscore_support</code>的输出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_fscore_support</span><br><span class="line"><span class="built_in">print</span>(precision_recall_fscore_support(y, y_pred))</span><br></pre></td></tr></table></figure><p>输出的第二个数组是召回率，因此我们可以忽略其他三个数组。这个数组有两个值。第一个是负类别的召回率，第二个是正类别的召回率。第二个值是标准的召回率或灵敏度值，你可以看到该值与上面得到的值相匹配。第一个值是特异性。因此，让我们编写一个函数只获取该值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">specificity_score</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    p, r, f, s = precision_recall_fscore_support(y_true, y_pred)</span><br><span class="line">    <span class="keyword">return</span> r[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(specificity_score(y_test, y_pred)) </span><br><span class="line"><span class="comment"># 0.9214285714285714</span></span><br></pre></td></tr></table></figure><p>请注意，在代码示例中，我们在训练测试拆分中使用了一个随机种子，以便每次运行代码时都能获得相同的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> recall_score, precision_recall_fscore_support</span><br><span class="line"></span><br><span class="line">sensitivity_score = recall_score</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">specificity_score</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    p, r, f, s = precision_recall_fscore_support(y_true, y_pred)</span><br><span class="line">    <span class="keyword">return</span> r[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sensitivity:&quot;</span>, sensitivity_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;specificity:&quot;</span>, specificity_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><h2 id="Sklearn-中的灵敏度和特异性的练习"><a href="#Sklearn-中的灵敏度和特异性的练习" class="headerlink" title="Sklearn 中的灵敏度和特异性的练习"></a>Sklearn 中的灵敏度和特异性的练习</h2><p>以下代码会得到什么值？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p, r, f, s = precision_recall_fscore_support(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(r[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><details class="toggle" ><summary class="toggle-button" style="">查看答案</summary><div class="toggle-content"><p>这段代码将打印正类别的召回率（recall）。</p><p><code>r[0]</code> 捕获的是特异性，<code>r[1]</code> 捕获的是灵敏度（标准召回率），但对于灵敏度，无需使用这个数组，因为Python中已经有了 <code>recall_score()</code> 方法用于计算正类别的值。</p></div></details><h1 id="SkLearn-中调整逻辑回归阈值"><a href="#SkLearn-中调整逻辑回归阈值" class="headerlink" title="SkLearn 中调整逻辑回归阈值"></a>SkLearn 中调整逻辑回归阈值</h1><p>在使用 scikit-learn 的 predict 方法时，会得到预测的 0 和 1 值。然而，在幕后，Logistic Regression 模型对于每个数据点都获得一个介于 0 到 1 之间的概率值，然后四舍五入为 0 或 1。如果我们想要选择除 0.5 之外的不同阈值，我们将需要这些概率值。我们可以使用 predict_proba 函数来获取它们。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.predict_proba(X_test)</span><br></pre></td></tr></table></figure><p>结果是一个包含每个数据点的 2 个值的 numpy 数组（例如，[0.78, 0.22]）。你会注意到这两个值的总和为 1。第一个值是数据点属于 0 类（未幸存）的概率，第二个是数据点属于 1 类（幸存）的概率。我们只需要该结果的第二列，可以使用以下 numpy 语法提取。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.predict_proba(X_test)[:, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>现在，我们只需将这些概率值与我们的阈值进行比较。假设我们想要一个阈值为 0.75。我们将上面的数组与 0.75 进行比较。这将给我们一个包含 True/False 值的数组，这将是我们的预测目标值的数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred = model.predict_proba(X_test)[:, <span class="number">1</span>] &gt; <span class="number">0.75</span></span><br></pre></td></tr></table></figure><p>0.75 的阈值意味着我们需要更有信心才能进行正面预测。这导致较少的正面预测和更多的负面预测。</p><p>现在，我们可以使用之前的任何 scikit-learn 指标，使用 y_test 作为我们的真实值，y_pred 作为我们的预测值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;precision:&quot;</span>, precision_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recall:&quot;</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><p>运行以下代码以查看结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred = model.predict_proba(X_test)[:, <span class="number">1</span>] &gt; <span class="number">0.75</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;precision:&quot;</span>, precision_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recall:&quot;</span>, recall_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><div class="note info flat"><p>将阈值设置为 0.5 会得到原始的 Logistic Regression 模型。任何其他阈值都会产生一种替代模型。</p></div><h2 id="对于-predict-proba-的补充"><a href="#对于-predict-proba-的补充" class="headerlink" title="对于 predict_proba 的补充"></a>对于 <code>predict_proba</code> 的补充</h2><p>使用 <code>predict_proba</code> 方法既给出乘客死亡的概率，又给出乘客幸存的概率，可能会显得有些奇怪。毕竟，我们只需要其中一列，而通过从 1 中减去第一列，我们就可以得到另一列。在我们的情况下，我们只有两个类别（幸存和未幸存），但对于有两个以上目标类别的问题，获取所有可能类别的概率是非常有用的。</p><h2 id="SkLearn-中调整逻辑回归阈值的练习"><a href="#SkLearn-中调整逻辑回归阈值的练习" class="headerlink" title="SkLearn 中调整逻辑回归阈值的练习"></a>SkLearn 中调整逻辑回归阈值的练习</h2><p>以下哪个语句给出了预测概率的数组（每个值将是数据点属于正类别的概率）？</p><ol><li><code>model.predict_proba(X_test)[:, 1]</code></li><li><code>model.predict_proba(X_test)[0]</code></li><li><code>model.predict_proba(X_test)[:, 0]</code></li><li><code>model.predict_proba(X_test)[1]</code></li><li><code>model.predict_proba(X_test)</code></li></ol><details class="toggle" ><summary class="toggle-button" style="">查看答案</summary><div class="toggle-content"><p>答案是：1. <code>model.predict_proba(X_test)[:, 1]</code></p></div></details>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 13 训练与测试</title>
      <link href="/2023/d24f091e.html"/>
      <url>/2023/d24f091e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a>过拟合（Overfitting）</h1><blockquote><p>got to see the answers to the quiz before we gave it the quiz — The best analogy used to explain overfitting.</p><p>让学生在我们出考试题之前已经看到了考试答案。这是解释过拟合的最佳类比。</p></blockquote><p>到目前为止，我们已经用所有的数据构建了一个模型，然后看了一下它在相同数据上的表现如何。这实际上是在人为地夸大我们的数字，因为我们的模型在实际上在我们给它测验之前就已经看到了测验的答案。这可能导致我们所说的过拟合。<strong>过拟合是指我们在模型已经看过的数据上表现良好，但在新数据上表现不佳。(Overfitting is when we perform well on the data the model has already seen, but we don’t perform well on new data.)</strong></p><p>我们可以从视觉上看出一个过拟合的模型如下。这条线试图过于贴近每个数据点的正确一侧，但却忽略了数据的本质。</p><p><img src="/uploads/sololearn/machine-learning/training%20and%20testing%20overfitting.jpg"/></p><p>在图表中，您可以看到我们在将黄点放在顶部和紫点放在底部方面做得相当好，但它并没有捕捉到正在发生的事情。一个单独的异常点可能会严重影响线的位置。虽然模型在已经看过的数据上得分很高，但在新数据上表现良好的可能性较小。</p><div class="note info flat"><p>我们的数据集中拥有的特征越多，我们就越容易出现过拟合的情况。</p></div><p>另一种看待过拟合模型的方式就像是一个学生在课堂上记住老师教的例子。如果问这样的学生任何一个例子中的问题，他会表现得非常好。但如果问学生一个完全不同的问题，不是例子中的任何一个，他就会表现得很差。这样的学生并没有在学习，他并不真正理解他所学的内容…他只是在死记硬背。大多数数据包含的观察结果都是离群值（outliner）和噪声（noise）。它们可能是作为数据特异性（idiosyncrasies）的一部分而自然发生（occur naturally），也可能是由于记录错误导致的。过拟合模型是一种过于受噪声影响的模型，因此，它不是在学习纯粹的隐藏模式（忽略噪声），而是开始学习噪声。它过于适应训练集，因此在测试集上表现不佳。在机器学习模型中，过拟合的模型实际上并没有从数据中学到东西，而只是死记硬背。请记住，它被称为机器<strong>学习</strong>，而不是机器<strong>记忆</strong>。😎</p><h1 id="训练集（Training-set）和-测试集（Testing-set）"><a href="#训练集（Training-set）和-测试集（Testing-set）" class="headerlink" title="训练集（Training set）和 测试集（Testing set）"></a>训练集（Training set）和 测试集（Testing set）</h1><div class="note primary flat"><p>我们在 <a href="/2023/75989641.html" title="Sololearn 自学机器学习 3 Pandas 数据读取与处理">课程一开始</a> ，就分别提供了 train.csv训练集 和 test.csv 测试集，并且从中计算出对应的模型评估分数。那么从现在开始，您需要重新下载 titanic.csv <a class="btn-beautify " href="/uploads/@files/datasets/titanic/titanic.csv" title="点此下载"><i class="fas fa-download"></i><span>点此下载</span></a>，由 sololearn 提供的数据集来进行操作，确保自己对结果没有误差。很抱歉为您带来了不便。</p></div><p>为了对模型进行公正评估，我们想知道我们的模型在尚未见过的数据上的表现如何。</p><p>在实际操作中，我们的模型将在我们不知道答案的数据上进行预测，因此我们想评估模型在新数据上的表现，而不仅仅是在已经见过的数据上。为了模拟在新的未见过的数据上进行预测，我们可以将数据集分为训练集和测试集。训练集用于构建模型，而测试集用于评估模型。我们在构建模型之前分割数据，因此模型对测试集一无所知，我们将对其进行公正评估。</p><p>如果我们的数据集中有 200 个数据点，将其分为训练集和测试集可能如下所示。</p><p><img src="/uploads/sololearn/machine-learning/training%20and%20testing%20split%20datasets.png"/></p><div class="note info flat"><p>标准的划分是将我们的数据的 70-80% 放入训练集，而将 20-30% 放入测试集。在训练集中使用较少的数据意味着我们的模型将没有太多数据可供学习，因此我们希望尽可能多地提供数据，同时仍然留有足够的数据进行评估。</p></div><h1 id="在-SkLearn-中的训练和测试"><a href="#在-SkLearn-中的训练和测试" class="headerlink" title="在 SkLearn 中的训练和测试"></a>在 SkLearn 中的训练和测试</h1><p>Scikit-learn中内置了一个函数，用于将数据分为训练集和测试集。</p><p>假设我们有一个包含特征的二维numpy数组 X 和一个包含目标的一维 numpy 数组 y，我们可以使用 <code>train_test_split</code> 函数。它会将每个数据点随机放入训练集或测试集。默认情况下，训练集占数据的 75%，测试集占剩余的 25%。让我们来实现这个功能</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离测试集和训练集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;whole dataset:&quot;</span>, X.shape, y.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;training set:&quot;</span>, X_train.shape, y_train.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test set:&quot;</span>, X_test.shape, y_test.shape)</span><br></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whole dataset: (887, 6) (887,)</span><br><span class="line">training set: (665, 6) (665,)</span><br><span class="line">test set: (222, 6) (222,)</span><br></pre></td></tr></table></figure><p>我们可以看到，在我们的数据集中有 887 个数据点，其中 665 个在训练集中，222 个在测试集中。数据集中的每个数据点都仅使用一次，要么在训练集中，要么在测试集中。请注意，我们的数据集中有 6 个特征，因此在训练集和测试集中仍然有 6 个特征。</p><div class="note info flat"><p>我们可以通过使用 <code>train_size</code> 参数来更改训练集的大小。例如，<code>train_test_split(X, y, train_size=0.6)</code> 将使60%的数据位于训练集中，40%位于测试集中。</p></div><h2 id="在-SkLearn-中的训练和测试提问"><a href="#在-SkLearn-中的训练和测试提问" class="headerlink" title="在 SkLearn 中的训练和测试提问"></a>在 SkLearn 中的训练和测试提问</h2><p>我们有一个包含100个数据点和4个特征的二维numpy数组X，以及一个包含100个目标值的一维数组y。这段代码的输出是什么？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape, y_train.shape)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>输出是训练集的特征矩阵（X_train）和目标数组（y_train）的形状。</p></div><details class="toggle" ><summary class="toggle-button" style="">查看答案和解释</summary><div class="toggle-content"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(75, 4) (75, )</span><br></pre></td></tr></table></figure></div></details><h1 id="使用训练集构建-Scikit-learn-模型"><a href="#使用训练集构建-Scikit-learn-模型" class="headerlink" title="使用训练集构建 Scikit-learn 模型"></a>使用训练集构建 Scikit-learn 模型</h1><p>现在我们知道如何将数据分为训练集和测试集，我们需要修改构建和评估模型的方式。所有的模型构建都是使用训练集完成的，而所有的评估都是在测试集上完成的。</p><p>在上个模块中，我们构建了一个模型并在同一数据集上进行了评估。现在我们使用训练集构建模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p>然后我们使用测试集评估模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.score(X_test, y_test))</span><br></pre></td></tr></table></figure><p>事实上，我们在之前部分计算的所有指标都应该在测试集上计算。完整代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://sololearn.com/uploads/files/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># building the model</span></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># evaluating the model</span></span><br><span class="line"><span class="comment"># print(&quot;accuracy:&quot;, model.score(X_test, y_test))</span></span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuracy:&quot;</span>, accuracy_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;precision:&quot;</span>, precision_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recall:&quot;</span>, recall_score(y_test, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;f1 score:&quot;</span>, f1_score(y_test, y_pred))</span><br></pre></td></tr></table></figure><p>我们的准确率（Accuracy）、精确度（Precision）、召回率（Recall）和 F1 分数（F1 Score）的值实际上与在使用整个数据集时的值非常相似。这表明我们的模型没有过拟合！</p><div class="note info flat"><p>如果您运行代码，您会注意到每次都会得到不同的分数。这是因为训练测试拆分 <code>train_test_split</code> 是随机进行的，取决于哪些点落入训练集和测试集，分数将不同。当我们学习交叉验证时，我们将看到更准确的衡量这些分数的方法。</p></div><h2 id="使用训练集构建-Scikit-learn-模型的练习"><a href="#使用训练集构建-Scikit-learn-模型的练习" class="headerlink" title="使用训练集构建 Scikit-learn 模型的练习"></a>使用训练集构建 Scikit-learn 模型的练习</h2><p>假设我们有一个包含特征的二维numpy数组X和一个包含目标值的一维numpy数组y。</p><p>我们从以下开始：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line">model = LogisticRegression()</span><br></pre></td></tr></table></figure><p>以下哪种是在scikit-learn中正确使用训练集和测试集的方式？</p><ol><li><code>model.fit(X_train, y_train) print(model.score(X_train, y_train))</code></li><li><code>model.fit(X_test, y_test) print(model.score(X_train, y_train))</code></li><li><code>model.fit(X, y) print(model.score(X_test, y_test))</code></li><li><code>model.fit(X_train, y_test) print(model.score(X_train, y_test))</code></li><li><code>model.fit(X_train, y_train) print(model.score(X_test, y_test))</code></li></ol><details class="toggle" ><summary class="toggle-button" style="">查看答案</summary><div class="toggle-content"><p>答案是 5 <code>model.fit(X_train, y_train) print(model.score(X_test, y_test))</code>，我们用 train 集合用于训练模型，而用 test 集合用于评估模型。</p></div></details><h1 id="使用随机种子"><a href="#使用随机种子" class="headerlink" title="使用随机种子"></a>使用随机种子</h1><p>正如我们在前一部分中注意到的，当我们随机将数据分割为训练集和测试集时，每次运行代码时，每个集合中的数据点都会不同。这是随机性的结果，我们需要它是随机的才能有效，但这有时会使测试代码变得困难。</p><p>例如，每次运行以下代码时，我们都会得到不同的结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train&#x27;</span>, X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_test&#x27;</span>, X_test)</span><br></pre></td></tr></table></figure><p>为了每次都获得相同的拆分，我们可以使用 <code>random_state</code> 属性。我们选择一个任意的数字，并且每次运行代码时，我们将获得相同的拆分。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>]]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">27</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train&#x27;</span>, X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_test&#x27;</span>, X_test)</span><br></pre></td></tr></table></figure><div class="note info flat"><p>The random state is also called a seed.</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【作业向】某电商网站用户交易记录分析</title>
      <link href="/2023/b38e8e7c.html"/>
      <url>/2023/b38e8e7c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前几天老师发下来一个任务，需要模仿 《CDNow 网站用户消费行为分析》，自己选择一个同类型的数据集进行分析。我不是数据分析专业的，只能照葫芦画瓢去对类似的数据进行分析。本文就是对整个项目操作进行一次梳理，并记录过程中因环境版本更新等原因所采的坑。</p><p>CDNow 数据集可以<a href="/uploads/@files/ipynbs/CDNOW.txt">点此下载</a>，完整的 CDNow 数据分析 Jupyter-notebook <a href="/uploads/@files/ipynbs/CDNow网站用户消费行为分析.ipynb">可以在此</a>进行下载。</p><p>一般上，电商数据集是电商公司的专有财产，因为它可以用于作为用户行为消费、产品销量等重要指标的分析数据。我通过 <a href="https://www.kaggle.com/datasets">Kaggle</a> 网站找到了 <a href="https://www.kaggle.com/datasets/carrie1/ecommerce-data">E-Commerce Data</a> 数据集。以下是该数据集的介绍：</p><div class="note info flat"><p>通常，电商数据集是专有的，因此在公开可用的数据中很难找到。然而，<a href="http://archive.ics.uci.edu/ml/index.php">UCI机器学习库</a>提供了这个包含2010年和2011年实际交易的数据集。该数据集在其网站上维护，可以通过标题 “Online Retail” 找到。</p></div><p>我们在数据集的介绍资料中了解到：这是一个跨国数据集，其中包含一家总部位于英国的注册非实体店在线零售公司在 2010 年 1 月 12 日至 2011 年 9 月 12 日之间发生的所有交易。该公司主要销售独特的全场合礼品。公司的许多客户都是批发商。</p><h1 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h1><p>通过项目要求以及我们所找到的数据集，可以进行以下分析：</p><p>用户消费特征</p><ol><li>用户整体消费分析：计算总收入、平均购买值等指标。</li><li>用户个人消费分析：观察每位用户的购买次数、总收入等。</li><li>用户消费周期分析：<ol><li>用户购买周期：计算用户购买相邻两次之间的时间间隔。</li><li>用户生命周期：从第一次购买到最后一次购买的时间跨度。</li></ol></li></ol><p>用户分层</p><ol><li>用户价值度分析——RMF 模型：根据最近购买时间、购买频率、总收入等指标进行分层。</li><li>用户活跃层分析：<ol><li>新用户：首次购买时间在分析期内。</li><li>活跃用户：购买频率高的用户。</li><li>不活跃用户：购买频率低的用户。</li><li>回流用户：曾经不活跃，然后再次购买的用户。</li></ol></li></ol><p>如何提高用户质量</p><ol><li>多少用户仅消费了一次？统计购买次数为1的用户数量。</li><li>复购率：计算有多少用户购买了多次。</li><li>回购率：计算有多少用户在分析期内再次购买。</li><li>留存率：观察用户在不同时间段的留存情况。</li><li>客户贡献率：计算每位用户对总收入的贡献比例。</li></ol><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>我使用的开发环境如下：</p><ul><li>Python 3.9.13</li><li>numpy==1.26.2</li><li>pandas==2.1.4</li><li>matplotlib==3.8.2</li><li>jupyter_core==5.5.0</li></ul><h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><p>由于下载好的数据集就是 <code>.csv</code> 文件，我们直接用 pandas 的 <code>read_csv()</code> 函数将路径传入打开即可。打开后出现了第一个报错：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xa3 in position 79780: invalid start byte</span><br></pre></td></tr></table></figure><p>这里，我使用 PyCharm 打开 csv 文件，发现文件是使用 <code>ISO-8859-1</code> 的编码格式进行保存的，所以打开时，我们也需要设定对应的 <code>encoding</code>，然后我也发现 <code>CustomerID</code> 和 <code>InvoiceID</code> 是由一串数值组成的，但是对于统计中，他们得属于是字符串，否则会出现奇怪的统计现象，所以我将他们使用 <code>dtype</code> 参数修改为字符串。具体 <code>read_csv</code> 函数调用如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;Data/E-Commerce Data/data.csv&quot;</span>, encoding=<span class="string">&quot;ISO-8859-1&quot;</span>,</span><br><span class="line">                 dtype=&#123;<span class="string">&#x27;CustomerID&#x27;</span>: <span class="built_in">str</span>, <span class="string">&#x27;InvoiceID&#x27;</span>: <span class="built_in">str</span>&#125;)</span><br></pre></td></tr></table></figure><p>对于数据的预处理，我首先统计了数据的空值，主要有空值的列是 CustomerID，空值占比近 25%，这些空值会影响后续的统计，所以我们将其舍弃掉，使用 <code>dropna</code> 函数将 CustomerID 为空的列剔除。我们也需要将重复的数据行进行剔除，用 <code>drop_duplicates</code> 函数做到这点。然后再将原数据不需要的列进行删减，留下：订单数、订单额、购买日期，用户 ID 这四个字段来分析。由于此数据集的所有交易是基于订单的（Invoice）所以我们需要合并所有相同 CustomerID 和 InvoiceID 的订单成一条记录。并提取出该订单发生的月份。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换日期格式</span></span><br><span class="line">df[<span class="string">&#x27;InvoiceDate&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;InvoiceDate&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供关于列类型和空值数量的一些信息</span></span><br><span class="line">tab_info = pd.DataFrame(df.dtypes).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;列类型&#x27;</span>&#125;)</span><br><span class="line">tab_info = pd.concat([tab_info, pd.DataFrame(df.isnull().<span class="built_in">sum</span>()).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;空值数量 (个)&#x27;</span>&#125;)])</span><br><span class="line">tab_info = pd.concat(</span><br><span class="line">    [tab_info, pd.DataFrame(df.isnull().<span class="built_in">sum</span>() / df.shape[<span class="number">0</span>] * <span class="number">100</span>).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;空值百分比 (%)&#x27;</span>&#125;)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Dataframe dimensions: &#x27;</span>, df.shape)</span><br><span class="line"></span><br><span class="line">display(tab_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 剔除空值数据项</span></span><br><span class="line">df.dropna(axis=<span class="number">0</span>, subset=[<span class="string">&#x27;CustomerID&#x27;</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供关于列类型和空值数量的一些信息</span></span><br><span class="line">tab_info = pd.DataFrame(df.dtypes).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;列类型&#x27;</span>&#125;)</span><br><span class="line">tab_info = pd.concat([tab_info, pd.DataFrame(df.isnull().<span class="built_in">sum</span>()).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;空值数量 (个)&#x27;</span>&#125;)])</span><br><span class="line">tab_info = pd.concat(</span><br><span class="line">    [tab_info, pd.DataFrame(df.isnull().<span class="built_in">sum</span>() / df.shape[<span class="number">0</span>] * <span class="number">100</span>).T.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;空值百分比 (%)&#x27;</span>&#125;)])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Dataframe dimensions: &#x27;</span>, df.shape)</span><br><span class="line"></span><br><span class="line">display(tab_info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复数据项</span></span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换 Quantity 列为数值型</span></span><br><span class="line">df[<span class="string">&#x27;Quantity&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;Quantity&#x27;</span>], errors=<span class="string">&#x27;coerce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 TotalPrice 列</span></span><br><span class="line">df[<span class="string">&#x27;TotalPrice&#x27;</span>] = df[<span class="string">&#x27;Quantity&#x27;</span>] * df[<span class="string">&#x27;UnitPrice&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ItemQuantities 列</span></span><br><span class="line">df[<span class="string">&#x27;ItemQuantities&#x27;</span>] = df[<span class="string">&#x27;Quantity&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Cancelled 列</span></span><br><span class="line">df[<span class="string">&#x27;Cancelled&#x27;</span>] = df[<span class="string">&#x27;InvoiceNo&#x27;</span>].<span class="built_in">str</span>.startswith(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择所需的列</span></span><br><span class="line">df_final = df[[<span class="string">&#x27;CustomerID&#x27;</span>, <span class="string">&#x27;InvoiceDate&#x27;</span>, <span class="string">&#x27;ItemQuantities&#x27;</span>, <span class="string">&#x27;TotalPrice&#x27;</span>, <span class="string">&#x27;Cancelled&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并相同 CustomerID 和 InvoiceDate 的订单</span></span><br><span class="line">df_final = df_final.groupby([<span class="string">&#x27;CustomerID&#x27;</span>, <span class="string">&#x27;InvoiceDate&#x27;</span>]).agg(&#123;</span><br><span class="line">    <span class="string">&#x27;ItemQuantities&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;TotalPrice&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cancelled&#x27;</span>: <span class="string">&#x27;any&#x27;</span></span><br><span class="line">&#125;).reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取订单月份</span></span><br><span class="line">df_final[<span class="string">&#x27;InvoiceMonth&#x27;</span>] = df_final[<span class="string">&#x27;InvoiceDate&#x27;</span>].values.astype(<span class="string">&#x27;datetime64[M]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">display(df_final)</span><br></pre></td></tr></table></figure><p>我们发现，有些订单其实是被取消的，一切从简，我使用一种逻辑对这些数据进行剔除：如果一张 Cancelled = True 的订单，其 ItemQuantities 和 TotalPrice &gt;= （之前同一 CustomerID 所购买的其中一个订单），则扣除掉该订单的 ItemQuantities 和 TotalPrice，并销毁该 Cancelled 订单。如果找不到，则直接消除 Cancelled 订单</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉被删除的订单</span></span><br><span class="line">df_final = df_final[df_final[<span class="string">&#x27;Cancelled&#x27;</span>] == <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><h1 id="对于-Matplotlib-绘制图片中文显示问题"><a href="#对于-Matplotlib-绘制图片中文显示问题" class="headerlink" title="对于 Matplotlib 绘制图片中文显示问题"></a>对于 Matplotlib 绘制图片中文显示问题</h1><p>英文 Matplotlib 并没有适配中文字符显示，所以我们需要修改字体，我们可以通过 pylab 包中的属性进行修改：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置显示中文字体</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line"><span class="comment"># 设置正常显示符号</span></span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在进行数据处理的过程中，由于该电商公司主要经营批发价格，出货量大，买家群体庞大，所以所呈现出来的数据并没有那么容易进行分析。我们需要对数据中的一些值进行 <code>query</code> 筛选掉个别数据，才能对其进行分析。</p><h1 id="衍生分析"><a href="#衍生分析" class="headerlink" title="衍生分析"></a>衍生分析</h1><p>通过对原数据集进行统计学分析，我还可以获取以下信息：</p><ul><li>描述性统计信息： 了解每个变量的基本统计指标，如平均值、中位数、最小值、最大值等，以便了解数据的整体特征。</li><li>年龄分布： 分析年龄变量，了解顾客年龄的分布情况，例如平均年龄、最年轻和最年长的顾客。</li><li>性别比例： 统计性别变量，计算男女顾客的比例，以便了解你的目标用户群体的性别分布。</li><li>收入分析： 对 <code>Revenue_Total</code> 进行分析，包括平均收入、总收入等，以了解顾客的整体购买能力。</li><li>购买行为： 分析 <code>N_Purchases</code> ，了解平均购买次数、最大购买次数等，以便了解顾客的购买行为。</li><li>购买日期分析： 根据 <code>Purchase_DATE</code> ，可以分析销售在不同日期的分布，可能有季节性或周期性的趋势。</li><li>购买价值： 分析 <code>Purchase_VALUE</code> ，了解平均购买价值、最大购买价值等，以便了解不同交易的价值。</li><li>支付方式偏好： 对 <code>Pay_Method</code> 进行统计，了解顾客的支付方式偏好。</li><li>浏览器使用情况： 分析 <code>Browser</code> 变量，了解顾客使用的主要浏览器。</li><li>是否订阅新闻和使用优惠券的情况： 分析 <code>Newsletter</code> 和 <code>Voucher</code> 变量，了解顾客是否订阅新闻和是否使用优惠券。</li></ul><p>另外，通过Pyplot，我们还可以绘制多种图形来对数据集进行分析。以下是一些可能的图形选项：</p><ul><li>直方图 (Histogram): 年龄分布、总消费金额分布、订单数量分布等。</li><li>散点图 (Scatter Plot): 年龄与总消费金额的关系、订单数量与购买金额的关系等。</li><li>折线图 (Line Plot): 时间趋势，例如总消费金额随时间的变化。</li><li>条形图 (Bar Chart): 性别分布、付款方式分布、浏览器分布等。</li><li>箱线图 (Box Plot): 年龄分布的五数概括、总消费金额的五数概括等。</li><li>饼图 (Pie Chart): 性别比例、是否使用优惠券的比例等。</li><li>热力图 (Heatmap): 可以展示各变量之间的相关性。</li><li>多子图组合 (Subplots): 可以在同一图中比较不同变量的分布或趋势。</li><li>散点矩阵 (Scatter Matrix): 用于观察多个变量之间的关系。</li><li>3D图 (3D Plot): 适用于三维数据的可视化，例如年龄、总消费金额和订单数量的关系。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 12 使用 Scikit-Learn 计算各种指标</title>
      <link href="/2023/5985afb6.html"/>
      <url>/2023/5985afb6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="SkLearn-中的准确率、精确度、召回率和-F1-分数"><a href="#SkLearn-中的准确率、精确度、召回率和-F1-分数" class="headerlink" title="SkLearn 中的准确率、精确度、召回率和 F1 分数"></a>SkLearn 中的准确率、精确度、召回率和 F1 分数</h1><p>SkLearn 已经内置了我们前面提到过的各个对于模型评估的指标，包括准确率（Accuracy）、精确度（Precision）、召回率（Recall）以及 F1 分数（F1 Score）。</p><p>现在我们将尝试调用他们为我们工作。现在，让我们重新回忆泰坦尼克号数据集逻辑回归模型的构建方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据预处理填补缺失值</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line">y_pred = model.predict(X)</span><br></pre></td></tr></table></figure><p>我们读取 train.csv 然后保存在 df DataFrame 中，然后对数据进行预处理，将 Age 列的缺失值添加为 Age 的平均值。再创建 male 变量，保存数据点是否为男性。再来是创建特征值 X 和目标值 y。接下来创建一个 <code>LogisticRegression</code> 类来构建我们的模型，并将特征值和目标值传递进去训练模型。最后创建一个 <code>y_pred</code> 变量来保存我们预测的结果</p><p>现在，我们来使用指标函数（metric functions），先引用它。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br></pre></td></tr></table></figure><p>每个函数接受两个一维的 numpy 数组：目标的真实值和目标的预测值。我们有目标的真实值和目标的预测值。因此，我们可以使用以下的度量函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据预处理填补缺失值</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuracy:&quot;</span>, accuracy_score(y, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;precision:&quot;</span>, precision_score(y, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recall:&quot;</span>, recall_score(y, y_pred))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;f1 score:&quot;</span>, f1_score(y, y_pred))</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accuracy: 0.797979797979798</span><br><span class="line">precision: 0.7515527950310559</span><br><span class="line">recall: 0.7076023391812866</span><br><span class="line">f1 score: 0.7289156626506023</span><br></pre></td></tr></table></figure><p>我们可以看到准确率为 79%，这意味着模型的预测有 80% 是正确的。精确度为 75%，这是指模型正类别预测中正确的百分比。召回率为 70%，表示模型正确预测的正类别占所有正类别的百分比。F1 分数为 73%，是精确度和召回率的平均值。</p><div class="note info flat"><p>对于单个模型，度量值并不能提供很多信息。对于某些问题，60% 的值可能是不错的，而对于其他问题，90% 的值可能是不错的，这取决于问题的难度。我们将使用度量值来比较不同的模型，以选择最佳的模型。</p></div><div class="note default flat"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(classification_report(y,y_pred))</span><br></pre></td></tr></table></figure><p>The above code give precision, recall &amp; f1_score</p></div><h1 id="Sklearn-中的混淆矩阵"><a href="#Sklearn-中的混淆矩阵" class="headerlink" title="Sklearn 中的混淆矩阵"></a>Sklearn 中的混淆矩阵</h1><p>Scikit-learn提供了一个混淆矩阵函数，我们可以使用它来获取混淆矩阵中的四个值（真正例、假正例、假负例和真负例）。假设y是我们的真实目标值，y_pred是预测值，我们可以如下使用confusion_matrix函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y, y_pred))</span><br></pre></td></tr></table></figure><p>返回值如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[469  80]</span><br><span class="line"> [100 242]]</span><br><span class="line"># output order of matrix : </span><br><span class="line"># [[TN FP]</span><br><span class="line">#  [FN TP]]</span><br></pre></td></tr></table></figure><p>Sklearn 反转矩阵使其先显示负值，以下就是返回值的结构：</p><div class="table-container"><table><thead><tr><th></th><th>Predicted Negative</th><th>Predicted Positive</th></tr></thead><tbody><tr><td>Actual Negative</td><td>469</td><td>80</td></tr><tr><td>Actual Positive</td><td>100</td><td>242</td></tr></tbody></table></div><p>这是我们通常绘制混淆矩阵的方式：</p><div class="table-container"><table><thead><tr><th></th><th>Actual Positive</th><th>Actual Negative</th></tr></thead><tbody><tr><td>Predicted Positive</td><td>242</td><td>80</td></tr><tr><td>Predicted Negative</td><td>100</td><td>469</td></tr></tbody></table></div><div class="note info flat"><p>Since negative target values correspond to 0 and positive to 1, scikit-learn has ordered them in this order. Make sure you double check that you are interpreting the values correctly!</p><p>由于负的目标值对应0，正的目标值对应1，scikit-learn以这个顺序排列它们。确保您仔细检查并正确解释这些值！</p></div><details class="toggle" ><summary class="toggle-button" style="">衍生介绍矩阵反转的原理</summary><div class="toggle-content"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression </span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://sololearn.com/uploads/files/titanic.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;Male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span> </span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Siblings/Spouses&#x27;</span>, <span class="string">&#x27;Parents/Children&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TP = True Positive </span></span><br><span class="line"><span class="comment"># FP = False Positive</span></span><br><span class="line"><span class="comment"># TN = True Negative</span></span><br><span class="line"><span class="comment"># FN = False Negative</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y, y_pred)) <span class="comment"># output confusion matrix, actual targets &#x27;y&#x27; passed first, predicted targets &#x27;y_pred&#x27; passed second </span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Scikit-learn convention for confusion matrix is to show predicted labels along columns, actual labels along rows. Scikit-learn convention considers 0 to be negative class and 1 to be positive class.</span></span><br><span class="line"><span class="comment"># Order of 0 and 1 in confusion matrix depends on which appears first in your dataset/target values. In our dataset/target values 0 appears first, so 0 is first row and column in our confusion matrix.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Therefore, the confusion matrix shows:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  A 0 TN | FP</span></span><br><span class="line"><span class="comment">#  c   ___|___</span></span><br><span class="line"><span class="comment">#  t  |</span></span><br><span class="line"><span class="comment">#  u 1 FN | TP  </span></span><br><span class="line"><span class="comment">#  a   </span></span><br><span class="line"><span class="comment">#  l   0 1</span></span><br><span class="line"><span class="comment">#  P r e d i c t e d</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatic ordering of 0 and 1 in confusion matrix can be overrided and set with &#x27;labels=&#x27;</span></span><br><span class="line"><span class="comment"># lets make 1 appear first with &#x27;labels=[1,0]&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y, y_pred, labels = [<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, the confusion matrix shows:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  A 1 TP | FN</span></span><br><span class="line"><span class="comment">#  c   ___|___</span></span><br><span class="line"><span class="comment">#  t  |</span></span><br><span class="line"><span class="comment">#  u 0 FP | TN  </span></span><br><span class="line"><span class="comment">#  a  </span></span><br><span class="line"><span class="comment">#  l   1 0 </span></span><br><span class="line"><span class="comment">#  P r e d i c t e d</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># To flip matrix so predicted labels along rows, actual labels along columns, we must pass predicted targets first, actual targets second</span></span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y_pred, y, labels = [<span class="number">1</span>,<span class="number">0</span>])) <span class="comment"># &#x27;y_pred&#x27; passed first, &#x27;y&#x27; passed second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Now, the confusion matrix shows:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  P </span></span><br><span class="line"><span class="comment">#  r</span></span><br><span class="line"><span class="comment">#  e 1 TP | FP   </span></span><br><span class="line"><span class="comment">#  d   ___|___  </span></span><br><span class="line"><span class="comment">#  i  | </span></span><br><span class="line"><span class="comment">#  c 0 FN | TN  </span></span><br><span class="line"><span class="comment">#  t   </span></span><br><span class="line"><span class="comment">#  e</span></span><br><span class="line"><span class="comment">#  d   1 0</span></span><br><span class="line"><span class="comment">#A c t u a l</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># github.com/alandavidgrunberg</span></span><br></pre></td></tr></table></figure></div></details>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 11 精确度和召回率</title>
      <link href="/2023/a865dfe2.html"/>
      <url>/2023/a865dfe2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在分类任务中，两个常用的指标是<strong>精确度（precision）</strong>和<strong>召回率（recall）</strong>。从概念上讲，<strong>精确度</strong>指的是正确的正类别结果在所有模型预测的正类别结果中所占的百分比，而<strong>召回率</strong>指的是正确预测的正类别结果在所有实际正类别样本中所占的百分比。</p><p>这两者都可以使用混淆矩阵中的象限来定义，而混淆矩阵如下：</p><details class="toggle" ><summary class="toggle-button" style="">英文原文</summary><div class="toggle-content"><p>Two commonly used metrics for classification are precision and recall. Conceptually, precision refers to the percentage of positive results which are relevant and recall to the percentage of positive cases correctly classified.</p><p>Both can be defined using quadrants from the confusion matrix, which we recall is as follows:</p></div></details><p><img src="/uploads/sololearn/machine-learning/confusion%20tfpn.webp"/></p><h1 id="精确度（Precision）"><a href="#精确度（Precision）" class="headerlink" title="精确度（Precision）"></a>精确度（Precision）</h1><p>精确度是模型正确预测的正类别结果在所有模型预测的正类别结果中所占的百分比。其定义如下：</p><script type="math/tex; mode=display">\begin{aligned}  \text{精确度} &= \frac{\text{正确预测的正类别数量}}{\text{模型预测的正类别总数量}} \\               &= \frac{\text{TP}}{\text{TP + FP}}\end{aligned}</script><details class="toggle" ><summary class="toggle-button" style="">查看英文公式</summary><div class="toggle-content"><script type="math/tex; mode=display">\begin{aligned}  \text{precision} &= \frac{\text{nums of positives predicted correctly}}{\text{nums of positives predictions}} \\                   &= \frac{\text{TP}}{\text{TP + FP}}\end{aligned}</script></div></details><p>如果我们查看泰坦尼克号数据集上模型的混淆矩阵，我们可以计算精确度。</p><p><img src="/uploads/sololearn/machine-learning/titanic%20confusion%20matrix.webp"/></p><script type="math/tex; mode=display">\begin{aligned}  \text{精确度} &= \frac{233}{(233 + 65)} \\               &= 0.7819\end{aligned}</script><div class="note info flat"><p>Precision is a measure of how precise the model is with its positive predictions.</p><p>精确度是模型在其正类别预测中的准确性度量。</p></div><h1 id="精确度的练习"><a href="#精确度的练习" class="headerlink" title="精确度的练习"></a>精确度的练习</h1><p>我们的混淆矩阵如下所示。</p><div class="table-container"><table><thead><tr><th></th><th>实际正类别</th><th>实际负类别</th></tr></thead><tbody><tr><td>预测为正类别</td><td>30</td><td>20</td></tr><tr><td>预测为负类别</td><td>10</td><td>40</td></tr></tbody></table></div><p>精确度是多少？<span class="hide-inline"><button type="button" class="hide-button" style=""> 查看答案</button><span class="hide-content">0.6</span></span></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><script type="math/tex; mode=display">\begin{aligned}  \text{精确度} &= \frac{\text{正确预测的正类别数量}}{\text{模型预测的正类别总数量}} \\               &= \frac{\text{TP}}{\text{TP + FP}} \\               &= \frac{\text{30}}{\text{30 + 20}} \\               &= 0.6\end{aligned}</script></div></details><h1 id="召回率（Recall）"><a href="#召回率（Recall）" class="headerlink" title="召回率（Recall）"></a>召回率（Recall）</h1><p>召回率是模型正确预测的正类别占所有实际正类别样本的百分比。同样，我们将使用混淆矩阵来计算结果。</p><p><img src="/uploads/sololearn/machine-learning/confusion%20tfpn.webp"/></p><p>在这里，我们用数学方式定义召回率：</p><script type="math/tex; mode=display">\begin{aligned}  \text{召回率} &= \frac{\text{正确预测的正类别数量}}{\text{正类别的数量}} \\               &= \frac{\text{TP}}{\text{TP + FN}}\end{aligned}</script><details class="toggle" ><summary class="toggle-button" style="">查看英文公式</summary><div class="toggle-content"><script type="math/tex; mode=display">\begin{aligned}  \text{precision} &= \frac{\text{nums of positives predicted correctly}}{\text{nums of positives cases}} \\                   &= \frac{\text{TP}}{\text{TP + FN}}\end{aligned}</script></div></details><p>让我们计算泰坦尼克号数据集上模型的召回率。</p><p><img src="/uploads/sololearn/machine-learning/titanic%20confusion%20matrix.webp"/></p><script type="math/tex; mode=display">\begin{aligned}  \text{召回率} &= \frac{233}{233 + 109} \\               &= 0.6813\end{aligned}</script><div class="note info flat"><p>Recall is a measure of how many of the positive cases the model can recall.</p><p>召回率是模型能够检索多少正类别案例的度量。</p></div><h1 id="召回率的练习"><a href="#召回率的练习" class="headerlink" title="召回率的练习"></a>召回率的练习</h1><p>我们的混淆矩阵如下所示。</p><div class="table-container"><table><thead><tr><th></th><th>实际正类别</th><th>实际负类别</th></tr></thead><tbody><tr><td>预测为正类别</td><td>30</td><td>20</td></tr><tr><td>预测为负类别</td><td>10</td><td>40</td></tr></tbody></table></div><p>召回率是多少？<span class="hide-inline"><button type="button" class="hide-button" style=""> 查看答案</button><span class="hide-content">0.75</span></span></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><script type="math/tex; mode=display">\begin{aligned}  \text{召回率} &= \frac{\text{正确预测的正类别数量}}{\text{正类别的数量}} \\               &= \frac{\text{TP}}{\text{TP + FN}} \\               &= \frac{\text{30}}{\text{30 + 10}} \\               &= 0.75\end{aligned}</script></div></details><h1 id="精确度和召回率的权衡（Trade-off）"><a href="#精确度和召回率的权衡（Trade-off）" class="headerlink" title="精确度和召回率的权衡（Trade-off）"></a>精确度和召回率的权衡（Trade-off）</h1><details class="toggle" style="border: 1px solid bg"><summary class="toggle-button" style="background-color: bg;color: color">英文原文</summary><div class="toggle-content"><p>We often will be in a situation of choosing between increasing the recall (while lowering the precision) or increasing the precision (and lowering the recall). It will depend on the situation which we’ll want to maximize.</p><p>For example, let’s say we’re building a model to predict if a credit card charge is fraudulent. The positive cases for our model are fraudulent charges and the negative cases are legitimate charges.</p><p>Let’s consider two scenarios:</p><ol><li>If we predict the charge is fraudulent, we’ll reject the charge.</li><li>If we predict the charge is fraudulent, we’ll call the customer to confirm the charge.</li></ol><p>In case 1, it’s a huge inconvenience for the customer when the model predicts fraud incorrectly (a false positive). In case 2, a false positive is a minor inconvenience for the customer.</p><p>The higher the false positives, the lower the precision. Because of the high cost to false positives in the first case, it would be worth having a low recall in order to have a very high precision. In case 2, you would want more of a balance between precision and recall.</p><div class="note info flat"><p>There’s no hard and fast rule on what values of precision and recall you’re shooting for. It always depends on the dataset and the application.</p></div></div></details><p>我们经常会面临在增加召回率（降低精确度）或增加精确度（降低召回率）之间进行选择的情况。我们选择哪个取决于我们希望最大化哪个度量，具体取决于情况。</p><p>例如，假设我们正在构建一个模型来预测信用卡交易是否存在欺诈。模型的正类别是欺诈交易，负类别是合法交易。</p><p>让我们考虑两种情况：</p><ol><li>如果我们预测交易是欺诈的，我们将拒绝交易。</li><li>如果我们预测交易是欺诈的，我们将致电客户以确认交易。</li></ol><p>在情况 1 中，当模型错误地预测欺诈（假正例）时，对客户来说是巨大的不便。在情况 2 中，假正例对客户来说只是轻微的不便。</p><p>假正例越多，精确度就越低。由于在情况 1 中假正例的代价很高，因此牺牲召回率以获得非常高的精确度可能是值得的。在情况 2 中，你可能希望在精确度和召回率之间取得更好的平衡。</p><div class="note info flat"><p>在精确度和召回率方面，没有硬性规则确定你要追求的数值。这始终取决于数据集和应用场景。</p></div><h1 id="精确度和召回率的权衡的练习"><a href="#精确度和召回率的权衡的练习" class="headerlink" title="精确度和召回率的权衡的练习"></a>精确度和召回率的权衡的练习</h1><p>我们正在构建一个用于预测垃圾邮件的模型。正类别是垃圾邮件，负类别是合法邮件。如果我们要删除我们预测为垃圾邮件的电子邮件，那么在精确度和召回率中，哪一个更重要需要最大化？<span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">精确度（Precision）</span></span></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><p>在这种情况下，最大化精确度（通过提高精确度）是很重要的；因为假正例将被删除（即被我们的模型错误预测为垃圾邮件的电子邮件），这可能导致重要的电子邮件被删除，因为出现了错误的预测。在这里，假正例的代价很高。因此，我们最好将其最小化（通过提高精确度）。</p><hr><p>众所周知，垃圾邮件相较于合法（重要）邮件要少得多。</p><script type="math/tex; mode=display">\begin{aligned}  \text{Precision} &= \frac{\text{TP}}{\text{TP + FP}} \\  \text{Recall} &= \frac{\text{TP}}{\text{TP + FN}} , \text{FP} > \text{FN} , \text{TP + FP} > \text{TP + FN} \\\end{aligned}</script><script type="math/tex; mode=display">\therefore \text{Precision} < \text{Recall} \\</script><p>在这种情况下，最大化精确度（通过增加精确度）是很重要的，因为假正例（邮件被错误预测为垃圾邮件）会导致合法（重要）邮件被错误地“删除”。FP 的代价大于 FN，我们必须最大化精确度。</p><script type="math/tex; mode=display">\text{Maximize Precision:} \quad \text{Precision} = \frac{\text{TP}}{\text{TP + FP}}</script></div></details><h1 id="精确度和召回率的小结"><a href="#精确度和召回率的小结" class="headerlink" title="精确度和召回率的小结"></a>精确度和召回率的小结</h1><p>更简单的定义：</p><ul><li><strong>Precision（精确度）</strong>：预测为正类别且实际上是正类别的数据点所占的百分比。即，所有正确预测为正类别（TP）占所有模型预测为</li><li><strong>Recall（召回率）</strong>：实际为正类别且被模型正确预测为正类别的数据点所占的百分比。即，所有正确预测为正类别（TP）占所有实际正类别的数据点（TP + FN）的百分比。</li></ul><h1 id="F1-分数"><a href="#F1-分数" class="headerlink" title="F1 分数"></a>F1 分数</h1><p>准确率是一个吸引人的指标，因为它是一个单一的数字。精确度和召回率是两个数字，因此在两个模型之间选择时，如果一个模型的精确度较高，另一个模型的召回率较高，并不总是很明显该选择哪个。F1 分数是精确度和召回率的平均值，因此我们有一个单一的得分用于评估模型。</p><p>以下是F1分数的数学公式：</p><script type="math/tex; mode=display">\text{F1} = 2 \times \frac{\text{精确度 \times 召回率}}{\text{精确度 + 召回率}}</script><p>让我们来计算泰坦尼克号数据集上模型的 F1 分数。我们将使用之前我们计算出来精确度和召回率的数值。精确度为 0.7819，召回率为 0.6813。F1 分数计算如下：</p><script type="math/tex; mode=display">\begin{aligned}  \text{F1} &= 2 \times \frac{0.7819 \times 0.6813}{0.7819 + 0.6813} \\            &= 0.7281\end{aligned}</script><div class="note info flat"><p>F1 分数是精确度和召回率值的调和平均（harmonic mean）。</p></div><details class="toggle" ><summary class="toggle-button" style="">衍生资料</summary><div class="toggle-content"><p>如果精确度或召回率中的任一个较低，F1（调和平均）将比算术平均或几何平均更为敏感：</p><ul><li>算术平均值：AM = <script type="math/tex">\frac{0.9 + 0.4}{2} = 0.65</script></li><li>几何平均值：GM = <script type="math/tex">\sqrt{0.9 \times 0.4} \approx 0.6</script></li><li>调和平均值：HM = <script type="math/tex">\frac{2 \times (0.9 \times 0.4)}{0.9 + 0.4} \approx 0.55</script>。</li></ul><p>调和平均值比算术平均值更严厉地惩罚极端值，因此在需要考虑精确度和召回率，并且希望达到平衡性能的情况下，它是更为合适的选择。它在一个指标明显低于另一个指标的情况下特别有用。</p><hr><p>两个值的调和平均在原始公式中为：</p><script type="math/tex; mode=display">\begin{aligned}  HM &= \frac{2}{\left(\frac{1}{a} + \frac{1}{b}\right)} \\     &= \frac{2 \times 1}{\frac{(a + b)}{ab}} \\     &= \frac{2 \times ab}{(a + b)} \end{aligned}</script><p>对于n个变量，我们将n除以分数之和 $\frac{1}{x}$：</p><script type="math/tex; mode=display">HM = \frac{n}{\left(\frac{1}{x_1} + \ldots + \frac{1}{x_n}\right)}</script><p>还有其他一些均值：算术平均：</p><script type="math/tex; mode=display">AM = \frac{(x_1 + \ldots + x_n)}{n}</script><p>几何平均：值的乘积的n次方根：</p><script type="math/tex; mode=display">GM = \sqrt[n]{x_1 \times \ldots \times x_n}</script><p>因此，有趣的一点是对于非负值总是成立的：$ AM \geq GM \geq HM $，只有当所有值相同时才会达到相等。简而言之，调和平均更接近较小的值，因此F1试图保持最小值较高。</p></div></details>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（10）模型评估</title>
      <link href="/2023/7d2579fa.html"/>
      <url>/2023/7d2579fa.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>“Model Evaluation” 的意思是对模型进行评估，即检查和量化模型在给定数据集上的性能和效果的过程。在机器学习中，构建一个模型后，我们通常需要评估它的性能，以确保其在实际应用中表现良好。</p><p>模型评估的目的是了解模型在预测新数据时的准确性、稳健性和可靠性。一些常见的模型评估指标包括准确率、精确度、召回率、F1 分数等，这些指标提供了关于模型在不同方面表现的信息。</p><p>总体而言，模型评估是机器学习中至关重要的一步，帮助我们了解模型在特定任务上的表现，从而可以进行调整、改进或选择其他模型。</p><h1 id="准确率（Accuracy）"><a href="#准确率（Accuracy）" class="headerlink" title="准确率（Accuracy）"></a>准确率（Accuracy）</h1><p>在前面的模块中，我们使用准确率（Accuracy）来衡量模型的性能。准确率是正确预测的百分比。</p><div class="note default flat"><p>如果你有100个数据点，其中70个被正确预测，30个被错误预测，那么准确率为70%。</p></div><p>准确率是一个非常直观且易于理解的指标，但并不总是最好的指标。例如，假设我有一个模型用于预测信用卡交易是否存在欺诈。在 10000 笔信用卡交易中，有 9900 笔是合法交易，100 笔是欺诈交易。我可以构建一个模型，只是预测每一笔交易都是合法的，这样它就会在预测中获得 9900/10000（99%）的准确率！</p><div class="note default flat"><p>对于欺诈信用卡活动的例子属于不平衡的数据集。在收集信用卡活动数据时，大部分活动将是合法的，而找到欺诈活动的实例相对较难。这是一个问题，因为通常我们更关心预测少数类别的情况，或者在这种情况下是欺诈活动。</p><p>处理不平衡数据集有一些策略。我们可以过采样少数类别。在我们的例子中，这意味着我们会在数据集中包含每个欺诈活动案例99次。这样做可以平衡数据中每个活动类别的表示。</p><p>或者，我们可以更重视预测欺诈活动的错误，而不是预测合法活动的错误。通过谷歌搜索，你可以找到更多处理不平衡数据集的想法。</p></div><p>如果我们的类别平均分布，准确率是一个很好的度量，但如果类别不平衡，它就会非常误导。</p><div class="note info flat"><p>在使用准确率时要谨慎。你需要了解类别的分布情况，以了解如何解释这个值。</p></div><h1 id="对于准确率的练习"><a href="#对于准确率的练习" class="headerlink" title="对于准确率的练习"></a>对于准确率的练习</h1><p>假设你的任务是构建一个模型来预测垃圾邮件。你的训练集有 1000 封电子邮件，其中 950 封是合法邮件，50 封是垃圾邮件。你构建了一个模型，只是预测每封电子邮件都是合法的。这个模型的准确率是多少？<span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">95%</span></span></p><h1 id="混淆矩阵（Confusion-Matrix）"><a href="#混淆矩阵（Confusion-Matrix）" class="headerlink" title="混淆矩阵（Confusion Matrix）"></a>混淆矩阵（Confusion Matrix）</h1><p>正如我们在前面部分中注意到的，我们不仅关心我们正确预测了多少数据点的类别，还关心我们正确预测了多少正类别数据点以及我们正确预测了多少负类别数据点。</p><p>我们可以在所谓的混淆矩阵 (Confusion Matrix)（或错误矩阵 (Error Matrix) 或混淆表 (Table of Confusion)）中看到所有重要的值。</p><p>混淆矩阵是一个显示四个值的表格：</p><ul><li>我们预测为正类别且实际上是正类别的数据点</li><li>我们预测为正类别但实际上是负类别的数据点</li><li>我们预测为负类别但实际上是正类别的数据点</li><li>我们预测为负类别且实际上是负类别的数据点</li></ul><p>第一和第四个是我们正确预测的数据点，而第二和第三个是我们错误预测的数据点。</p><p>在我们的泰坦尼克号数据集中，有887名乘客，342名幸存（正类别）和545名未幸存（负类别）。我们在前一模块中构建的模型具有以下混淆矩阵。</p><p><img src="/uploads/sololearn/machine-learning/titanic%20confusion%20matrix.webp"/></p><p>蓝色阴影的方块是我们正确预测的预测次数。因此，在 342 名幸存的乘客中，我们正确预测了 233 人（错误预测了 109 人）。在 545 名未幸存的乘客中，我们正确预测了 480 人（错误预测了 65 人）。</p><p>我们可以使用混淆矩阵来计算准确率。作为提醒，准确率是正确预测的数据点数量除以总数据点数量。</p><script type="math/tex; mode=display">\begin{aligned}                                \text{准确率} &= \frac{\text{主对角线元素之和}}{\text{所有元素之和}} \\  \frac{(233 + 480)}{(233 + 65 + 109 + 480)} &= \frac{713}{887} \\                                             &= 80.38\%\end{aligned}</script><p>这确实是我们在前一模块中得到的相同值。（注：在逻辑回归中，我们使用的是另一个源的模型数据，所以概率在 79% 左右。</p><div class="note info flat"><p>混淆举证完全描述了模型在数据集上的性能，景观他难以用于比较模型。</p></div><h1 id="混淆矩阵的练习"><a href="#混淆矩阵的练习" class="headerlink" title="混淆矩阵的练习"></a>混淆矩阵的练习</h1><p>根据下面的混淆矩阵，计算模型的准确率。</p><div class="table-container"><table><thead><tr><th></th><th>实际正类别</th><th>实际负类别</th></tr></thead><tbody><tr><td>预测为正类别</td><td>20</td><td>26</td></tr><tr><td>预测为负类别</td><td>10</td><td>44</td></tr></tbody></table></div><p>准确率将是多少？<span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">64%</span></span></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><p>计算矩阵的主对角线上的元素之和，然后除以矩阵所有元素的和。</p><script type="math/tex; mode=display">\begin{aligned}  \frac{(20 + 44)}{(20 + 26 + 10 + 44)} &= \frac{64}{100} \\                                        &= 64\%\end{aligned}</script></div></details><h1 id="真正例、真负例、假正例、假负例"><a href="#真正例、真负例、假正例、假负例" class="headerlink" title="真正例、真负例、假正例、假负例"></a>真正例、真负例、假正例、假负例</h1><p>对于混淆矩阵的每个方格，我们有相应的术语。</p><p><strong>真正例（True Positive，TP）</strong> 是我们正确预测为正类别的数据点。<br><strong>真负例（True Negative，TN）</strong> 是我们正确预测为负类别的数据点。<br><strong>假正例（False Positive，FP）</strong> 是我们错误地预测为正类别的数据点。<br><strong>假负例（False Negative，FN）</strong> 是我们错误地预测为负类别的数据点。</p><p>这些术语可能有点难以记住。记住的方法是，第二个词表示我们的预测是什么（正类别或负类别），而第一个词表示该预测是否正确（真或假）。</p><p>通常会看到混淆矩阵描述如下：</p><p><img src="/uploads/sololearn/machine-learning/confusion%20tfpn.webp"/></p><div class="note info flat"><p>混淆矩阵的四个值（TP、TN、FP、FN）用于计算后面将要使用的几个不同的度量指标。</p></div><h1 id="真假正负例的练习"><a href="#真假正负例的练习" class="headerlink" title="真假正负例的练习"></a>真假正负例的练习</h1><div class="table-container"><table><thead><tr><th></th><th>实际正类别</th><th>实际负类别</th></tr></thead><tbody><tr><td>预测为正类别</td><td>233</td><td>65</td></tr><tr><td>预测为负类别</td><td>109</td><td>480</td></tr></tbody></table></div><ul><li>那里有 233 个 <span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">真正例（True Positive）</span></span></li><li>那里有 65 个 <span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">假正例（False Positive）</span></span></li><li>那里有 109 个 <span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">假负例（False Negative）</span></span></li><li>那里有 480 个 <span class="hide-inline"><button type="button" class="hide-button" style="">查看答案</button><span class="hide-content">真负例（True Negative）</span></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> 混淆矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 Code Project 2 Bob the Builder</title>
      <link href="/2023/665f82e5.html"/>
      <url>/2023/665f82e5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>构建一个逻辑回归模型。</p><h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><p>给定一个特征矩阵和一个要预测的单个数据点。您的任务是使用特征矩阵构建逻辑回归模型，并对单个数据点进行预测（ 1 或 0 ）。</p><p>You are given a feature matrix and a single datapoint to predict. Your job will be to build a Logistic Regression model with the feature matrix and make a prediction (1 or 0) of the single datapoint.</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><ul><li>第一行：特征矩阵中的数据点数量（n）</li><li>接下来的 n 行：特征矩阵中行的值，以空格分隔</li><li>接下来一行：目标值，以空格分隔</li><li><p>最后一行：单个数据点的值（以空格分隔），没有目标值</p></li><li><p>First line: Number of data points in the feature matrix (n)</p></li><li>Next n lines: Values of the row in the feature matrix, separated by spaces</li><li>Next line: Target values separated by spaces</li><li>Final line: Values (separated by spaces) of a single datapoint without a target value</li></ul><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>要么是 1 要么是 0</p><h1 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 3</span><br><span class="line">3 5</span><br><span class="line">5 7</span><br><span class="line">3 1</span><br><span class="line">5 3</span><br><span class="line">7 5</span><br><span class="line">1 1 1 0 0 0</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h1 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p><img src="/uploads/sololearn/machine-learning/code%20project%202%20visualize.jpg"/></p><p>我们可以看到上图中绘制的点和分隔数据的线。点（2, 4）在图上标出，你可以看到它在线的正侧，因此结果是1。</p><h1 id="起手式"><a href="#起手式" class="headerlink" title="起手式"></a>起手式</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">X = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    X.append([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">y = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">datapoint = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br></pre></td></tr></table></figure><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>我们根据起手式，将注释写上，容易看一些</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一行：特征矩阵中的数据点数量（n）</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 接下来的 n 行：特征矩阵中行的值，以空格分隔</span></span><br><span class="line">X = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    X.append([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line"><span class="comment"># 接下来一行：目标值，以空格分隔</span></span><br><span class="line">y = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"><span class="comment"># 最后一行：单个数据点的值（以空格分隔），没有目标值</span></span><br><span class="line">datapoint = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>分析并给出思路</p><ol><li>引用 scikit-learn 包中的 LogisticRegression 类</li><li>实例化 LogisticRegression 类</li><li>构建模型</li><li>输出结果</li></ol><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入机器学习的包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 LogisticRegression 类</span></span><br><span class="line">model = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行：特征矩阵中的数据点数量（n）</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 接下来的 n 行：特征矩阵中行的值，以空格分隔</span></span><br><span class="line">X = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    X.append([<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line"><span class="comment"># 接下来一行：目标值，以空格分隔</span></span><br><span class="line">y = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"><span class="comment"># 最后一行：单个数据点的值（以空格分隔），没有目标值</span></span><br><span class="line">datapoint = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出预测结果</span></span><br><span class="line"><span class="built_in">print</span>(model.predict([datapoint])[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><div class="note info flat"><p>代码解释：</p><p>主要是 <code>model.predict()</code> 函数返回值是数组，由于我们只预测一组数据点（datapoint），所以需要用下标 0 来获取第一个元素</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Code Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言随堂测试试卷解答</title>
      <link href="/2023/d0dd4115.html"/>
      <url>/2023/d0dd4115.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="单项选择题"><a href="#单项选择题" class="headerlink" title="单项选择题"></a>单项选择题</h1><h2 id="用户标识符"><a href="#用户标识符" class="headerlink" title="用户标识符"></a>用户标识符</h2><p>1、以下不能定义为用户标识符的是（   ）</p><div class="hide-block"><button type="button" class="hide-button" style="">A）scanf</button><div class="hide-content"><div class="note danger flat"><p><code>scanf</code> 答案错误！</p><p><code>scanf</code> 不属于 C 语言关键字的任意一个。他是 <code>&lt;stdio.h&gt;</code> 头文件中的其中一个函数名。用户可以自定义一个 <code>scanf</code> 函数名去 <strong>替换</strong> 掉原有的 <code>scanf</code> 函数。</p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">B）Void</button><div class="hide-content"><div class="note danger flat"><p><code>Void</code> 答案错误！</p><p>要知道，C 语言是严格区分大小写的，所以 <code>Void</code> <strong>不等于</strong> <strong>关键字</strong> 中的 <code>Void</code></p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">C）_3com</button><div class="hide-content"><div class="note danger flat"><p><code>_3com</code> 答案错误！</p><p>C 语言的变量名可以用 <strong>字母或下划线开头</strong></p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">D）int</button><div class="hide-content"><div class="note success flat"><p><code>int</code> 正确，<code>int</code> 属于 C 语言中 <strong>32 个关键字</strong> 中的其中一个，故不能成为用户标识符。 </p></div></div></div><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><p>本题重点是：关键字，变量命名规则</p><ul><li>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 <code>A-Z</code> 或 <code>a-z</code> 或下划线 <code>_</code> 开始，后跟零个或多个字母、下划线和数字（<code>0-9</code>）。</li><li>C 标识符内 <strong>不允许</strong> 出现标点字符，比如 <code>@</code>、<code>$</code> 和 <code>%</code>。C 是区分大小写的编程语言。因此，在 C 中，<code>Manpower</code> 和 <code>manpower</code> 是两个不同的标识符。</li><li>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</li></ul><div class="table-container"><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>声明自动变量</td></tr><tr><td>break</td><td>跳出当前循环</td></tr><tr><td>case</td><td>开关语句分支</td></tr><tr><td>char</td><td>声明字符型变量或函数返回值类型</td></tr><tr><td>const</td><td>定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</td></tr><tr><td>continue</td><td>结束当前循环，开始下一轮循环</td></tr><tr><td>default</td><td>开关语句中的”其它”分支</td></tr><tr><td>do</td><td>循环语句的循环体</td></tr><tr><td>double</td><td>声明双精度浮点型变量或函数返回值类型</td></tr><tr><td>else</td><td>条件语句否定分支（与 if 连用）</td></tr><tr><td>enum</td><td>声明枚举类型</td></tr><tr><td>extern</td><td>声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td>float</td><td>声明浮点型变量或函数返回值类型</td></tr><tr><td>for</td><td>一种循环语句</td></tr><tr><td>goto</td><td>无条件跳转语句</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>int</td><td>声明整型变量或函数</td></tr><tr><td>long</td><td>声明长整型变量或函数返回值类型</td></tr><tr><td>register</td><td>声明寄存器变量</td></tr><tr><td>return</td><td>子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td>short</td><td>声明短整型变量或函数</td></tr><tr><td>signed</td><td>声明有符号类型变量或函数</td></tr><tr><td>sizeof</td><td>计算数据类型或变量长度（即所占字节数）</td></tr><tr><td>static</td><td>声明静态变量</td></tr><tr><td>struct</td><td>声明结构体类型</td></tr><tr><td>switch</td><td>用于开关语句</td></tr><tr><td>typedef</td><td>用以给数据类型取别名</td></tr><tr><td>unsigned</td><td>声明无符号类型变量或函数</td></tr><tr><td>union</td><td>声明共用体类型</td></tr><tr><td>void</td><td>声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td>volatile</td><td>说明变量在程序执行中可被隐含地改变</td></tr><tr><td>while</td><td>循环语句的循环条件</td></tr></tbody></table></div></div></details><h2 id="表达式与数据类型"><a href="#表达式与数据类型" class="headerlink" title="表达式与数据类型"></a>表达式与数据类型</h2><p>设有定义：<code>float a = 2, b = 4, h = 3;</code> 以下 C 语言表达式中与代数式 <script type="math/tex">\frac{1}{2} (a + b) \times h</script> 的计算结果不相符的是（     ）</p><details class="toggle" style="border: 1px solid #FF7242"><summary class="toggle-button" style="background-color: #FF7242;color: #fff">查看算出来的值</summary><div class="toggle-content"><script type="math/tex; mode=display">\begin{aligned}\frac{1}{2} (a + b) \times h &= \frac{1}{2} (2 + 4) \times 3 \text{（将变量代入算式内）} \\                             &= 0.5 \times (6) \times 3 \\                             &=9\end{aligned}</script></div></details><div class="hide-block"><button type="button" class="hide-button" style="">A）(a + b) * h / 2</button><div class="hide-content"><div class="note danger flat"><p><code>(a + b) * h / 2</code></p><script type="math/tex; mode=display">\begin{aligned}    (a + b) \times h \div 2 &= (2 + 4) \times 3 \div 2 \\                         &= 6 \times 3 \div 2 \\                         &= 9 \text{相等}\end{aligned}</script></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">B）(1 / 2) * (a + b) * h</button><div class="hide-content"><div class="note success flat"><p><code>(1 / 2) * (a + b) * h</code><br>哎呀！这不是和上面的代数式一模一样嘛？怎么和计算结果不相符呢？别急，看下面解释。</p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">C）(a + b) * h * 1 / 2</button><div class="hide-content"><div class="note danger flat"><p><code>(a + b) * h * 1 / 2</code></p><script type="math/tex; mode=display">\begin{aligned}    (a + b) \times h \times 1 \div 2 &= (2 + 4) \times 3 \times 1 \div 2 \\                                  &= 6 \times 3 \times 1 \div 2 \\                                  &= 9 \text{相等}\end{aligned}</script></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">D）h / 2 * (a + b)</button><div class="hide-content"><div class="note danger flat"><p><code>h / 2 * (a + b)</code></p><script type="math/tex; mode=display">\begin{aligned}    h \div 2 \times (a + b) &= 3 \div 2 \times (2 + 4) \\                         &= 1.5 \times (6) \\                         &= 9 \text{相等}\end{aligned}</script></div></div></div><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><div class="note info flat"><p>本题重点是：数据类型</p></div><p>这要是用数学的思维计算，好家伙，全是 9，那不没答案嘛。你正想要去找老师抬杠呢，信心满满的打开 Visual Studio，往里面一输入：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">2</span>, b = <span class="number">4</span>, h = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (a + b) * h / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (<span class="number">1</span> / <span class="number">2</span>) * (a + b) * h);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, (a + b) * h * <span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, h / <span class="number">2</span> * (a + b));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果一看输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9.000000</span><br><span class="line">0.000000</span><br><span class="line">9.000000</span><br><span class="line">9.000000</span><br></pre></td></tr></table></figure><p>好家伙，我计算机出问题了？这怎么算出个 0 呢？仔细一看。。。奥！原来问题就出在 <code>(1 / 2)</code> 这个坑里。</p><div class="note danger flat"><p>在 C 语言中，整数相除，会舍弃掉小数点后面的值，甚至没有四舍五入。所以 <code>(1 / 2) = 0;</code> 而 <code>(1.0 / 2.0) = 0.5</code></p></div></div></details><h2 id="脑子过程序-1"><a href="#脑子过程序-1" class="headerlink" title="脑子过程序 1"></a>脑子过程序 1</h2><p>有以下程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((j++ || k++) &amp;&amp; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, i, j, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的输出结果是（     ）</p><p><code>1, 1, 2</code><br><div class="hide-block"><button type="button" class="hide-button" style="">A）</button><div class="hide-content"><div class="note danger flat"><p><code>1, 1, 2</code> 答错了！</p></div></div></div></p><p><code>2, 2, 1</code><br><div class="hide-block"><button type="button" class="hide-button" style="">B）</button><div class="hide-content"><div class="note danger flat"><p><code>2, 2, 1</code> 答错了！</p></div></div></div></p><p><code>2, 2, 2</code><br><div class="hide-block"><button type="button" class="hide-button" style="">C）</button><div class="hide-content"><div class="note success flat"><p><code>2, 2, 2</code> 答对了！</p></div></div></div></p><p><code>2, 2, 3</code><br><div class="hide-block"><button type="button" class="hide-button" style="">D）</button><div class="hide-content"><div class="note danger flat"><p><code>2, 2, 3</code> 答错了！</p></div></div></div></p><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> ((j++ || k++) &amp;&amp; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, i, j, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是程序员最烦最烦的题目。但是总喜欢出这种没营养的题目，是为了训练学生的 C 语言基础，所以还是得忍痛学习。这题主要有以下几点：</p><ol><li>C 逻辑中，非零为 真 True</li><li>if 语句有短路</li><li>自增</li></ol><p>非零为真 其实不是本题关键，因为 i j k 都是非 0 值。重点在 <strong>自增和短路</strong>！</p><ol><li>首先，<code>i = 1, j = 1, k = 2;</code></li><li>到 if 语句时，执行两个判断，首先是 <code>(j++ || k++)</code>，才到 <code>((j++ || k++) &amp;&amp; i++)</code><ol><li>当执行 <code>(j++ || k++)</code> 会触发一种机制，短路。因为 <code>j++</code> 后，<code>j = 2</code>，非 0，所以或语句并没有执行 <code>k++</code>，直接返回 <code>true</code></li><li>接下来执行 <code>(true &amp;&amp; i++)</code>，这时候需要执行 <code>i++</code>，所以 <code>i = 2</code>。</li></ol></li><li>所以 <code>i = 2, j = 2, k = 2;</code></li></ol><p><strong>衍生说逻辑判断中的短路：</strong></p><p>短路的意思是不会执行逻辑判断中后续的语句</p><ol><li>逻辑与 <code>&amp;&amp;</code>：如果或中间的其中一个值为 <code>0 假 false</code>，则发生短路</li><li>逻辑或 <code>||</code>：如果与中间的其中一个值为 <code>1 真 true</code>，则发生短路</li></ol></div></details><h2 id="脑子过程序-2"><a href="#脑子过程序-2" class="headerlink" title="脑子过程序 2"></a>脑子过程序 2</h2><p>有以下程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i += <span class="number">2</span>)</span><br><span class="line">s += i + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的输出结果是（     ）</p><div class="hide-block"><button type="button" class="hide-button" style="">A）自然数 1～9 的累加和</button><div class="hide-content"><div class="note danger flat"><p>自然数 1～9 的累加和 答错了！</p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">B）自然数 1～10 的累加和</button><div class="hide-content"><div class="note danger flat"><p>自然数 1～10 的累加和 答错了！</p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">C）自然数 1～9 中奇数之和</button><div class="hide-content"><div class="note success flat"><p>自然数 1～9 中奇数之和 答对了！</p></div></div></div><div class="hide-block"><button type="button" class="hide-button" style="">D）自然数 1～10 中偶数之和</button><div class="hide-content"><div class="note danger flat"><p>自然数 1～10 中偶数之和 答错了！</p></div></div></div><details class="toggle" ><summary class="toggle-button" style="">查看解释</summary><div class="toggle-content"><ol><li>注意看 for 循环变量增值操作（第三个表达式）是 <code>i += 2</code>，所以要么奇数要么偶数。</li><li>可以两种观点：<ol><li>for 循环的循环变量赋值操作（第一个表达式）是 <code>i = 1</code>，所以只能是 <code>1 3 5 7 9</code> 奇数。</li><li>for 循环中的循环条件（第二个表达式）为 <code>i &lt; 10</code>，所以不可能会是 1 - 10</li></ol></li></ol></div></details><h2 id="脑子过程序-3"><a href="#脑子过程序-3" class="headerlink" title="脑子过程序 3"></a>脑子过程序 3</h2><p>有以下函数定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n, <span class="type">double</span> x)</span> &#123; ... ... &#125;</span><br></pre></td></tr></table></figure><p>若以下选项中的变量都已经正确定义并赋值，则对函数fun的正确调用语句是（     ）</p><p><code>fun(int y, double m);</code><br><div class="hide-block"><button type="button" class="hide-button" style="">A）</button><div class="hide-content"><div class="note danger flat"><p><code>fun(int y, double m);</code> 答错了！这不知道是什么奇怪的写法。。。</p></div></div></div></p><p><code>k = fun(10, 12.5);</code><br><div class="hide-block"><button type="button" class="hide-button" style="">B）</button><div class="hide-content"><div class="note danger flat"><p><code>k = fun(10, 12.5);</code> 答错了！咋一看很像是对的是吧，可是这个函数的返回值是 <code>void</code>。所以他还是错了。</p></div></div></div></p><p><code>fun(x, n);</code><br><div class="hide-block"><button type="button" class="hide-button" style="">C）</button><div class="hide-content"><div class="note success flat"><p><code>fun(x, n);</code> 答对了！</p></div></div></div></p><p><code>void fun(n, x);</code><br><div class="hide-block"><button type="button" class="hide-button" style="">D）</button><div class="hide-content"><div class="note danger flat"><p><code>void fun(n, x);</code> 答错了！这是 <strong>声明函数</strong> 的语句</p></div></div></div></p><h1 id="阅读程序-填空"><a href="#阅读程序-填空" class="headerlink" title="阅读程序 填空"></a>阅读程序 填空</h1><p>有一个 3 * 4 矩阵，求其中的最大元素。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max_value</span><span class="params">(<span class="type">int</span> <span class="built_in">array</span>[][<span class="number">4</span>] <span class="comment">/* 填空 1：定义参数 */</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j, max;</span><br><span class="line">max = <span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; max)</span><br><span class="line">max = <span class="built_in">array</span>[i][j];</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>], i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">a[i][j] = i * j; <span class="comment">// 填空 2：赋值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max value is % d\n&quot;</span>, max_value(a));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="">查看解释</button><div class="hide-content"><ol><li>第一个空是函数行禅定义，我们通过下边的代码观察到 <code>array</code> 变量未在函数中被定义，所以推断形参就是 <code>array</code>。下方 <code>main</code> 函数中对 <code>max_value(a)</code> 的调用也能验证参数只有一个。且是二维数组。而二维数组的定义，第一个方括号可以留空，但是第二个不行 <code>[][4]</code>。同理，一维数组中的方括号不能留空 <code>[]</code>。</li><li>第二个空是赋值，说实话，这个空在这里好奇怪，因为我想不到还能填什么值，索性就以 <code>i * j</code> 的结果赋值给矩阵中。访问二维矩阵的方式为 <code>数组名[行下标][列下标]</code>。</li></ol></div></div><hr><p>输入 x、y 两个整数，按先大后小的顺序输出 x、y。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, * px, * py, * p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">px = &amp;x; <span class="comment">// 填空 3：将 x 的地址赋值给 px 指针</span></span><br><span class="line">py = &amp;y; <span class="comment">// 填空 4：将 y 的地址赋值给 py 指针</span></span><br><span class="line"><span class="keyword">if</span> (x &lt; y)</span><br><span class="line">&#123;</span><br><span class="line">p = px;   px = py;   py = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d, y = %d\n&quot;</span>, x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MAX = %d, MIN = %d\n&quot;</span>, *px, *py);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="">查看解释</button><div class="hide-content"><p>这题主要看它的交换操作那块，那是<strong>对地址</strong>进行操作，所以我们需要初始化地址指向 <code>x</code> 和 <code>y</code> 的指针。</p><div class="note warning flat"><p>注意，我们需要用 <code>&amp;</code> 取地址符，来获取 x 和 y 变量的地址。</p></div></div></div><hr><p>用选择排序法对任意10个整数按照由大到小排序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">11</span>], i, j, k, t;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input 10 numbers:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">k = i; <span class="comment">// 填空 5：初始化 k 为 i</span></span><br><span class="line"><span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= <span class="number">10</span><span class="comment">/* 填空 6：循环到数组的最后一个元素 */</span>; j++)</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[k])</span><br><span class="line">k = j;</span><br><span class="line"><span class="keyword">if</span> (k != i)</span><br><span class="line">&#123;</span><br><span class="line">t = a[k];  a[k] = a[i];  a[i] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The sorted numbers:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)  <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="hide-block"><button type="button" class="hide-button" style="">查看解释</button><div class="hide-content"><ol><li>填空 5： 在选择排序中，变量 <code>k</code> 用于记录当前轮次中最大元素的索引。在每轮开始时，应将 <code>k</code> 初始化为当前轮次的起始位置 <code>i</code>。</li><li>填空 6： 修改循环条件，使其循环到数组的最后一个元素。</li></ol><p><strong>选择排序的解释</strong></p><p>选择排序是一种简单直观的排序算法，其基本思想是每一次从待排序的数据元素中选择最小（或最大）的一个元素，放到序列的起始位置，然后再从剩余未排序的元素中选择最小（或最大）的元素，放到已排序序列的末尾。依此类推，直到所有元素均排序完毕。</p><p>具体步骤如下：</p><ol><li><strong>初始状态：</strong> 假设待排序的序列有n个元素，将序列分为已排序和未排序两部分。初始时，已排序部分为空，未排序部分包含所有n个元素。</li><li><strong>选择最小元素：</strong> 在未排序部分中选择最小的元素，记其下标为k。</li><li><strong>交换位置：</strong> 将未排序部分中的第一个元素与第2步中选择的最小元素交换位置。此时，已排序部分增加一个元素，未排序部分减少一个元素。</li><li><strong>重复步骤2-3：</strong> 重复执行步骤2和步骤3，直到未排序部分变为空。这样，每一次循环都会找到未排序部分的最小元素，并将其加入已排序部分。</li><li><strong>结束：</strong> 当未排序部分为空时，排序完成。</li></ol><p>选择排序的时间复杂度为O(n^2)，其中n是待排序序列的长度。虽然选择排序相对简单，但对于大型数据集来说，性能较差，因此在实际应用中更常使用其他更高效的排序算法，如快速排序或归并排序。</p></div></div><h1 id="基础程序设计题"><a href="#基础程序设计题" class="headerlink" title="基础程序设计题"></a>基础程序设计题</h1><h2 id="第-9-题"><a href="#第-9-题" class="headerlink" title="第 9 题"></a>第 9 题</h2><p>编写一个程序。实现输入一个小写字母，程序输出它对应的大写字母。 （提示：小写字母的ASCII码值比大些字母大32。）</p><h3 id="第-9-题思路"><a href="#第-9-题思路" class="headerlink" title="第 9 题思路"></a>第 9 题思路</h3><ol><li>接收用户输入</li><li>将小写转换成大写</li><li>输出结果</li></ol><h3 id="第-9-题题解"><a href="#第-9-题题解" class="headerlink" title="第 9 题题解"></a>第 9 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="comment">// 1. 接收用户输入</span></span><br><span class="line">    scanf_s(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="comment">// 2. 将小写转换成大写</span></span><br><span class="line">    <span class="comment">// 3. 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, ch - <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第-9-题思路（字符串版本）"><a href="#第-9-题思路（字符串版本）" class="headerlink" title="第 9 题思路（字符串版本）"></a>第 9 题思路（字符串版本）</h3><div class="note info flat"><p>这是之前将题目会错意了，大家可以当课外看</p></div><ol><li>接收用户输入</li><li>循环字符串</li><li>判断是否为小写字母</li><li>转换成大写</li><li>输出结果</li></ol><h3 id="第-9-题题解（字符串版本）"><a href="#第-9-题题解（字符串版本）" class="headerlink" title="第 9 题题解（字符串版本）"></a>第 9 题题解（字符串版本）</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">基础版本</button><button type="button" class="tab">科技与狠活</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100 <span class="comment">// 定义数组长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str[SIZE];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 接收用户输入</span></span><br><span class="line">gets(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环字符串</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line"><span class="comment">// 3. 判断是否为小写字母</span></span><br><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 4. 转换成大写</span></span><br><span class="line">str[i] -= <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 输出结果</span></span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p>我在原版的基础上，加上了：</p><ol><li>使用 <code>sizeof</code>，动态计算数组长度</li><li>增加用户输入提示</li><li>检测字符串结尾，提前退出循环</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> len; <span class="comment">// 黑科技，计算字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 接收用户输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一段字符串：&quot;</span>);</span><br><span class="line">gets(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环字符串</span></span><br><span class="line">len = <span class="keyword">sizeof</span>(str) / <span class="keyword">sizeof</span>(*str); <span class="comment">// 记不住的话，len = 100 （和字符串数组长度一样就行）</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">break</span>; <span class="comment">// 已经到字符串结尾，直接退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 判断是否为小写字母</span></span><br><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">// 4. 转换成大写</span></span><br><span class="line">str[i] -= <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 输出结果</span></span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><hr><h2 id="第-10-题"><a href="#第-10-题" class="headerlink" title="第 10 题"></a>第 10 题</h2><p>编写一个程序，计算    100 + 101 + 102 + ⋯ + 300 的值。</p><h3 id="第-10-题思路"><a href="#第-10-题思路" class="headerlink" title="第 10 题思路"></a>第 10 题思路</h3><ol><li>定义总和变量</li><li>从 100 循环到 300</li><li>加总和</li><li>输出结果</li></ol><h3 id="第-10-题题解"><a href="#第-10-题题解" class="headerlink" title="第 10 题题解"></a>第 10 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1. 定义总和变量</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 从 100 循环到 300</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">100</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 3. 加总和</span></span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 输出结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>注意：定义 <code>sum</code> 变量时，必须赋初值！</p></div><hr><h2 id="第-11-题"><a href="#第-11-题" class="headerlink" title="第 11 题"></a>第 11 题</h2><p>已知学生成绩（100 分为满分）与等级的对应关系为：</p><div class="table-container"><table><thead><tr><th>成绩（grade）</th><th>等级</th></tr></thead><tbody><tr><td>90 &lt;= grade &lt;= 100</td><td>A</td></tr><tr><td>80 &lt;= grade &lt; 90</td><td>B</td></tr><tr><td>70 &lt;= grade &lt; 80</td><td>C</td></tr><tr><td>60 &lt;= grade &lt; 70</td><td>D</td></tr><tr><td>grade &lt; 60</td><td>E</td></tr></tbody></table></div><p>请你编写一个程序，要求：输入学生成绩，输出学生成绩对应的等级。（提示：使用 switch⋯.case语句）</p><h3 id="第-11-题思路与题解"><a href="#第-11-题思路与题解" class="headerlink" title="第 11 题思路与题解"></a>第 11 题思路与题解</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">switch...case 版本</button><button type="button" class="tab">if...else 版本</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>switch…case 版本</strong></p><ol><li>接收用户输入</li><li>因为是每个档次以 10 分为分水岭，所以直接将分数除 10，得到它的十进制。</li><li>用 <code>switch...case</code> 判断 10 进制</li><li>输出结果</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 接收用户输入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入学生成绩（0-100）：&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 因为是每个档次以 10 分为分水岭，所以直接将分数除 10，得到它的十进制。</span></span><br><span class="line"><span class="comment">// 3. 用 `switch...case` 判断 10 进制</span></span><br><span class="line"><span class="keyword">switch</span> (grade / <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"><span class="comment">// 4. 输出结果</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等级：A\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等级：B\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等级：C\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等级：D\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (grade &gt;= <span class="number">0</span> &amp;&amp; grade &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等级：E\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入无效的成绩\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>if…else 版本</strong></p><ol><li>接收用户输入</li><li>既然它的条件都已经写给你了，何不用 if…else？</li><li>将他的条件拆分成：<code>if (上限 &lt;= grade &amp;&amp; grade &lt; 下限) { ... } eise if ( ... ) { ... } else { ... }</code> 完美解决</li><li>输出结果</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 接收用户输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生成绩（0-100）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;grade);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 既然它的条件都已经写给你了，何不用 if...else？</span></span><br><span class="line">    <span class="comment">// 使用 if-else if 语句判断等级</span></span><br><span class="line">    <span class="keyword">if</span> (grade &gt;= <span class="number">90</span> &amp;&amp; grade &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 输出结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等级：A\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">80</span> &amp;&amp; grade &lt; <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等级：B\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">70</span> &amp;&amp; grade &lt; <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等级：C\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">60</span> &amp;&amp; grade &lt; <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等级：D\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (grade &gt;= <span class="number">0</span> &amp;&amp; grade &lt; <span class="number">60</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等级：E\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入无效的成绩\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h1 id="综合程序设计题"><a href="#综合程序设计题" class="headerlink" title="综合程序设计题"></a>综合程序设计题</h1><h2 id="第-12-题"><a href="#第-12-题" class="headerlink" title="第 12 题"></a>第 12 题</h2><p>输入一个圆半径 <code>r</code>，当 <code>r &gt;＝ 0</code> 时，计算并输出圆的面积和周长，否则，输出提示信息。</p><h3 id="第-12-题思路"><a href="#第-12-题思路" class="headerlink" title="第 12 题思路"></a>第 12 题思路</h3><ol><li>获取用户输入</li><li>判断输入是否合法</li><li>计算面积</li><li>输出结果</li></ol><h3 id="第-12-题题解"><a href="#第-12-题题解" class="headerlink" title="第 12 题题解"></a>第 12 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取用户输入</span></span><br><span class="line">    <span class="type">double</span> r; <span class="comment">// 定义圆半径变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入圆的半径：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;r); <span class="comment">// 通过scanf获取用户输入的半径值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断输入是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 判断半径是否大于等于0</span></span><br><span class="line">        <span class="comment">// 3. 计算面积</span></span><br><span class="line">        <span class="type">double</span> area = PI * r * r; <span class="comment">// 使用圆周率π计算圆的面积</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 输出结果</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;圆的面积为：%lf\n&quot;</span>, area); <span class="comment">// 输出计算得到的圆的面积</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;半径不能为负数\n&quot;</span>); <span class="comment">// 输出提示信息，半径不能为负数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回程序结束状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="第-13-题"><a href="#第-13-题" class="headerlink" title="第 13 题"></a>第 13 题</h2><p>从键盘输入 10 个整数，统计其中正数、负数和零的个数，并在屏幕上输出。</p><h3 id="第-13-题思路"><a href="#第-13-题思路" class="headerlink" title="第 13 题思路"></a>第 13 题思路</h3><ol><li>定义一个整型数组</li><li>获取用户输入</li><li>遍历数组</li><li>判断整数类型</li><li>统计</li><li>输出结果</li></ol><h3 id="第-13-题题解"><a href="#第-13-题题解" class="headerlink" title="第 13 题题解"></a>第 13 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定义一个整型数组</span></span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> positiveCount = <span class="number">0</span>, negativeCount = <span class="number">0</span>, zeroCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取用户输入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个整数：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 4. 判断整数类型</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positiveCount++;  <span class="comment">// 5. 统计正数个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            negativeCount++;  <span class="comment">// 5. 统计负数个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            zeroCount++;  <span class="comment">// 5. 统计零的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正数个数：%d\n&quot;</span>, positiveCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;负数个数：%d\n&quot;</span>, negativeCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;零的个数：%d\n&quot;</span>, zeroCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第-14-题"><a href="#第-14-题" class="headerlink" title="第 14 题"></a>第 14 题</h2><p>编写程序，其中自定义一函数用来判断数组 <code>a[8] = &#123;1，3，4，7，8，9，10，12&#125;</code> 中的每个数组元素是否为素数，输出是否为素数。子函数声明格式为：<code>int prime(int *p)</code>。</p><h3 id="第-14-题思路"><a href="#第-14-题思路" class="headerlink" title="第 14 题思路"></a>第 14 题思路</h3><ol><li><code>int prime(int *p)</code> 函数<ol><li>如果 prime 等于 1 则返回 0（1 不是素数）</li><li>暴力尝试是否能被自身以外的值整除</li></ol></li><li>主函数<ol><li>定义数组</li><li>遍历数组中的值</li><li>调用 <code>prime</code> 函数，判断是否为素数</li><li>输出结果</li></ol></li></ol><h3 id="第-14-题题解"><a href="#第-14-题题解" class="headerlink" title="第 14 题题解"></a>第 14 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数判断素数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 1不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 尝试是否能被自身以外的值整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= *p; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 能被整除，不是素数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 是素数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定义数组</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">8</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;判断数组中的素数：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历数组中的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 3. 调用 prime 函数，判断是否为素数</span></span><br><span class="line">        <span class="keyword">if</span> (prime(&amp;a[i])) &#123;</span><br><span class="line">            <span class="comment">// 4. 输出结果</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 是素数\n&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 不是素数\n&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，<code>prime</code> 函数接受一个整数指针作为参数，判断该整数是否为素数。然后，在 <code>main</code> 函数中，对数组中的每个元素调用 <code>prime</code> 函数，并输出结果。</p><p>在这个程序中，指针起到的作用是允许函数<code>prime</code>直接修改传递给它的数组元素的值。以下是对指针的作用的解释：</p><ol><li><strong>传递数组元素的地址：</strong> 函数 <code>prime</code> 的参数是一个整数指针 <code>int *p</code>，它接受一个整数的地址作为输入。这样，当在 <code>main</code> 函数中调用 <code>prime(&amp;a[i])</code> 时，实际上是将数组元素 <code>a[i]</code> 的地址传递给了 <code>prime</code> 函数。</li><li><strong>通过指针修改数组元素：</strong> 在 <code>prime</code> 函数中，使用解引用操作符 <code>*p</code> 来访问传递进来的整数的值。这允许 <code>prime</code> 函数直接修改 <code>main</code> 函数中数组元素的值。在这个程序中，虽然 <code>prime</code> 函数没有对数组元素的值进行修改，但是通过指针，它具有修改的能力。</li><li><strong>避免数组元素的复制：</strong> 通过传递指针，而不是整数的副本，可以避免在函数调用中进行数组元素的复制。这在处理大型数组时可以提高程序的效率。</li></ol><hr><h2 id="第-15-题"><a href="#第-15-题" class="headerlink" title="第 15 题"></a>第 15 题</h2><p>一个学生具有学号、姓名、3 门课程成绩共 5 个信息。定义结构体变量，调用函数求 3 门课程的平均分。</p><h3 id="第-15-题思路"><a href="#第-15-题思路" class="headerlink" title="第 15 题思路"></a>第 15 题思路</h3><ol><li>定义学生结构体，包含学号、姓名和3门课程成绩</li><li>声明一个函数用于计算三门课程的平均分</li><li>在主函数中定义学生结构体变量，接收用户输入的学生信息和三门课程成绩</li><li>调用函数计算平均分</li><li>输出计算结果</li></ol><h3 id="第-15-题题解"><a href="#第-15-题题解" class="headerlink" title="第 15 题题解"></a>第 15 题题解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义学生结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> studentId;      <span class="comment">// 学号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];      <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">double</span> grades[<span class="number">3</span>];   <span class="comment">// 3门课程成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数用于计算课程平均分</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateAverage</span><span class="params">(<span class="keyword">struct</span> Student student)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义学生结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入学生信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入学生信息：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;student1.studentId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, student1.name);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入三门课程的成绩：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;课程%d成绩：&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;student1.grades[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数计算平均分</span></span><br><span class="line">    <span class="type">double</span> average = calculateAverage(student1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的三门课程平均分为：%lf\n&quot;</span>, student1.name, average);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回程序结束状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：计算课程平均分</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">calculateAverage</span><span class="params">(<span class="keyword">struct</span> Student student)</span> &#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算成绩总和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        sum += student.grades[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算平均分</span></span><br><span class="line">    <span class="type">double</span> average = sum / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观众姥爷赏口饭吃"><a href="#观众姥爷赏口饭吃" class="headerlink" title="观众姥爷赏口饭吃"></a>观众姥爷赏口饭吃</h1><div style="color: red; font-size: 3rem; text-align: center;">教材准备不易，可否打个赏？</div><p><img src="/Gallery/stickers/beggar.jpeg" alt="要个饭" height="128px"/></p><div style="display: flex; justify-content: space-between;"><img src="/Gallery/wallets/WechatPay.jpg" width="60%"/><img src="/Gallery/wallets/Alipay.jpg" width="60%"/></div>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考试题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 9 逻辑回归结合乳癌数据集</title>
      <link href="/2023/45ca5809.html"/>
      <url>/2023/45ca5809.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>乳腺癌是世界上女性中最常见的癌症。它占据了所有癌症病例的25%，仅在2015年就影响了超过210万人。它始于乳房中的细胞开始失控生长。这些细胞通常形成肿瘤，可以通过X射线检查或在乳房区域触摸时感觉到。</p><p>对其检测的关键挑战是如何将肿瘤分类为恶性（癌症）或良性（非癌症）。我们请您完成对使用机器学习（使用SVMs）和威斯康辛州（诊断性）乳腺癌数据集进行肿瘤分类的分析。<sup><a href="#1">[1]</a></sup></p></div><a class="btn-beautify green larger" href="/uploads/@files/datasets/breast-cancer.csv" title="下载乳腺癌数据集"><i class="far fa-hand-point-right"></i><span>下载乳腺癌数据集</span></a> <p>许可证：<a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0: Public Domain</a></p><h1 id="介绍乳腺癌数据集"><a href="#介绍乳腺癌数据集" class="headerlink" title="介绍乳腺癌数据集"></a>介绍乳腺癌数据集</h1><p>现在我们已经掌握了构建用于分类数据集的逻辑回归（Logistics Regression）模型的工具，我们将引入一个新的数据集。</p><p>在乳腺癌数据集中，每个数据点都包含来自乳腺肿块图像的测量数据，以及它是否为癌性。我们的目标是使用这些测量值来预测肿块是否为癌性。</p><p>这个数据集已经<strong>内置在 scikit-learn</strong> 中，因此我们不需要读取 csv 文件。<a href="https://scikit-learn.org/stable/datasets/toy_dataset.html#breast-cancer-wisconsin-diagnostic-dataset">scikit_learn 乳癌数据集官方文档</a></p><p>让我们从加载数据集开始，查看数据及其格式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">cancer_data = load_breast_cancer()</span><br></pre></td></tr></table></figure><p>返回的对象（我们将其存储在 <code>cancer_data</code> 变量中）类似于 Python 字典。我们可以使用 <code>cancer_data.keys()</code> 方法查看可用的键。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(cancer_data.keys())</span><br></pre></td></tr></table></figure><p>我们首先查看 <code>DESCR</code>，其中提供了对数据集的详细描述。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(cancer_data[<span class="string">&#x27;DESCR&#x27;</span>])</span><br></pre></td></tr></table></figure><p>它返回的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.. _breast_cancer_dataset:</span><br><span class="line"></span><br><span class="line">Breast cancer wisconsin (diagnostic) dataset</span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">**Data Set Characteristics:**</span><br><span class="line"></span><br><span class="line">    :Number of Instances: 569</span><br><span class="line"></span><br><span class="line">    :Number of Attributes: 30 numeric, predictive attributes and the class</span><br><span class="line"></span><br><span class="line">    :Attribute Information:</span><br><span class="line">        - radius (mean of distances from center to points on the perimeter)</span><br><span class="line">        - texture (standard deviation of gray-scale values)</span><br><span class="line">        - perimeter</span><br><span class="line">        - area</span><br><span class="line">        - smoothness (local variation in radius lengths)</span><br><span class="line">        - compactness (perimeter^2 / area - 1.0)</span><br><span class="line">        - concavity (severity of concave portions of the contour)</span><br><span class="line">        - concave points (number of concave portions of the contour)</span><br><span class="line">        - symmetry</span><br><span class="line">        - fractal dimension (&quot;coastline approximation&quot; - 1)</span><br><span class="line"></span><br><span class="line">        The mean, standard error, and &quot;worst&quot; or largest (mean of the three</span><br><span class="line">        worst/largest values) of these features were computed for each image,</span><br><span class="line">        resulting in 30 features.  For instance, field 0 is Mean Radius, field</span><br><span class="line">        10 is Radius SE, field 20 is Worst Radius.</span><br><span class="line"></span><br><span class="line">        - class:</span><br><span class="line">                - WDBC-Malignant</span><br><span class="line">                - WDBC-Benign</span><br><span class="line"></span><br><span class="line">    :Summary Statistics:</span><br><span class="line"></span><br><span class="line">    ===================================== ====== ======</span><br><span class="line">                                           Min    Max</span><br><span class="line">    ===================================== ====== ======</span><br><span class="line">    radius (mean):                        6.981  28.11</span><br><span class="line">    texture (mean):                       9.71   39.28</span><br><span class="line">    perimeter (mean):                     43.79  188.5</span><br><span class="line">    area (mean):                          143.5  2501.0</span><br><span class="line">    smoothness (mean):                    0.053  0.163</span><br><span class="line">    compactness (mean):                   0.019  0.345</span><br><span class="line">    concavity (mean):                     0.0    0.427</span><br><span class="line">    concave points (mean):                0.0    0.201</span><br><span class="line">    symmetry (mean):                      0.106  0.304</span><br><span class="line">    fractal dimension (mean):             0.05   0.097</span><br><span class="line">    radius (standard error):              0.112  2.873</span><br><span class="line">    texture (standard error):             0.36   4.885</span><br><span class="line">    perimeter (standard error):           0.757  21.98</span><br><span class="line">    area (standard error):                6.802  542.2</span><br><span class="line">    smoothness (standard error):          0.002  0.031</span><br><span class="line">    compactness (standard error):         0.002  0.135</span><br><span class="line">    concavity (standard error):           0.0    0.396</span><br><span class="line">    concave points (standard error):      0.0    0.053</span><br><span class="line">    symmetry (standard error):            0.008  0.079</span><br><span class="line">    fractal dimension (standard error):   0.001  0.03</span><br><span class="line">    radius (worst):                       7.93   36.04</span><br><span class="line">    texture (worst):                      12.02  49.54</span><br><span class="line">    perimeter (worst):                    50.41  251.2</span><br><span class="line">    area (worst):                         185.2  4254.0</span><br><span class="line">    smoothness (worst):                   0.071  0.223</span><br><span class="line">    compactness (worst):                  0.027  1.058</span><br><span class="line">    concavity (worst):                    0.0    1.252</span><br><span class="line">    concave points (worst):               0.0    0.291</span><br><span class="line">    symmetry (worst):                     0.156  0.664</span><br><span class="line">    fractal dimension (worst):            0.055  0.208</span><br><span class="line">    ===================================== ====== ======</span><br><span class="line"></span><br><span class="line">    :Missing Attribute Values: None</span><br><span class="line"></span><br><span class="line">    :Class Distribution: 212 - Malignant, 357 - Benign</span><br><span class="line"></span><br><span class="line">    :Creator:  Dr. William H. Wolberg, W. Nick Street, Olvi L. Mangasarian</span><br><span class="line"></span><br><span class="line">    :Donor: Nick Street</span><br><span class="line"></span><br><span class="line">    :Date: November, 1995</span><br><span class="line"></span><br><span class="line">This is a copy of UCI ML Breast Cancer Wisconsin (Diagnostic) datasets.</span><br><span class="line">https://goo.gl/U2Uwz2</span><br><span class="line"></span><br><span class="line">Features are computed from a digitized image of a fine needle</span><br><span class="line">aspirate (FNA) of a breast mass.  They describe</span><br><span class="line">characteristics of the cell nuclei present in the image.</span><br><span class="line"></span><br><span class="line">Separating plane described above was obtained using</span><br><span class="line">Multisurface Method-Tree (MSM-T) [K. P. Bennett, &quot;Decision Tree</span><br><span class="line">Construction Via Linear Programming.&quot; Proceedings of the 4th</span><br><span class="line">Midwest Artificial Intelligence and Cognitive Science Society,</span><br><span class="line">pp. 97-101, 1992], a classification method which uses linear</span><br><span class="line">programming to construct a decision tree.  Relevant features</span><br><span class="line">were selected using an exhaustive search in the space of 1-4</span><br><span class="line">features and 1-3 separating planes.</span><br><span class="line"></span><br><span class="line">The actual linear program used to obtain the separating plane</span><br><span class="line">in the 3-dimensional space is that described in:</span><br><span class="line">[K. P. Bennett and O. L. Mangasarian: &quot;Robust Linear</span><br><span class="line">Programming Discrimination of Two Linearly Inseparable Sets&quot;,</span><br><span class="line">Optimization Methods and Software 1, 1992, 23-34].</span><br><span class="line"></span><br><span class="line">This database is also available through the UW CS ftp server:</span><br><span class="line"></span><br><span class="line">ftp ftp.cs.wisc.edu</span><br><span class="line">cd math-prog/cpo-dataset/machine-learn/WDBC/</span><br><span class="line"></span><br><span class="line">|details-start|</span><br><span class="line">**References**</span><br><span class="line">|details-split|</span><br><span class="line"></span><br><span class="line">- W.N. Street, W.H. Wolberg and O.L. Mangasarian. Nuclear feature extraction </span><br><span class="line">  for breast tumor diagnosis. IS&amp;T/SPIE 1993 International Symposium on </span><br><span class="line">  Electronic Imaging: Science and Technology, volume 1905, pages 861-870,</span><br><span class="line">  San Jose, CA, 1993.</span><br><span class="line">- O.L. Mangasarian, W.N. Street and W.H. Wolberg. Breast cancer diagnosis and </span><br><span class="line">  prognosis via linear programming. Operations Research, 43(4), pages 570-577, </span><br><span class="line">  July-August 1995.</span><br><span class="line">- W.H. Wolberg, W.N. Street, and O.L. Mangasarian. Machine learning techniques</span><br><span class="line">  to diagnose breast cancer from fine-needle aspirates. Cancer Letters 77 (1994) </span><br><span class="line">  163-171.</span><br><span class="line"></span><br><span class="line">|details-end|</span><br></pre></td></tr></table></figure><p>我们可以看到有 30 个特征、569 个数据点，目标是恶性（癌性）或良性（非癌性）。对于每个数据点，我们有乳腺肿块的测量值（半径、质地、周长等）。对于这 10 个测量值，计算了多个值，因此我们有均值、标准误差和最差值。这导致了 10 * 3 或 30 个总特征。</p><div class="note info flat"><p>在乳腺癌数据集中，有一些特征是基于其他列计算出来的。确定要计算哪些附加特征的过程称为<strong>特征工程（Feature engineering）</strong>。</p></div><h2 id="乳癌数据集导入代码"><a href="#乳癌数据集导入代码" class="headerlink" title="乳癌数据集导入代码"></a>乳癌数据集导入代码</h2><p>可以在计算机中运行此代码以查看结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer_data = load_breast_cancer()</span><br><span class="line"><span class="built_in">print</span>(cancer_data.keys())</span><br><span class="line"><span class="built_in">print</span>(cancer_data[<span class="string">&#x27;DESCR&#x27;</span>])</span><br></pre></td></tr></table></figure><h1 id="将数据加载到-Pandas-中"><a href="#将数据加载到-Pandas-中" class="headerlink" title="将数据加载到 Pandas 中"></a>将数据加载到 Pandas 中</h1><p>让我们从 <code>cancer_data</code> 对象中提取特征和目标数据。</p><p>首先，特征数据存储在 <code>data</code> 键中。当我们查看它时，我们看到它是一个具有 569 行和 30 列的 numpy 数组。这是因为我们有 569 个数据点和 30 个特征。我们可以使用 <code>shape</code> 属性来验证这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer_data[<span class="string">&#x27;data&#x27;</span>].shape</span><br></pre></td></tr></table></figure><p>为了将其放入 Pandas DataFrame 使其更易读，我们需要列名，这些数据将存储在 <code>feature_names</code> 键中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer_data[<span class="string">&#x27;feature_names&#x27;</span>]</span><br></pre></td></tr></table></figure><p>现在我们可以使用所有特征数据创建一个 Pandas DataFrame。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(cancer_data[<span class="string">&#x27;data&#x27;</span>], columns=cancer_data[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><p>返回值如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mean radius  mean texture  mean perimeter  mean area  mean smoothness  \</span><br><span class="line">0        17.99         10.38          122.80     1001.0          0.11840   </span><br><span class="line">1        20.57         17.77          132.90     1326.0          0.08474   </span><br><span class="line">2        19.69         21.25          130.00     1203.0          0.10960   </span><br><span class="line">3        11.42         20.38           77.58      386.1          0.14250   </span><br><span class="line">4        20.29         14.34          135.10     1297.0          0.10030   </span><br><span class="line"></span><br><span class="line">   mean compactness  mean concavity  mean concave points  mean symmetry  \</span><br><span class="line">0           0.27760          0.3001              0.14710         0.2419   </span><br><span class="line">1           0.07864          0.0869              0.07017         0.1812   </span><br><span class="line">2           0.15990          0.1974              0.12790         0.2069   </span><br><span class="line">3           0.28390          0.2414              0.10520         0.2597   </span><br><span class="line">4           0.13280          0.1980              0.10430         0.1809   </span><br><span class="line"></span><br><span class="line">   mean fractal dimension  ...  worst radius  worst texture  worst perimeter  \</span><br><span class="line">0                 0.07871  ...         25.38          17.33           184.60   </span><br><span class="line">1                 0.05667  ...         24.99          23.41           158.80   </span><br><span class="line">2                 0.05999  ...         23.57          25.53           152.50   </span><br><span class="line">3                 0.09744  ...         14.91          26.50            98.87   </span><br><span class="line">4                 0.05883  ...         22.54          16.67           152.20   </span><br><span class="line"></span><br><span class="line">   worst area  worst smoothness  worst compactness  worst concavity  \</span><br><span class="line">0      2019.0            0.1622             0.6656           0.7119   </span><br><span class="line">1      1956.0            0.1238             0.1866           0.2416   </span><br><span class="line">2      1709.0            0.1444             0.4245           0.4504   </span><br><span class="line">3       567.7            0.2098             0.8663           0.6869   </span><br><span class="line">4      1575.0            0.1374             0.2050           0.4000   </span><br><span class="line"></span><br><span class="line">   worst concave points  worst symmetry  worst fractal dimension  </span><br><span class="line">0                0.2654          0.4601                  0.11890  </span><br><span class="line">1                0.1860          0.2750                  0.08902  </span><br><span class="line">2                0.2430          0.3613                  0.08758  </span><br><span class="line">3                0.2575          0.6638                  0.17300  </span><br><span class="line">4                0.1625          0.2364                  0.07678  </span><br></pre></td></tr></table></figure><p>我们可以看到 DataFrame 中有 30 列，因为我们有 30 个特征。我们使用了 <code>head</code> 方法，所以我们的结果只有 5 个数据点。</p><p>我们仍然需要将目标数据放入我们的 DataFrame 中，可以在 <code>target</code> 键中找到。我们可以看到目标是一个由 1 和 0 组成的一维 numpy 数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer_data[<span class="string">&#x27;target&#x27;</span>]</span><br></pre></td></tr></table></figure><p>如果我们查看数组的形状，我们会看到它是一个具有 569 个值的一维数组（这就是我们有多少数据点）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer_data[<span class="string">&#x27;target&#x27;</span>].shape</span><br></pre></td></tr></table></figure><p>为了解释这些1和0，我们需要知道1或0表示良性或恶性。我们可以使用 <code>target_names</code> 得到这一数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cancer_data[<span class="string">&#x27;target_names&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这给出了数组[‘malignant’, ‘benign’]，告诉我们 0 表示恶性，1 表示良性。让我们将这些数据添加到 Pandas DataFrame 中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;target&#x27;</span>] = cancer_data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><h2 id="将数据加载到-Pandas-中的完整代码"><a href="#将数据加载到-Pandas-中的完整代码" class="headerlink" title="将数据加载到 Pandas 中的完整代码"></a>将数据加载到 Pandas 中的完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"></span><br><span class="line">cancer_data = load_breast_cancer()</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(cancer_data[<span class="string">&#x27;data&#x27;</span>], columns=cancer_data[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;target&#x27;</span>] = cancer_data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><div class="note info flat"><p>在将数据加载到 Pandas 中时，最重要的就是仔细检查是否正确解释了布尔列或其他目标值。</p></div><h1 id="构建逻辑回归（Logistic-Regression）模型"><a href="#构建逻辑回归（Logistic-Regression）模型" class="headerlink" title="构建逻辑回归（Logistic Regression）模型"></a>构建逻辑回归（Logistic Regression）模型</h1><p>现在我们已经查看了我们的数据并将其整理成了一个舒适的格式，现在我们可以构建我们的特征矩阵 X 和目标数组 y，以便构建逻辑回归模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = df[cancer_data.feature_names].values</span><br><span class="line">y = df[<span class="string">&#x27;target&#x27;</span>].values</span><br></pre></td></tr></table></figure><p>现在我们创建一个逻辑回归对象，并使用 fit 方法构建模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>别忘了导包！</p></div><p>当我们运行这段代码时，会得到一个收敛警告 (Convergence Warning)。这意味着模型需要更多时间来找到最优解。一种选择是增加迭代次数。您还可以切换到另一个求解器（solver），这就是我们将要做的。求解器是模型用来找到线性方程的算法。您可以在<a href="https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression">逻辑回归文档</a>中看到<a href="https://scikit-learn.org/stable/modules/linear_model.html#solvers">可能的求解器</a>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression(solver=<span class="string">&#x27;liblinear&#x27;</span>)</span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><p>让我们看看模型对数据集中第一个数据点的预测。回想一下，<code>predict</code> 方法接受一个二维数组，因此我们必须将数据点放入列表中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.predict([X[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p>因此，模型预测第一个数据点是良性的。</p><p>为了查看模型在整个数据集上的表现如何，我们使用 <code>score</code> 方法来查看模型的准确性。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.score(X, y)</span><br></pre></td></tr></table></figure><p>我们看到模型正确预测了 96% 的数据点。</p><div class="note info flat"><p>有了我们开发的工具，我们可以为任何分类数据集构建模型。</p></div><h2 id="构建逻辑回归模型的完整代码"><a href="#构建逻辑回归模型的完整代码" class="headerlink" title="构建逻辑回归模型的完整代码"></a>构建逻辑回归模型的完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">cancer_data = load_breast_cancer()</span><br><span class="line">df = pd.DataFrame(cancer_data[<span class="string">&#x27;data&#x27;</span>], columns=cancer_data[<span class="string">&#x27;feature_names&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;target&#x27;</span>] = cancer_data[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"></span><br><span class="line">X = df[cancer_data.feature_names].values</span><br><span class="line">y = df[<span class="string">&#x27;target&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model = LogisticRegression(solver=<span class="string">&#x27;liblinear&#x27;</span>)</span><br><span class="line">model.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;prediction for datapoint 0:&quot;</span>, model.predict([X[<span class="number">0</span>]]))</span><br><span class="line"><span class="built_in">print</span>(model.score(X, y))</span><br></pre></td></tr></table></figure><h1 id="引文"><a href="#引文" class="headerlink" title="引文"></a>引文</h1><p><a id="1">[1]</a> <a href="https://www.kaggle.com/datasets/yasserh/breast-cancer-dataset">Breast Cancer Dataset | Binary Classification Prediction for type of Breast Cancer - Kaggle</a></p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> 乳癌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（8）构建逻辑回归模型</title>
      <link href="/2023/23d836ce.html"/>
      <url>/2023/23d836ce.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Scikit-learn-是什么"><a href="#Scikit-learn-是什么" class="headerlink" title="Scikit-learn 是什么"></a>Scikit-learn 是什么</h1><p>既然我们已经建立了逻辑回归（Logistic Regression）的基础，让我们深入一些代码来构建一个模型。</p><p>为此，我们将介绍一个名为 scikit-learn 的 Python 模块。Scikit-learn，通常缩写为 sklearn ，是我们的科学工具包。</p><p>所有基本的机器学习算法都已经在 sklearn 中实现。我们将看到，只需几行代码，我们就可以构建几种不同的强大模型。</p><div class="note warning flat"><p>请注意，scikit-learn 正在不断更新。如果您的计算机上安装的模块版本略有不同，一切仍将正常工作，但您可能会看到与本文中略有不同的值。</p></div><div class="note info flat"><p>Scikit-learn 是 Python 中文档最详尽的模块之一。您可以在 <a href="https://scikit-learn.org">scikit-learn.org</a> 上找到大量的代码示例。</p></div><h1 id="使用-Pandas-准备数据"><a href="#使用-Pandas-准备数据" class="headerlink" title="使用 Pandas 准备数据"></a>使用 Pandas 准备数据</h1><p>在我们使用 sklearn 构建模型之前，我们需要使用 Pandas 准备数据。让我们回到完整的数据集并回顾一下 Pandas 命令。</p><p>这是一个包含所有列的 Pandas DataFrame 数据：</p><div class="table-container"><table><thead><tr><th></th><th>Survived</th><th>Pclass</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Fare</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>3</td><td>male</td><td>22.0</td><td>1</td><td>0</td><td>7.2500</td></tr><tr><td>1</td><td>1</td><td>1</td><td>female</td><td>38.0</td><td>1</td><td>0</td><td>71.2833</td></tr><tr><td>2</td><td>1</td><td>3</td><td>female</td><td>26.0</td><td>0</td><td>0</td><td>7.9250</td></tr><tr><td>3</td><td>1</td><td>1</td><td>female</td><td>35.0</td><td>1</td><td>0</td><td>53.1000</td></tr><tr><td>4</td><td>0</td><td>3</td><td>male</td><td>35.0</td><td>0</td><td>0</td><td>8.0500</td></tr></tbody></table></div><div class="note info flat"><p>注：SibSp 是 Sibling / Spouses；Parch 是 Parents / Children</p></div><p>首先，我们需要使所有列变成数值型。回顾一下如何为性别创建布尔列。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>现在，让我们将所有特征（features）创建一个名为 <code>X</code> 的 numpy 数组。我们首先选择我们感兴趣的所有列，然后使用 <code>values</code> 方法将其转换为 <code>numpy</code> 数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br></pre></td></tr></table></figure><p>现在让我们取目标（targets, Survived 列）并将其存储在变量 <code>y</code> 中。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br></pre></td></tr></table></figure><div class="note info flat"><p>通常，我们习惯将特征的2D数组称为X，将目标值的1D数组称为y。</p></div><h1 id="使用-Sklearn-构建逻辑回归模型"><a href="#使用-Sklearn-构建逻辑回归模型" class="headerlink" title="使用 Sklearn 构建逻辑回归模型"></a>使用 Sklearn 构建逻辑回归模型</h1><p>首先，我们需要从 skikit-learn 包中导入逻辑回归模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br></pre></td></tr></table></figure><p>所有 sklearn 中的模型都被构建成了 Python 类，因此我们需要实例化这个类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = LogisticRegression()</span><br></pre></td></tr></table></figure><p>现在，我们可以使用之前准备的数据来训练模型。使用 <code>fit</code> 函数来构建模型，他接受两个参数：X（特征，是一个 2D numpy 数组），y（目标，是一个 1D numpy 数组）。</p><p>一切从简，我们使用 Fare 和 Age 作为特征来构建模型，首先我们定义特征和目标数组：</p><div class="note danger flat"><p>由于我们提供的数据有空值，所以需要对其进行预处理（Preprocessing），这里我们将年龄的空值填补为年龄的平均值，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = df[[<span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>别忘了加上 <code>values</code> 属性来获取 numpy array！</p></div><p>现在，使用 <code>fit</code> 来构建模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><p>拟合模型（Fitting the model）意味着使用数据选择最佳拟合线（a line of best fit）。我们可以使用 <code>coef_</code> 和 <code>intercept_</code> 属性来查看系数（coefficients）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.coef_, model.intercept_)</span><br></pre></td></tr></table></figure><p>得到的返回值为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[ 0.01619443 -0.01738676]] [-0.45768136]</span><br></pre></td></tr></table></figure><p>这个数据意味着我们的线性方程为：</p><script type="math/tex; mode=display">\begin{aligned}  0 &= ax + by + c \\    &= 0.01619443x + -0.01738676y + -0.45768136\end{aligned}</script><p>所以我们可以再次调用 matplotlib 进行画图，你可以看到它在分割黄色和紫色点方面做得还不错（但不是很好）。通过仅使用2个特征，我们有点自限，所以在接下来的部分中，我们将使用所有特征。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取系数和截距</span></span><br><span class="line">coef = model.coef_[<span class="number">0</span>]</span><br><span class="line">intercept = model.intercept_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算决策边界上的两个点</span></span><br><span class="line">x_values = np.array([<span class="number">25</span>, <span class="number">120</span>])</span><br><span class="line">y_values = (coef[<span class="number">0</span>] * x_values + intercept) / -coef[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(df[<span class="string">&#x27;Fare&#x27;</span>], df[<span class="string">&#x27;Age&#x27;</span>], c=df[<span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">plt.plot(x_values, y_values)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20calculated%20boundary.jpg"/></p><div class="note info flat"><p>记住不同 sklearn 模型的导入语句可能有点困难。如果记不住，只需查看 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html">scikit-learn 文档</a>。</p></div><h2 id="构建逻辑回归模型完整源码"><a href="#构建逻辑回归模型完整源码" class="headerlink" title="构建逻辑回归模型完整源码"></a>构建逻辑回归模型完整源码</h2><p>今天的完整源码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填补缺失值</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取系数和截距</span></span><br><span class="line">coef = model.coef_[<span class="number">0</span>]</span><br><span class="line">intercept = model.intercept_[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算决策边界上的两个点</span></span><br><span class="line">x_values = np.array([<span class="number">25</span>, <span class="number">120</span>])</span><br><span class="line">y_values = (coef[<span class="number">0</span>] * x_values + intercept) / -coef[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(df[<span class="string">&#x27;Fare&#x27;</span>], df[<span class="string">&#x27;Age&#x27;</span>], c=df[<span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">plt.plot(x_values, y_values)</span><br></pre></td></tr></table></figure><h1 id="使用我们构建的模型进行预测"><a href="#使用我们构建的模型进行预测" class="headerlink" title="使用我们构建的模型进行预测"></a>使用我们构建的模型进行预测</h1><p>在先前的部分中，我们只使用了两个特征，这实际上对我们的模型造成了一些限制，因此让我们使用所有特征重新构建模型。在这里，我们需要用到 male 字段，同时也要填补 Age 字段的缺省值：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model.fit(X, y)</span><br></pre></td></tr></table></figure><p>现在，我们可以用 <code>predict(X)</code> 函数进行预测。数据集中的第一位乘客是：</p><div class="table-container"><table><thead><tr><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>3</td><td>“Braund, Mr. Owen Harris”</td><td>male</td><td>22</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.25</td><td></td><td>S</td></tr></tbody></table></div><p>其中我们要用到的数据为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="literal">True</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7.25</span>]</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Survived</th><th>Pclass</th><th>male</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Fare</th></tr></thead><tbody><tr><td>0</td><td>3</td><td>True</td><td>22</td><td>1</td><td>0</td><td>7.25</td></tr></tbody></table></div><p>这意味着该乘客位于 Pclass 3，男性，年龄22岁，有 1 名兄弟/配偶，0 名父母/子女，支付 7.25 美元。让我们看看模型对于这位乘客的预测结果。请注意，即使有一个数据点，predict 方法也需要一个二维的 numpy 数组并返回一个一维的 numpy 数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.predict([[<span class="number">3</span>, <span class="literal">True</span>, <span class="number">22.0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7.25</span>]])) </span><br></pre></td></tr></table></figure><p>执行结果为 <code>[0]</code>。意味着模型预测的这位乘客并没有生还。</p><p>让我们看看模型对前5行数据的预测结果，并将其与目标数组进行比较。我们使用 <code>X[:5]</code> 获取前5行数据，使用 <code>y[:5]</code> 获取目标的前5个值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.predict(X[:<span class="number">5</span>])) </span><br><span class="line"><span class="comment"># [0 1 1 1 0]</span></span><br><span class="line"><span class="built_in">print</span>(y[:<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># [0 1 1 1 0]</span></span><br></pre></td></tr></table></figure><p>我们看到它全部预测正确！</p><div class="note info flat"><p>事实上，训练模型我们需要将训练集与测试集分开，这就是为什么我们同时上传了 <a href="/uploads/@files/datasets/titanic/train.csv" download>训练集</a> 和 <a href="/uploads/@files/datasets/titanic/test.csv" download>测试集</a></p><p><code>predict</code> 方法返回一个包含 1 和 0 的数组，其中 1 表示模型预测乘客生还，0 表示模型预测乘客没有生还。</p></div><h2 id="使用模型进行预测的完整代码"><a href="#使用模型进行预测的完整代码" class="headerlink" title="使用模型进行预测的完整代码"></a>使用模型进行预测的完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(model.predict([[<span class="number">3</span>, <span class="literal">True</span>, <span class="number">22.0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7.25</span>]])) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测数据前五个值</span></span><br><span class="line"><span class="built_in">print</span>(model.predict(X[:<span class="number">5</span>])) </span><br><span class="line"><span class="comment"># [0 1 1 1 0]</span></span><br><span class="line"><span class="built_in">print</span>(y[:<span class="number">5</span>]) </span><br><span class="line"><span class="comment"># [0 1 1 1 0]</span></span><br></pre></td></tr></table></figure><h1 id="评估模型的性能"><a href="#评估模型的性能" class="headerlink" title="评估模型的性能"></a>评估模型的性能</h1><p>通过计算模型正确预测的数据点数量，我们可以了解模型的表现好坏。这被称为准确率分数。</p><p>让我们创建一个包含预测的y值的数组。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_pred = model.predict(X)</span><br></pre></td></tr></table></figure><p>然后创建一个布尔值数组 <code>y == y_pred</code>，表示我们的模型是否正确预测了每个乘客。要获取其中为真的数量，我们可以使用 numpy 的 sum 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((y == y_pred).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>返回值为：711，这说明在 891 个数据点中，模型对其中的 711 个数据点进行了正确的预测。</p><p>为了得到百分比，我们将其除以总乘客数。我们使用 <code>shape</code> 属性获取总乘客数 <code>y.shape[0]</code>。计算准确性的分数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((y == y_pred).<span class="built_in">sum</span>() / y.shape[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 0.797979797979798</span></span><br></pre></td></tr></table></figure><p>因此，模型的准确性为 79%。换句话说，模型在 79% 的数据点上做出了正确的预测。</p><p>这是一个足够常见的计算，sklearn 已经为我们实现了它。因此，我们可以使用 <code>score</code> 方法得到相同的结果。<code>score</code> 方法使用模型对 X 进行预测，计算匹配 y 的百分比。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.score(X, y))</span><br></pre></td></tr></table></figure><p>通过这种替代方法计算准确性，我们得到相同的值，79%。</p><h2 id="评估模型性能的完整代码"><a href="#评估模型性能的完整代码" class="headerlink" title="评估模型性能的完整代码"></a>评估模型性能的完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>].fillna(df[<span class="string">&#x27;Age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>]].values</span><br><span class="line">y = df[<span class="string">&#x27;Survived&#x27;</span>].values</span><br><span class="line"></span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((y == y_pred).<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>((y == y_pred).<span class="built_in">sum</span>() / y.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以替换计算分数的公式</span></span><br><span class="line"><span class="built_in">print</span>(model.score(X, y))</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>鉴于以下代码和输出，模型的准确性是多少？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model.predict(X))</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 0 0 0 1]</span><br><span class="line">[1 1 0 0 0]</span><br></pre></td></tr></table></figure></p><ul><li>60%</li><li>20%</li><li>80%</li><li>40%</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>在给定的代码和输出中，模型的准确度可以通过比较预测值与实际值来计算。让我们统计正确预测的数量：</p><script type="math/tex; mode=display">\text{正确的预测} = 3 \\\text{总数居点} = 5 \\\begin{aligned}  \text{准确度} &= \frac{\text{正确的预测}}{\text{总数居点}} \times 100\% \\               &= \frac{3}{5} \times 100\% \\               &= 60\%\end{aligned}</script><p>因此，正确答案是 $60%$。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> scikit-learn </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（7）逻辑回归模型</title>
      <link href="/2023/6b4ae084.html"/>
      <url>/2023/6b4ae084.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="生存的概率"><a href="#生存的概率" class="headerlink" title="生存的概率"></a>生存的概率</h1><p>为了确定最佳的分割数据的直线，我们需要有一种评分直线的方法。首先，让我们看一个单独的数据点。</p><p>理想情况下，如果数据点是一个幸存的乘客，它应该在直线的右侧，并且离直线很远。如果它是一个未幸存的乘客的数据点，它应该在直线的左侧远离直线。它离直线越远，我们越有信心它在正确的一侧。</p><p>对于每个数据点，我们将有一个介于 0 和 1 之间的分数。我们可以将其视为乘客幸存的概率。如果值接近 0，该点将远离直线的左侧，这意味着我们有信心该乘客未幸存。如果值接近 1，该点将远离直线的右侧，这意味着我们有信心该乘客幸存。值为 0.5 意味着该点正好落在直线上，我们不确定乘客是否幸存。</p><p>下面是计算这个分数的方程，尽管对它的直观理解远比实际方程重要。</p><p>回顾直线的方程，$ 0 = ax + by + c $ 其中 $x$ 是票价，$y$ 是年龄，$a$、$b$ 和 $c$ 是我们控制的系数。数 $e$ 是常熟，约为 2.71828</p><script type="math/tex; mode=display">\frac{1}{1 + e^{-(ax + by + c)}}</script><p>这个函数被称为 sigmoid</p><div class="note info flat"><p>逻辑回归不仅提供了一个预测（幸存或否），还提供了一个概率（这个人幸存的概率为 80%）。</p></div><h1 id="似然性-Likelihood"><a href="#似然性-Likelihood" class="headerlink" title="似然性 Likelihood"></a>似然性 Likelihood</h1><details class="toggle" ><summary class="toggle-button" style="">这段有点生涩难懂，放上英文原文方便学习</summary><div class="toggle-content"><p>To calculate how good our line is, we need to score whether our predictions are correct. Ideally if we predict with a high probability that a passenger survives (meaning the datapoint is far to the right of the line), then that passenger actually survives.</p><p>So we’ll get rewarded when we predict something correctly and penalized if we predict something incorrectly.</p><p>Here’s the <strong>likelihood</strong> equation. Though again, the intuition is more important than the equation.</p><script type="math/tex; mode=display">\text{likelihood} = \begin{cases}  p      & \text{if passenger survived} \\  1 - p  & \text{if passenger didn't survive}\end{cases}</script><p>Here p is the predicted probability of surviving from the previous part.</p><p>The likelihood will be a value between 0 and 1. The higher the value, the better our line is.</p><p>Let’s look at a couple possibilities:</p><ul><li>If the predicted probability p is 0.25 and the passenger didn’t survive, we get a score of 0.75 (good).</li><li>If the predicted probability p is 0.25 and the passenger survived, we get a score of 0.25 (bad).</li></ul><p>We multiply all the individual scores for each datapoint together to get a score for our line. Thus we can compare different lines to determine the best one.</p><p>Let’s say for ease of computation that we have 4 datapoints.</p><div class="table-container"><table><thead><tr><th>Survived or not?</th><th>Predicted probability</th><th>Score</th></tr></thead><tbody><tr><td>Survived</td><td>0.25</td><td>0.25</td></tr><tr><td>Didn’t Survive</td><td>0.25</td><td>0.75</td></tr><tr><td>Survived</td><td>0.6</td><td>0.6</td></tr><tr><td>Didn’t Survive</td><td>0.2</td><td>0.8</td></tr></tbody></table></div><p>We get the total score by multiplying the four scores together:</p><script type="math/tex; mode=display">0.25 * 0.75 * 0.6 * 0.8 = 0.09</script><p>The value is always going to be really small since it is the likelihood that our model predicts everything perfectly. A perfect model would have a predicted probability of 1 for all positive cases and 0 for all negative cases.</p><div class="note info flat"><p>The likelihood is how we score and compare possible choices of a best fit line.</p></div></div></details><p>为了计算我们定义的直线有多好（实用）。我们需要评估我们的预测是否正确。理想情况下，如果我们以很高的概率预测某位乘客幸存（即数据点远离直线的右侧），那么该乘客实际上会幸存。</p><p>因此，当我们正确预测时，我们将获得奖励；如果我们错误预测，我们将受到惩罚。这是似然性（Likelihood）方程。尽管再次强调，直觉比方程更重要。</p><script type="math/tex; mode=display">\text{likelihood} = \begin{cases}  p      & \text{if passenger survived} \\  1 - p  & \text{if passenger didn't survive}\end{cases}</script><p>这里的 $p$ 是从之前部分预测的幸存概率。</p><p>似然性将是一个介于 0 和 1 之间的值。该值越高，表示我们的直线定义的越完美。</p><p>让我们看以下几种可能性：</p><ul><li>如果预测的概率 $p$ 是 0.25，而乘客没有幸存，我们得到的分数是 0.75（好的）。</li><li>如果预测的概率 $p$ 是 0.25，而乘客幸存了，我们得到的分数是 0.25（不好的）。</li></ul><p>我们将每个数据点的各个分数相乘，得到我们直线的分数。因此，我们可以比较不同的直线，确定最佳直线。</p><p>假设为了计算方便，我们有 4 个数据点：</p><div class="table-container"><table><thead><tr><th>Survived or not?</th><th>Predicted probability</th><th>Score</th></tr></thead><tbody><tr><td>Survived</td><td>0.25</td><td>0.25</td></tr><tr><td>Didn’t Survive</td><td>0.25</td><td>0.75</td></tr><tr><td>Survived</td><td>0.6</td><td>0.6</td></tr><tr><td>Didn’t Survive</td><td>0.2</td><td>0.8</td></tr></tbody></table></div><script type="math/tex; mode=display">0.25 * 0.75 * 0.6 * 0.8 = 0.09</script><p>该值总是会非常小，因为它是我们的模型完美预测所有情况的可能性。一个完美的模型对于所有正类别的情况都会有预测概率为 1，对于所有负类别的情况都会有预测概率为 0。</p><div class="note info flat"><p>似然性是我们对最佳拟合直线的可能选择进行评分和比较的方式。</p></div><h2 id="似然性总结"><a href="#似然性总结" class="headerlink" title="似然性总结"></a>似然性总结</h2><p>总结一下，如果一个乘客幸存，将相同的 $p$ 包含在所有乘客得分的乘法中；如果没有幸存，将 $(1-p)$ 包含在所有乘客得分的乘法中。概率 $p$ 表示幸存的预测分数。</p><ul><li>如果乘客幸存：（$p$ - 应该更高），如果我们预测的 $p$ 更高，那就是正确的，所以将这个更高的 $p$ 直接包含在其中；或者如果我们预测的 $p$ 更低，那就是不正确的，所以将这个更低的 $p$ 直接包含在其中。</li><li>如果乘客没有幸存：（$p$ - 应该更低），如果我们预测的 $p$ 更高，那就是不正确的，所以通过简单地取 $(1-p)$ 来对这个更高的 $p$ 进行惩罚，以将其切换为更低的值；或者如果我们预测的 $p$ 更低，那就是正确的，但由于 $p$ 更低，我们希望奖励这一点，所以通过进行 $(1-p)$ 将这个更低的 $p$ 切换为更高的值。</li></ul><h2 id="似然性练习"><a href="#似然性练习" class="headerlink" title="似然性练习"></a>似然性练习</h2><p>如果预测的概率为 0.75 但是乘客没幸存，则似然性的分数为？</p><ul><li>A. 0</li><li>B. 0.5</li><li>C. 0.25</li><li>D. 0.75</li><li>E. 1</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>答案是：C =&gt; 0.25</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>步骤 1：找出似然性（或预测概率）。在这里是 0.75。</li><li>步骤 2：根据预测概率，该人应该幸存。0.75 远高于 0.5 或 0.25。</li><li>步骤 3：数据表明该人没有幸存，因此我们需要惩罚模型，但如何做呢？</li><li>步骤 4：为了惩罚，将预测的概率从 1 中减去，这里将变为 1 - 0.75 = 0.25。</li><li>步骤 5：（直觉）这意味着 “亲爱的模型，我给你的分数较低，因为你预测的概率是错误的，请在下次注意”。</li></ul></div></div><hr><p>我们已经使用了逻辑回归（Logistic Regression）来找到一条分隔泰坦尼克号数据集的线。在以下哪个预测概率值中，乘客被预测为幸存，数据点离分隔线最远？</p><ul><li>0.6</li><li>0.5</li><li>0.9</li><li>0.75</li><li>0.25</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>正确答案是 0.9，大于 0.5 且接近 1 的任何值都是可能生还，小于 0.5 的值表示可能罹难… 明智地选择你的答案！</p></div></div><hr><p>如果我们预测乘客有 0.8 的生存几率，而乘客确实生存了，那么可能性（Likelihood）是 0.8。如果我们预测乘客有 0.6 的生存几率，而乘客未能生存，那么可能性（Likelihood）是多少？</p><ul><li>0.6</li><li>0.8</li><li>0.2</li><li>0.4</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>0.4，解释看回第一题</p></div></div><hr><p>逻辑回归（Logistics Regression）模型将找到具有最高 <strong>__</strong> 的线</p><ul><li>系数（Coefficients）</li><li>准确度（Accuracy）</li><li>可能性（Likelihood）</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>可能性（Likelihood）</p><p>准确度（Accuracy）是一个良好模型的特征，但可能性（likelihood）是一个更强大模型的特征。为了解释，我将给出一个非常简单的例子。假设我们有一个只有一个特征的数据集，目标可以是 0 或 1。我们有以下特征：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = [[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><p>和以下目标：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>线 x=3、x=4、x=5、x=6 和 x=7 的准确度（Accuracy）都是 100%，因为它们完美地将0和1分开。</p><p>然而，x=5 具有最佳的似然性（likelihood），因为它将 0 放在更正面的区域，将 1 放在更负面的区域。如果我们对接近 2 或 8 的新数据进行预测，x=5 模型将分别给出期望的输出 0 或 1。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（6）分类 Classification</title>
      <link href="/2023/e73891d6.html"/>
      <url>/2023/e73891d6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="分类在机器学习中属于哪一个部分"><a href="#分类在机器学习中属于哪一个部分" class="headerlink" title="分类在机器学习中属于哪一个部分"></a>分类在机器学习中属于哪一个部分</h1><p>机器学习的顶层是由<strong>监督学习</strong>和<strong>无监督学习</strong>所组成的。<strong>分类</strong>在一个较高层次上属于监督学习的一部分。</p><p>监督学习是指我们将用一组有标记的历史数据来训练我们的模型。我们称那个标签（Label）或我们试图预测的事物为<strong>目标（Target）</strong>。因此，在监督学习中，历史数据有一个已知的目标，而在无监督学习中没有已知的目标。</p><p>在监督学习中，有<strong>分类（Classification）</strong>和<strong>回归（Regression）</strong>两种。<strong>分类问题</strong>是目标是分类值的情况（通常是True或False，但也可以是多个类别）。<strong>回归问题</strong>是目标是数值的情况。</p><p>例如，预测房价是一个<strong>回归问题</strong>。</p><ul><li>它是属于监督学习的一种，因为我们有过去房屋销售的历史数据。</li><li>它是回归问题，因为房价是一个数值。</li></ul><p>预测某人是否会违约是一个<strong>分类问题</strong>。</p><ul><li>同样，它是监督学习，因为我们有过去借款人是否违约的历史数据，</li><li>它是一个<strong>分类问题</strong>，因为我们试图预测贷款是否属于两个类别之一（违约或不违约）。</li></ul><p><strong>逻辑回归（Logic Regression）</strong>虽然在其名称中包含“回归”，但是是用于解决<strong>分类问题</strong>的算法，而不是<strong>回归问题</strong>。</p><h1 id="分类-Classification-术语-Terminology"><a href="#分类-Classification-术语-Terminology" class="headerlink" title="分类 Classification 术语 Terminology"></a>分类 Classification 术语 Terminology</h1><p>让我们回顾一下我们的泰坦尼克号数据集。这是该数据集的 Pandas DataFrame：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Survived  Pclass     Sex   Age  Siblings/Spouses  Parents/Children     Fare</span><br><span class="line">0          0       3  female  22.0                 1                 0   7.2500</span><br><span class="line">1          1       3  female  22.0                 1                 0  71.2833</span><br><span class="line">2          1       3  female  22.0                 1                 0   7.9250</span><br><span class="line">3          1       3  female  22.0                 1                 0  53.1000</span><br><span class="line">4          1       3  female  22.0                 1                 0   8.0500</span><br></pre></td></tr></table></figure><p><strong>Survived</strong> 列是我们试图预测的内容。我们称之为<strong>目标（Target）</strong>。你可以看到它是一个由 1 和 0 组成的列表。1 表示乘客幸存，0 表示乘客未幸存。</p><p>其余的列是关于我们可以用来预测目标的乘客的信息。我们称这些列中的每一列为<strong>特征（Features）</strong>。特征是我们用来进行预测的数据。</p><p>虽然我们知道数据集中的每个乘客是否幸存，但我们希望能够对我们无法收集到其数据的其他乘客进行预测。我们将构建一个机器学习模型来帮助我们做到这一点。</p><div class="note info flat"><p>有时你会听到把特征称为预测变量 predictors。</p></div><h1 id="线性分类模型"><a href="#线性分类模型" class="headerlink" title="线性分类模型"></a><strong>线性分类模型</strong></h1><p>在机器学习中，线性模型是一种常见的分类方法。</p><details class="toggle" ><summary class="toggle-button" style="">让我们简要了解线性分类模型（内容涉及数学，慎重展开）</summary><div class="toggle-content"><p>线性分类模型的基本思想是通过一个线性方程对输入特征进行加权求和，然后通过一个阈值函数（也称为激活函数）将结果映射到类别标签。这个线性方程的输出表示输入特征属于某个类别的程度。</p><p>数学上，给定输入特征向量 $X = [X_1, X_2, …, X_n]$，线性分类模型的输出 $y$ 计算如下：</p><p>$y = b + w_1X_1 + w_2X_2 + … + w_nX_n$</p><p>其中，$b$ 是偏置项（截距），$w_1, w_2, …, w_n$ 是权重，控制每个特征在分类中的影响程度。</p><p>然后，通过将输出 $y$ 输入激活函数，将连续的输出映射到类别标签。一种常用的激活函数是<strong>sigmoid函数</strong>，其数学表达式为：</p><p>$f(y) = \frac{1}{1 + e^{-y}}$</p><p>在二分类问题中，如果 $f(y) &gt; 0.5$，则模型预测为正类别 $1$，否则预测为负类别 $0$。</p><p>这是一个简单的线性分类模型的概述。实际中，机器学习模型通常通过训练数据来学习最优的权重和偏置项，以便能够进行准确的分类。</p></div></details><h2 id="图形化的分类"><a href="#图形化的分类" class="headerlink" title="图形化的分类"></a>图形化的分类</h2><div class="note info flat"><p>在项目的最终，我们将会用到 titanic.csv 中的所有特征值，但为了简单介绍，先使用其中两个特征（Fare 和 Age）这两种特征可以帮助我们在图表中可视化数据。</p></div><p>我们将乘客票价（Fare）绘制在 X 轴上，然后将其年龄绘制在 Y 轴上。黄色点是幸存乘客，紫色电视未幸存乘客。这个图的代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;Fare&#x27;</span>], df[<span class="string">&#x27;Age&#x27;</span>], c=df[<span class="string">&#x27;Survived&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter.jpg"/></p><p>你可以看到在图的底部有更多的黄色点，而在顶部有更多的紫色点。这是因为儿童比成年人更有可能幸存，这符合我们的直觉。同样，在图的右侧有更多的黄色点，意味着支付更多的人更有可能幸存。</p><p>线性模型的任务是找到最好地将两个类别分开的线，使得黄色点在一侧，紫色点在另一侧。</p><p>下面是一个好的示例。该线用于对新乘客进行预测。如果乘客的数据点位于线的右侧，我们会预测他们会幸存。如果在左侧，我们会预测他们未幸存。</p><div class="note danger flat"><p>这条线是根据直觉给的，不要盲目跟风。</p></div><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;Fare&#x27;</span>], df[<span class="string">&#x27;Age&#x27;</span>], c=df[<span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">plt.plot([<span class="number">25</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">80</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter%20w%20line.jpg"/></p><div class="note primary flat"><p>建立模型的挑战在于确定最佳的分隔线是什么。</p></div><h1 id="线的方程式"><a href="#线的方程式" class="headerlink" title="线的方程式"></a>线的方程式</h1><p>线的方程可以用以下形式表示：</p><script type="math/tex; mode=display">0 = ax + by + c</script><p>其中，a、b 和 c 是系数。任意三个值都将定义一条唯一的直线。</p><p>让我们看一个具体的例子，其中系数是 a=1，b=-1，c=-30。</p><script type="math/tex; mode=display">0 = (1)x + (-1)y + (-30)</script><p>三个系数分别是：1，-1，-30</p><p>回想一下，我们一直在用 x 轴表示乘客的票价（Fare），y 轴表示乘客的年龄（Age）。</p><p>为了画出方程表示的直线，我们需要两个位于直线上的点。</p><p>我们可以看到，例如点 (30, 0) 正好位于该直线上（票价 30，年龄 0）。如果我们将它代入方程，计算结果如下：</p><script type="math/tex; mode=display">30 - 0 - 30 = 0</script><p>我们还可以看到，点 (50, 20) 位于该直线上（票价 50，年龄 20）。</p><script type="math/tex; mode=display">50 - 20 - 30 = 0</script><p>以下是我们的直线在图上的样子。</p><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter%20w%20line.jpg"/></p><div class="note info flat"><p>直线的系数控制着直线的位置。</p></div><h2 id="对线性方程式的讨论"><a href="#对线性方程式的讨论" class="headerlink" title="对线性方程式的讨论"></a>对线性方程式的讨论</h2><details class="toggle" ><summary class="toggle-button" style="">另一种表示直线的方式</summary><div class="toggle-content"><p>另一种表示直线的方式是：</p><script type="math/tex; mode=display">y = mx + c</script><p>在这里，$m$ 是直线的“斜率”；</p><script type="math/tex; mode=display">m = \tan \theta</script><p>$\theta$ 是直线与正 x 轴之间的角度。简而言之，$m$ 是一个数字，表示直线的倾斜程度。$\theta$ 表示水平，无穷大表示垂直，1 表示角度为 45° 或与两个轴（x 和 y）均匀倾斜。在 0 和无穷大之间的任何其他数字将直接与角度成正比（值越大，角度越大）。因此，正值 =&gt; 正角 =&gt; 逆时针旋转。负值将使直线顺时针旋转（值越负，角度越负）。</p><p>$c$ 是斜率，或直线与 y 轴相交的点的 y 坐标（当 $x = 0$ 时）。这种直线方程的形式可以帮助并减少确定所需直线方程所需的尝试次数。您只需要大致了解直线会倾斜多少（或与 x 轴成什么角度 $\theta$），使用计算器计算 $\tan \theta$ 并将得到的值放入 $m$ 的位置即可。</p></div></details><h1 id="基于直线的预测"><a href="#基于直线的预测" class="headerlink" title="基于直线的预测"></a>基于直线的预测</h1><blockquote><p>一个点位于直线的哪一侧决定了我们是否认为该乘客会幸存。</p></blockquote><p>让我们再次看看同一条直线。</p><script type="math/tex; mode=display">0 = (1)x + (−1)y − 30</script><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter%20w%20line.jpg"/></p><p>如果我们有一个乘客的数据，我们可以使用这个方程来确定他们在直线的哪一侧。例如，假设我们有一个票价为 100，年龄为 20 的乘客。</p><p>让我们将这些值代入我们的方程：</p><script type="math/tex; mode=display">\begin{aligned}(1) × 100 + (−1) × 20 − 30 \\&= 100 − 20 − 30 \\&= 50\end{aligned}</script><p>由于这个值是正的，该点位于直线的右侧，我们会预测该乘客幸存。</p><p>现在假设一个乘客的票价是 10，年龄是 50。让我们将这些值代入方程。</p><script type="math/tex; mode=display">(1) × 10 + (−1) × 50 − 30 = −70</script><p>由于这个值是负的，该点位于直线的左侧，我们会预测该乘客未幸存。</p><p>我们可以在下面的图中看到这两个点。</p><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20prediction.jpg"/></p><h1 id="什么是一条好的直线？"><a href="#什么是一条好的直线？" class="headerlink" title="什么是一条好的直线？"></a>什么是一条好的直线？</h1><p>让我们来看看两条不同的直线，首先是我们一直在使用的那条直线：我们称为直线 1</p><script type="math/tex; mode=display">0 = (1)x + (−1)y − 30</script><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter%20w%20line.jpg" alt="直线 1"/></p><p>接下来是我们定义的另外一条直线方程，我们称之为直线 2</p><script type="math/tex; mode=display">0 = (4)x + (5)y − 400</script><p><img src="/uploads/sololearn/machine-learning/fare%20age%20survival%20scatter%20w%20line%202.jpg" alt="直线 2"/></p><p>如果我们看这两条直线，我们会发现直线 1 在右侧有更多的黄色点，左侧有更多的紫色点。直线 2 在右侧没有太多点；大多数紫色和黄色点都在左侧。这使直线 1 成为更好的选择，因为它更好地分离了黄色和紫色点。</p><p>我们需要在数学上定义这个想法，以便我们可以通过算法找到最佳的直线。</p><p><strong>逻辑回归</strong>是一种数学方法，可以找到最佳的直线。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Classification </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（5）Matplotlib 绘图基础</title>
      <link href="/2023/760f244b.html"/>
      <url>/2023/760f244b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="散点图-Scatter-Plot"><a href="#散点图-Scatter-Plot" class="headerlink" title="散点图 Scatter Plot"></a>散点图 Scatter Plot</h1><p>我们可以使用 matplotlib 库绘制数据，绘制数据通常有助于我们建立对数据的直觉。</p><p>首先，我们需要导入 matplotlib。一般我们会为他取一个别名 plt，方便后续调用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>接下来，还是使用 titanic.csv，我们用 <code>scatter</code> 函数来绘制数据图，scatter 函数的第一个参数是 x 轴（横向 / 水平方向），第二个参数是 y 轴（纵向 / 垂直方向）。下面，我们将在 x 轴上绘制年龄，在 y 轴上绘制票价。为了更容易解释，我们可以添加 x 和 y 标签。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;Age&#x27;</span>], df[<span class="string">&#x27;Fare&#x27;</span>])</span><br><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Fare&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/plotting%20basics%20scatter%20plot.jpg"/></p><p>我们还能为散点图进行着色，这将为三个舱位等级分配不同的颜色。我们添加了 c 参数，并给他一个 Pandas Series <code>Pclass</code>。在这种情况下，我们的 Pandas Series 有三种值（1st, 2nd 和 3rd 类）因此我们将看到每个数据点都能获得对应的颜色</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;Age&#x27;</span>], df[<span class="string">&#x27;Fare&#x27;</span>], c=df[<span class="string">&#x27;Pclass&#x27;</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/plotting%20basics%20scatter%20plot%20colored.jpg"/></p><div class="note info flat"><p>散点图用于在图表上显示数据的所有值。为了获得我们数据的视觉表示，我们必须将数据限制在两个特征上。</p></div><h2 id="散点图练习"><a href="#散点图练习" class="headerlink" title="散点图练习"></a>散点图练习</h2><p>现在，编写一段代码创建一个散点图。要求 Pclass 在 y 轴、Fare 在 x 轴，用颜色表明他们是否幸存。然后在 xy 轴上写上标签</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(df[<span class="string">&#x27;Fare&#x27;</span>], df[<span class="string">&#x27;Pclass&#x27;</span>], c=df[<span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Fare&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Pclass&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="画线-Line"><a href="#画线-Line" class="headerlink" title="画线 Line"></a>画线 Line</h1><p>既然我们可以在图上放置单个数据点，让我们看看如何绘制线。<code>plot</code> 函数正是用于此目的。以下代码绘制了一条线，大致分离了一等舱和二、三等舱。通过用眼睛观察，我们将线放在 <code>(0, 85)</code> 到 <code>(80，5)</code> 之间。我们的语法下有一个 x 值列表和一个 y 值列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">0</span>, <span class="number">80</span>], [<span class="number">85</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p><img src="/uploads/sololearn/machine-learning/plotting%20basics%20scatter%20plot%20w%20line.jpg"/></p><p>你可以看到黄色（三等舱）和绿色（二等舱）的点大多在线下，而紫色（一等舱）的点大多在线上。虽然我们是手动完成的，但在下一个模块中，我们将学习如何通过算法完成这个任务。</p><div class="note info flat"><p>在 matplotlib 中，我们使用 <code>scatter</code> 函数创建散点图，使用 <code>plot</code> 函数创建线。</p></div><h2 id="画线练习"><a href="#画线练习" class="headerlink" title="画线练习"></a>画线练习</h2><p>我们需要画一条直线从 (10, 0) 到 (100, 3)，代码应该怎么写？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">10</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h2 id="深入记忆"><a href="#深入记忆" class="headerlink" title="深入记忆"></a>深入记忆</h2><p>要知道，<code>plot([x], [y])</code> 函数的参数是两个列表，也就是说，假设我需要在三个点之间连线：(0, 85), (68, 50), (80, 5)，需要先将坐标值的 x 轴全部取出来变成数组 <code>[0, 68, 80]</code>，再将坐标值的 y 轴全部取出来变成数组 <code>[85, 50, 5]</code>。调用函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">0</span>, <span class="number">68</span>, <span class="number">80</span>], [<span class="number">85</span>, <span class="number">50</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（4）Numpy 数据处理</title>
      <link href="/2023/25bd939a.html"/>
      <url>/2023/25bd939a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Numpy-是什么？"><a href="#Numpy-是什么？" class="headerlink" title="Numpy 是什么？"></a>Numpy 是什么？</h1><p>Numpy 是一个用于操作数值数据列表和表格的 Python 包。我们可以使用它进行许多统计计算。我们将数据列表或表格称为 numpy 数组（Numpy Array）。</p><p>通常，我们会从 Pandas DataFrame 中获取数据并将其放入 numpy 数组中。Pandas DataFrame 非常棒，因为我们有列名和其他文本数据，使其易于人类阅读。虽然 DataFrame 对人类来说易读，但并不是进行计算的理想格式。相比之下，numpy 数组通常不太容易阅读，但是却是进行必要计算的理想格式。</p><div class="note info flat"><p>事实上 Pandas 的底层是用 Numpy 作为基础来开发的。</p></div><h1 id="将-Pandas-Series-转换成-Numpy-Array"><a href="#将-Pandas-Series-转换成-Numpy-Array" class="headerlink" title="将 Pandas Series 转换成 Numpy Array"></a>将 Pandas Series 转换成 Numpy Array</h1><p>我们经常使用 Pandas 来读取数据，所以得到的也是 Pandas DataFrame。如果需要将其转换成 numpy array，可以使用 <code>values</code> 属性直接获取。对于 Pandas Series，具体操作如下，比如我们需要将 Fare 列表转换成 numpy array</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;https://kingsmai.github.io/uploads/@files/datasets/titanic/train.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Fare&#x27;</span>].values)</span><br></pre></td></tr></table></figure><p>得到的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[  7.25    71.2833   7.925   53.1      8.05     8.4583  51.8625  21.075 ...... ]</span><br></pre></td></tr></table></figure><p>返回值是一个 <strong>一维数组</strong>。因为我们转换的是 Pandas Series，所以得到的值是一个一维数组。能理解吧？</p><div class="note default flat"><p><code>Series.values</code> 属性就是用来获取 Pandas Series 的 numpy array 形式的数据的。</p></div><h1 id="将-Pandas-DataFrame-转换成-Numpy-Array"><a href="#将-Pandas-DataFrame-转换成-Numpy-Array" class="headerlink" title="将 Pandas DataFrame 转换成 Numpy Array"></a>将 Pandas DataFrame 转换成 Numpy Array</h1><p>如果需要转换的数据是 DataFrame，同样的可以使用 <code>DataFrame.values</code>，但是它的返回值将会是一个 <strong>二维数组</strong>。比如我们需要获取：舱位信息、票价和年龄的 numpy array，可以这么操作：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values)</span><br></pre></td></tr></table></figure><p>得到的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[ 3.      7.25   22.    ]</span><br><span class="line"> [ 1.     71.2833 38.    ]</span><br><span class="line"> [ 3.      7.925  26.    ]</span><br><span class="line"> ...</span><br><span class="line"> [ 3.     23.45    7.    ]</span><br><span class="line"> [ 1.     30.     26.    ]</span><br><span class="line"> [ 3.      7.75   32.    ]]</span><br></pre></td></tr></table></figure><h1 id="Numpy-Shape-属性"><a href="#Numpy-Shape-属性" class="headerlink" title="Numpy Shape 属性"></a>Numpy Shape 属性</h1><p><code>shape</code> 属性用来得到一组 numpy array 的维度（宽 高）。这个数据将告诉我们数据集中有多少行多少列。同样的，我们来获取三个列的 shape，看看其返回值为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br><span class="line"><span class="built_in">print</span>(arr.shape)</span><br></pre></td></tr></table></figure><p>返回值为 (887, 3) 说明这个数据集有 887 行，3 列数据。</p><div class="note info flat"><p>除了 numpy array 可以使用 <code>shape</code> 属性获取它的行列值之外，DataFrame 同样也可以获取：<code>df.shape</code>。</p></div><h1 id="从-Numpy-Array-中获取数据"><a href="#从-Numpy-Array-中获取数据" class="headerlink" title="从 Numpy Array 中获取数据"></a>从 Numpy Array 中获取数据</h1><p>我们定义了一个数组，存放了乘客的舱位信息、票价和年龄，那么我们可以像操作数组一样，对 Numpy Array 进行操作。如下所示，获取 Numpy Array 数组中第一行第二列的数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>同样的，我们可以选择一行，直接输出正行数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>但是如果我们需要选取<strong>一列</strong>的数据，那么就要通过以下代码进行完成，如我们需要获取乘客的年龄信息（第 3 列）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(arr[:, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>是不是觉得很眼熟？没错，这就是 Python 中数组的 slice 用法。原理就是获取全部行 <code>:</code> 然后获取下表为 <code>2</code> 的列。</p><div class="note default flat"><p>通过不同的语法规则（syntax），我们可以获取 numpy array 中的 值，整行，整列。</p></div><h1 id="遮罩-Masking"><a href="#遮罩-Masking" class="headerlink" title="遮罩 Masking"></a>遮罩 Masking</h1><p>一般情况下，我们希望选择的数据是符合某些条件的。比如说选择符合某条件的所有行。在以下例子中，我们将选择所有儿童（年龄小于 18 岁的乘客）。要做到这点，我们需要</p><ol><li>获取我们的数组（舱位等级，票价，年龄），得到他们的 numpy array</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br></pre></td></tr></table></figure><ol><li>获取 age 列的数组，用于后面的判断</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[:, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><ol><li>【重点】接下来，我们需要创建一个我们称之为掩码（Mask）的东西。这是一个包含布尔值的数组，表示乘客是否为儿童</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = arr[:, <span class="number">2</span>] &lt; <span class="number">18</span></span><br></pre></td></tr></table></figure><p>我们可以输出这段 mask，看他是什么：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[False, False, False, False, False, False, False, True, False, ...]</span><br></pre></td></tr></table></figure><p>其中，False 表示是成年人，True 表示儿童。现在我们使用创建好的掩码只选择我们关心的行，操作方法就是<strong>将 mask 数组当作索引放入 arr 数组中</strong>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[mask]</span><br></pre></td></tr></table></figure><p>通常，我们不需要额外取创建 mask 变量来保存掩码，我们可以通过一行代码直接完成上述功能。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr[arr[:, <span class="number">2</span>] &lt; <span class="number">18</span>]</span><br></pre></td></tr></table></figure><div class="note default flat"><p>掩码 Mask 就是一组布尔值的数组，用来告诉 python 我们对哪些数据感兴趣。</p></div><h1 id="总和与计算"><a href="#总和与计算" class="headerlink" title="总和与计算"></a>总和与计算</h1><p>如果说我们需要在刚刚处理好的小孩数据中获取到具体有多少个小孩，那么我们可以这么操作。因为 mask 获得的值，符合条件的为 True，可以被解释为 1；反之为 0。所以我们可以通过 <code>mask.sum()</code>，得到统计。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = df[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Fare&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]].values</span><br><span class="line">mask = arr[:, <span class="number">2</span>] &lt; <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(mask.<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p>同样的，我们也可以跳过定义 mask 变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((arr[:, <span class="number">2</span>] &lt; <span class="number">18</span>).<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><div class="note info flat"><p>将布尔值数组进行求和，将会得到 True 为 1 的数量。</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习 3 Pandas 数据读取与处理</title>
      <link href="/2023/75989641.html"/>
      <url>/2023/75989641.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="什么是-Pandas"><a href="#什么是-Pandas" class="headerlink" title="什么是 Pandas"></a>什么是 Pandas</h1><p>这整个系列教程将使用机器学习中最常用的编程语言 —— Python。Python 的社群特别强大，里面有无数个有用的且效率高的模组可以用来进行数据处理。包括今天的主角：Pandas</p><p>Pandas 是 Python 中用来读取和操作数据的一个库，它可以将数据转换成人们看得懂的表格模式来将数据进行输出，同时它也可以以数值方式对数据进行解释，从而使用户可以对数据进行各种计算。</p><div class="note info flat"><p>我们将 Pandas 的数据表称为 DataFrame</p></div><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><p>现在开始使用 <code>pandas</code> 来读取数据，我们习惯将其命名为 <code>pd</code>，一遍后续能够快速调用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>由于在 <a href="/2023/d24f091e.html" title="Sololearn 自学机器学习 13 训练与测试">《训练与测试篇》</a> 中，我们介绍了 <strong>训练集</strong> 与 <strong>测试集</strong> 的概念，所以我现在从那边穿越回来，告知读者，我们提供的数据是从 kaggle 下载的已经分离过的 train.csv。如需下载原先 sololearn 提供的数据集，请 <a class="btn-beautify " href="/uploads/@files/datasets/titanic/titanic.csv" title="点此下载"><i class="fas fa-download"></i><span>点此下载</span></a></p></div><p>我们将对泰坦尼克号的数据集进行处理，在 <a href="/uploads/@files/datasets/titanic/train.csv" download>train.csv</a> 数据集中，记录了所有泰坦尼克号乘客的信息，包括以下几种（字段很多，就没一一列举了）：</p><ul><li>幸存情况</li><li>舱位等级</li><li>姓名、性别、年龄……等</li></ul><div class="table-container"><table><thead><tr><th>PassengerId</th><th>Survived</th><th>Pclass</th><th>Lname</th><th>Name</th><th>Sex</th><th>Age</th><th>SibSp</th><th>Parch</th><th>Ticket</th><th>Fare</th><th>Cabin</th><th>Embarked</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>3</td><td>Braund</td><td>Mr. Owen Harris</td><td>male</td><td>22</td><td>1</td><td>0</td><td>A/5 21171</td><td>7.25</td><td></td><td>S</td></tr><tr><td>2</td><td>1</td><td>1</td><td>Cumings</td><td>Mrs. John Bradley (Florence Briggs Thayer)</td><td>female</td><td>38</td><td>1</td><td>0</td><td>PC 17599</td><td>71.2833</td><td>C85</td><td>C</td></tr><tr><td>3</td><td>1</td><td>3</td><td>Heikkinen</td><td>Miss. Laina</td><td>female</td><td>26</td><td>0</td><td>0</td><td>STON/O2. 3101282</td><td>7.925</td><td></td><td>S</td></tr><tr><td>4</td><td>1</td><td>1</td><td>Futrelle</td><td>Mrs. Jacques Heath (Lily May Peel)</td><td>female</td><td>35</td><td>1</td><td>0</td><td>113803</td><td>53.1</td><td>C123</td><td>S</td></tr><tr><td>5</td><td>0</td><td>3</td><td>Allen</td><td>Mr. William Henry</td><td>male</td><td>35</td><td>0</td><td>0</td><td>373450</td><td>8.05</td><td></td><td>S</td></tr></tbody></table></div><p>我们将使用 pandas 对数据进行读取，可以通过 pandas 的 <code>read_csv</code> API 对数据进行读取，并转换成 pandas DataFrame 对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><div class="note info flat"><p>由于 Titanic Dataset 经常作为机器学习的学习用途，所以将其分为训练集和测试集两种，上方链接下载的就是训练集 <code>train.csv</code>，所以读取的是 train.csv 而非 titanic.csv。</p></div><p><code>df</code> 现在保存了 titanic 数据集的 DataFrame，接下来可以使用 <code>DataFrame.head()</code> 函数对数据集的首五行进行输出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><h1 id="将数据进行概述"><a href="#将数据进行概述" class="headerlink" title="将数据进行概述"></a>将数据进行概述</h1><p>将所有数据进行输出显然不科学，数据量太大，人脑也无法对其进行分析。我们可以通过 <code>DataFrame.describe()</code> 函数对数据进行概述，他将会返回一个统计表供我们了解整个数据中的各项数值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.describe())</span><br></pre></td></tr></table></figure><p><code>describe</code> 函数只会对数值列表进行统计，非数值数据将会被掠过。他将会列出以下几个数据供分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         Survived      Pclass         Age  Siblings/Spouses  Parents/Children       Fare  </span><br><span class="line">count  887.000000  887.000000  887.000000        887.000000        887.000000  887.00000  </span><br><span class="line">mean     0.385569    2.305524   29.471443          0.525366          0.383315   32.30542  </span><br><span class="line">std      0.487004    0.836662   14.121908          1.104669          0.807466   49.78204  </span><br><span class="line">min      0.000000    1.000000    0.420000          0.000000          0.000000    0.00000  </span><br><span class="line">25%      0.000000    2.000000   20.250000          0.000000          0.000000    7.92500  </span><br><span class="line">50%      0.000000    3.000000   28.000000          0.000000          0.000000   14.45420  </span><br><span class="line">75%      1.000000    3.000000   38.000000          1.000000          0.000000   31.13750  </span><br><span class="line">max      1.000000    3.000000   80.000000          8.000000          6.000000  512.32920  </span><br></pre></td></tr></table></figure><ul><li>Count - 数据总数量</li><li>Mean - 平均值</li><li>Std - 标准平方差（Standard Deviation），用于衡量数据的离散状态）</li><li>Min - 最小值</li><li>25% - 25 分位数</li><li>50% - 50 分位数 / 中位数</li><li>75% - 75 分位数</li><li>Max - 最大值</li></ul><div class="note primary flat"><p>We use the Pandas describe method to start building some intuition about our data.</p><p>我们使用Pandas的describe方法来开始建立对我们的数据的一些直观认识。</p></div><h1 id="选择一个字段"><a href="#选择一个字段" class="headerlink" title="选择一个字段"></a>选择一个字段</h1><p>我们需要对数据集中的一些列进行操作，如果需要选择其中一个列，我们使用方括号和列名 <code>[&#39;列名&#39;]</code>，下边的例子就是选择乘客票价的列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">col = df[<span class="string">&#x27;Fare&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(col)</span><br></pre></td></tr></table></figure><p>我们将 DataFrame 中的某一列称之为 <code>Series</code>，Series 也是 DataFrame 的一种，但是只有一列数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0       7.2500</span><br><span class="line">1      71.2833</span><br><span class="line">2       7.9250</span><br><span class="line">3      53.1000</span><br><span class="line">4       8.0500</span><br><span class="line">        ...   </span><br><span class="line">882    13.0000</span><br><span class="line">883    30.0000</span><br><span class="line">884    23.4500</span><br><span class="line">885    30.0000</span><br><span class="line">886     7.7500</span><br><span class="line">Name: Fare, Length: 887, dtype: float64</span><br></pre></td></tr></table></figure><h1 id="选择多个字段"><a href="#选择多个字段" class="headerlink" title="选择多个字段"></a>选择多个字段</h1><p>我们当然可以选择数据集中的多个列来进行操作，创建一个小的 DataFrame。比如说我们选择 <code>Age, Sex, Survived</code> 列作为我们的小 DataFrame。要选取多个列，我们需要使用两个方括号 <code>[[&#39;列名1&#39;, &#39;列名2&#39;, ...]]</code> 来完成，如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">small_df = df[[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]]</span><br><span class="line"><span class="built_in">print</span>(small_df.head())</span><br></pre></td></tr></table></figure><div class="note info flat"><p>当选择一列时，我们使用一个方括号，如果选择多列时，我们需要使用两个方括号。</p></div><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Age     Sex  Survived</span><br><span class="line">0  22.0    male         0</span><br><span class="line">1  38.0  female         1</span><br><span class="line">2  26.0  female         1</span><br><span class="line">3  35.0  female         1</span><br><span class="line">4  35.0    male         0</span><br></pre></td></tr></table></figure><h1 id="创建一个字段"><a href="#创建一个字段" class="headerlink" title="创建一个字段"></a>创建一个字段</h1><p>我们经常希望我们的数据以比其原始格式稍微不同的方式呈现。例如，我们的数据中的乘客性别是一个字符串（”male” 或 “female”）。这对于人类来说很容易阅读，但当我们稍后对数据进行计算时，我们希望将其表示为布尔值（True 和 False）。</p><p>上面提到，我们可以通过选取一列获得一个 pandas Series 类型数据。在这基础上，我们可以直接对整个 Series 进行一些逻辑操作，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行这段操作之后，相当于 Series 会将整个数据集中的每一行取进行对比，如果是 <code>male</code> 则为 <code>True</code> 反之为 <code>False</code>，最后得到一个新的 Series</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0       True</span><br><span class="line">1      False</span><br><span class="line">2      False</span><br><span class="line">3      False</span><br><span class="line">4       True</span><br><span class="line">       ...  </span><br><span class="line">882     True</span><br><span class="line">883    False</span><br><span class="line">884    False</span><br><span class="line">885     True</span><br><span class="line">886     True</span><br><span class="line">Name: Sex, Length: 887, dtype: bool</span><br></pre></td></tr></table></figure><p>那现在就需要创建一个列来保存这些数据，我们可以直接通过和选取列相同的代码来执行这个操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;Male&#x27;</span>] = df[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>以上这行代码将会在 df 数据集中创建一个新的数据列 <code>Male</code>。然后保存 <code>df[&#39;Sex&#39;] == &#39;male&#39;</code> 的结果。</p><p>同理，我们可以创建一个用来判断用户是否是头等舱的数据集</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;First Class&#x27;</span>] = df[<span class="string">&#x27;Pclass&#x27;</span>] == <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（2）统计学回顾</title>
      <link href="/2023/d1d2c808.html"/>
      <url>/2023/d1d2c808.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在机器学习的学习过程中，统计学是一个至关重要的基础知识。本章将对一些基础统计概念进行回顾，这些概念构成了机器学习理论和实践的基础。</p><h1 id="平均数"><a href="#平均数" class="headerlink" title="平均数"></a>平均数</h1><p>平均数<br>在处理数据时，我们经常需要计算一些简单的统计量。</p><p>假设我们有一个班级学生年龄的列表，按升序排列以便更容易进行计算。</p><p>15, 16, 18, 19, 22, 24, 29, 30, 34</p><p><strong>均值（Mean）</strong>是最常见的平均数。</p><p>将所有值相加，然后除以值的数量：</p><script type="math/tex; mode=display">\frac{(15 + 16 + 18 + 19 + 22 + 24 + 29 + 30 + 34)} {9} = \frac{207} {9} = 23</script><p><strong>中位数（Median）</strong>是中间的值。在这种情况下，由于有9个值，中间值是第5个，即22。</p><p>在统计学中，均值和中位数都被称为平均数。在一般用语中，平均数通常指的是均值。</p><h1 id="百分位数（Percentiles）"><a href="#百分位数（Percentiles）" class="headerlink" title="百分位数（Percentiles）"></a>百分位数（Percentiles）</h1><p>中位数也可以被视为<strong>第 50 个百分位数</strong>。这意味着 50% 的数据小于中位数，而 50% 的数据大于中位数。这告诉我们数据的中间位置在哪里，但我们通常希望更深入地了解数据的分布。我们经常会查看<strong>第 25 个</strong>百分位数和<strong>第 75 个</strong>百分位数。</p><p><strong>第 25 个</strong>百分位数是数据的四分之一处的值。这是一个值，其中25%的数据小于它（而75%的数据大于它）。</p><p>同样，<strong>第 75 个</strong>百分位数是数据的四分之三处的值。这是一个值，其中75%的数据小于它（而25%的数据大于它）。</p><p>如果我们再看一下我们的年龄数据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15, 16, 18, 19, 22, 24, 29, 30, 34</span><br></pre></td></tr></table></figure><p>我们有9个值，因此数据的 25% 大约是 2 个数据点。因此，第 3 个数据点大于 25% 的数据。因此，第 25 个百分位数是 18（第 3 个数据点）。<br>同样，数据的75%大约是 6 个数据点。因此，第 7 个数据点大于75%的数据。因此，第 75 个百分位数是 29（第 7 个数据点）。</p><p>我们的数据的完整范围在 15 到 34 之间。第 25 和第 75 个百分位数告诉我们，我们的数据有一半位于 18 和 29 之间。这有助于我们了解数据的分布方式。</p><p>如果数据点的数量是偶数，为了找到中位数（或第50个百分位数），您需要取中间两个值的平均值。</p><h2 id="百分位数练习"><a href="#百分位数练习" class="headerlink" title="百分位数练习"></a>百分位数练习</h2><p>假设我们有一个包含 11 个家庭及每个家庭孩子数量的样本。列表中的每个数字代表一个家庭的孩子数量。因此，有 1 个家庭没有孩子，有 5 个家庭有 1 个孩子，依此类推。</p><p>0，1，1，1，1，1，2，2，2，3，6</p><p>第25个百分位数是 <span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 查看答案</button><span class="hide-content">1</span></span></p><p>第50个百分位数（又称中位数）是 <span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 查看答案</button><span class="hide-content">1</span></span></p><p>第75个百分位数是 <span class="hide-inline"><button type="button" class="hide-button" style="background-color:  #FF7242;color:  #fff"> 查看答案</button><span class="hide-content">2</span></span></p><h1 id="标准差和方差"><a href="#标准差和方差" class="headerlink" title="标准差和方差"></a>标准差和方差</h1><p>我们可以通过标准差（Standard Deviation）和方差（Variance）更深入地了解数据的分布。<strong>标准差</strong>和<strong>方差</strong>是衡量数据分散或扩散程度的指标。</p><p>我们测量每个数据点离均值的距离。</p><p>让我们再次看一下我们的年龄组：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15, 16, 18, 19, 22, 24, 29, 30, 34</span><br></pre></td></tr></table></figure><p>回想一下均值是23。</p><p>让我们计算每个值离均值的距离。15 离均值 8 个单位（因为 23 - 15 = 8）。</p><p>以下是所有这些距离的列表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8, 7, 5, 4, 1, 1, 6, 7, 11</span><br></pre></td></tr></table></figure><p>我们对这些值进行平方并相加。</p><script type="math/tex; mode=display">\begin{aligned}& 8^2 + 7^2 + 5^2 + 4^2 + 1^2 + 1^2 + 6^2 + 7^2 + 11^2 \\&= 64 + 49 + 25 + 16 + 1 + 1 + 36 + 49 + 121 \\&= 362\end{aligned}</script><p>然后，我们将这个值除以总值的数量，得到方差。</p><script type="math/tex; mode=display">362 / 9 = 40.22</script><p>要得到标准差，我们只需<strong>对方差取平方根</strong>，得到：6.34</p><div class="note info flat"><p>If our data is normally distributed like the graph below, 68% of the population is within one standard deviation of the mean. In the graph, we’ve highlighted the area within one standard deviation of the mean. You can see that the shaded area is about two thirds (more precisely 68%) of the total area under the curve. If we assume that our data is normally distributed, we can say that 68% of the data is within 1 standard deviation of the mean.</p></div><p>如果我们的数据像下面的图表一样呈正态分布，那么 68% 的人口在均值的一个标准差内。在图表中，我们突出显示了均值一个标准差内的区域。您可以看到，阴影区域大约是曲线下总面积的三分之二（更精确地说是 68% ）。如果我们假设我们的数据正态分布，我们可以说 68% 的数据在均值的 1 个标准差内。</p><p><img src="/uploads/sololearn/machine-learning/statistics%20review%20Normal%20distribution%20graph.jpg"/></p><div class="note info flat"><p>In our age example, while the ages are likely not exactly normally distributed, we assume that we are and say that approximately 68% of the population has an age within one standard deviation of the mean. Since the mean is 23 and the standard deviation is 6.34, we can say that approximately 68% of the ages in our population are between 16.66 (23 minus 6.34) and 29.34 (23 plus 6.34).</p></div><p>在我们的年龄示例中，虽然年龄可能不完全是正态分布的，但我们假设是，并说大约 68% 的人口在均值的一个标准差内具有年龄。由于均值是 23，标准差是 6.34，我们可以说大约 68% 的年龄在我们的人口中介于 16.66（23 减去 6.34）和 29.34（23 加上 6.34）之间。</p><div class="note primary flat"><p>即使数据永远不是完美的正态分布，我们仍然可以使用标准差来洞察数据的分布方式。</p></div><div class="note default flat"><p>The standard deviation and variance are measures of how dispersed the data is.</p></div><h1 id="使用-Python-进行统计学计算"><a href="#使用-Python-进行统计学计算" class="headerlink" title="使用 Python 进行统计学计算"></a>使用 Python 进行统计学计算</h1><p>我们可以使用 Python 计算所有这些操作。我们将使用 Python 包 numpy。稍后我们将更多地使用 numpy 来操作数组，但现在我们将仅使用其中一些用于统计计算的函数：mean（均值）、median（中位数）、percentile（百分位数）、std（标准差）、var（方差）。</p><p>首先，我们导入这个包。习惯上将 numpy 取一个别名为 np。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>让我们初始化变量data，将其赋值为年龄的列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">15</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">34</span>]</span><br></pre></td></tr></table></figure><p>现在我们可以使用 numpy 函数。对于mean（均值）、median（中位数）、standard deviation（标准差）和 variance（方差）函数，我们只需传入数据列表。对于 percentile（百分位数）函数，我们传入数据列表和百分位数（作为0到100之间的数字）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = [<span class="number">15</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">24</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">34</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mean:&quot;</span>, np.mean(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;median:&quot;</span>, np.median(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;50th percentile (median):&quot;</span>, np.percentile(data, <span class="number">50</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;25th percentile:&quot;</span>, np.percentile(data, <span class="number">25</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;75th percentile:&quot;</span>, np.percentile(data, <span class="number">75</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;standard deviation:&quot;</span>, np.std(data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;variance:&quot;</span>, np.var(data))</span><br></pre></td></tr></table></figure><div class="note primary flat"><p>Numpy 是一个允许在数组上执行快速且轻松的数学运算的 Python 库。</p></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sololearn 自学机器学习（1）基础篇</title>
      <link href="/2023/10f22a3b.html"/>
      <url>/2023/10f22a3b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h1><p>机器学习是将数据转化为见解的一种方式。我们利用计算机的能力来分析过去的例子，建立一个模型，可以预测新例子的结果。</p><p>我们每天都会遇到机器学习模型。例如，当Netflix向您推荐一部节目时，他们使用基于您和其他用户观看记录的模型来预测您可能喜欢的内容。当亚马逊为商品选择价格时，他们使用基于类似商品过去销售情况的模型。当您的信用卡公司因为可疑活动而给您打电话时，他们使用基于您过去活动的模型来识别异常行为。</p><blockquote><p>机器学习可用于创建聊天机器人、检测垃圾邮件或图像识别。</p></blockquote><h1 id="通过这系列博文，能够学到什么"><a href="#通过这系列博文，能够学到什么" class="headerlink" title="通过这系列博文，能够学到什么"></a>通过这系列博文，能够学到什么</h1><p>我们将使用 pandas、numpy、matplotlib 和 scikit-learn。</p><ul><li>Pandas 用于读取数据和数据处理</li><li>numpy 用于数值数据的计算，</li><li>matplotlib 用于绘制数据图表，</li><li>scikit-learn 用于机器学习模型。</li></ul><p>这些包都非常庞大，但我们将重点介绍我们将使用的函数。我们还将回顾一些基础统计知识，因为它是机器学习的基础。</p><h1 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h1><p>在机器学习中，我们谈论监督学习和无监督学习。监督学习（Supervised Learning）是基于过去数据的已知目标（例如，预测房屋的售价），而无监督学习（Unsupervised Learning）是当没有已知的过去答案时（例如，确定餐厅评论中讨论的主题）。</p><p>在本课程中，我们将专注于监督学习。在监督学习中，有分类（Classification）和回归（Regression）问题。回归是预测数值（例如，预测房屋的售价），而分类是预测某物属于哪个类别（例如，预测借款人是否会违约）。</p><p>我们将专注于分类问题，即预测某物属于哪个类别。</p><p>我们的例子将包括：</p><ul><li>预测谁会在泰坦尼克号事故中生存</li><li>从图像中确定手写数字</li><li>使用活检数据来分类肿块是否为癌症</li></ul><p>我们将使用许多流行的技术来解决这些问题。在接下来的模块中，我们将更详细地介绍每一种技术：</p><ul><li>逻辑回归（Logistic Regression）</li><li>决策树（Decision Trees）</li><li>随机森林（Random Forests）</li><li>神经网络（Neural Networks）</li></ul><p>在本课程结束时，您将能够使用Python构建多个不同的模型来处理分类数据集，并确定适用于给定问题的最佳模型。</p><blockquote><p>机器学习可以用来解决各种问题。本课程将专注于监督学习和分类。</p></blockquote><div class="note info flat"><p>除了监督学习（Supervised）和无监督学习（Unsupervised）之外，还有两种进一步的类型，即强化学习（Reinforcement）和半监督学习（Semisupervised）。</p><p>半监督学习是指处理部分标记的数据，通常是大量未标记和少量已标记的数据。Google 相册是其中的最佳例子。只需几张“你”的照片，它就能在未来的图像中识别“你”。它可以涉及监督和无监督技术的结合。</p><p>强化学习则大不相同，它致力于构建最佳模型（专家也称之为最佳可行策略，Best feasible strategy），以奖励系统（代理、机器人、设备等）在预测正确时，并在做出错误动作后对其进行惩罚。</p></div><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>如果分类问题的目标具有分类值，这意味着它有多少个可能的值？</p><ul><li>无限</li><li>有限</li><li>连续</li></ul><div class="hide-block"><button type="button" class="hide-button" style="">查看答案</button><div class="hide-content"><p>有限，因为在机器学习中，我们有两种类型的分类，监督（Supervised）和无监督（Unsupervised）。</p><p>监督意味着，例如，你有10栋房子和它们的价格，你想要卖掉你的房子，因为你已经知道你的房子价格，可以通过与其他房屋比较来确定。这是已经属于一组的分类。</p><p>但是，无监督的分类中，我们不知道房屋的价格，甚至不知道房屋的大小，这是无监督的。</p><p>分类总是有限的。</p></div></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
          <category> Sololearn 自学机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Sololearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个完整的游戏策划文件需要哪些内容</title>
      <link href="/2023/fcea434d.html"/>
      <url>/2023/fcea434d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我已经上传了可下载的 Markdown 文档，需要的同学自己去领取。<a href="/uploads/@files/Game%20Design%20Document.md" download>点此下载</a></p><blockquote><p><strong>Game Design Document Outline</strong></p><p>A game design document is the blueprint from which a game is to be built. As such, every single detail necessary to build the game should be addressed. The larger the team and the longer the design and development cycle, the more critical is the need. For your purpose, the intent is to capture as much as possible of your design. I want you to think big…bigger than what you are able to develop. I also want you to be clear about what the software delivers and what the design entails. My recommendation is that you define the ultimate game and then clarify what it is that you have developed.</p><p>All topics must be included, but “not applicable” is fine. The goal is NOT to force you to make up answers, but to assure that you have considered all of these elements and why they are or are not relevant to your game.</p><p>Your document must include the top levels of the outline explicitly. You should use your judgment as to how to present the additional detail, particularly when it is not relevant to your game. I don’t need a page of “not applicable.”</p><p>游戏设计文档是构建游戏的蓝图。因此，应该解决构建游戏所需的每一个细节。团队越大，设计和开发周期越长，需求就越关键。为了您的目的，目的是尽可能多地捕捉您的设计。我想让你想得更远……比你能开发的更远。我还希望您清楚软件提供什么以及设计需要什么。我的建议是你定义终极游戏，然后阐明你开发的是什么。</p><p>必须包括所有主题，但“不适用”也可以。目标不是强迫您做出答案，而是确保您已经考虑了所有这些元素以及它们与您的游戏相关或不相关的原因。</p><p>您的文档必须明确包含大纲的顶层。您应该根据自己的判断来决定如何呈现额外的细节，尤其是当它与您的游戏无关时。我不需要“不适用”的页面。</p></blockquote><h2 id="Title-Page-封面页"><a href="#Title-Page-封面页" class="headerlink" title="Title Page 封面页"></a>Title Page 封面页</h2><h3 id="Game-Name游戏名"><a href="#Game-Name游戏名" class="headerlink" title="Game Name游戏名"></a>Game Name游戏名</h3><h3 id="Tag-line-标语"><a href="#Tag-line-标语" class="headerlink" title="Tag line 标语"></a>Tag line 标语</h3><h3 id="Team-开发团队"><a href="#Team-开发团队" class="headerlink" title="Team 开发团队"></a>Team 开发团队</h3><h3 id="Date-of-last-update-最后一次更新日期"><a href="#Date-of-last-update-最后一次更新日期" class="headerlink" title="Date of last update 最后一次更新日期"></a>Date of last update 最后一次更新日期</h3><h2 id="Game-Overview-游戏概览"><a href="#Game-Overview-游戏概览" class="headerlink" title="Game Overview 游戏概览"></a>Game Overview 游戏概览</h2><h3 id="Game-Concept-游戏概念"><a href="#Game-Concept-游戏概念" class="headerlink" title="Game Concept 游戏概念"></a>Game Concept 游戏概念</h3><h3 id="Target-Audience-目标客户群"><a href="#Target-Audience-目标客户群" class="headerlink" title="Target Audience 目标客户群"></a>Target Audience 目标客户群</h3><h3 id="Genre-s-流派"><a href="#Genre-s-流派" class="headerlink" title="Genre(s) 流派"></a>Genre(s) 流派</h3><h3 id="Game-Flow-Summary-游戏流程总结"><a href="#Game-Flow-Summary-游戏流程总结" class="headerlink" title="Game Flow Summary 游戏流程总结"></a>Game Flow Summary 游戏流程总结</h3><blockquote><p>How does the player move through the game? Include both the interface and the game itself.</p><p>玩家如何在游戏中移动？ 包括界面和游戏本身。 </p></blockquote><h3 id="Look-and-Feel-外观和感觉"><a href="#Look-and-Feel-外观和感觉" class="headerlink" title="Look and Feel 外观和感觉"></a>Look and Feel 外观和感觉</h3><blockquote><p>What is the basic look and feel of the game? What is the visual style?</p><p>游戏的基本外观和感觉是什么？ 什么是视觉风格？</p></blockquote><h2 id="Gameplay-游戏性"><a href="#Gameplay-游戏性" class="headerlink" title="Gameplay 游戏性"></a>Gameplay 游戏性</h2><h3 id="Objectives-目标"><a href="#Objectives-目标" class="headerlink" title="Objectives 目标"></a>Objectives 目标</h3><blockquote><p>What are the objectives of the game?</p><p>游戏的目标是什么？</p></blockquote><h3 id="Game-Progression-游戏进程"><a href="#Game-Progression-游戏进程" class="headerlink" title="Game Progression 游戏进程"></a>Game Progression 游戏进程</h3><h3 id="Play-Flow-游戏流程"><a href="#Play-Flow-游戏流程" class="headerlink" title="Play Flow 游戏流程"></a>Play Flow 游戏流程</h3><blockquote><p>How does the game flow for the game player</p><p>游戏玩家的游戏流程如何</p></blockquote><h3 id="Mission-challenge-Structure-任务-挑战结构"><a href="#Mission-challenge-Structure-任务-挑战结构" class="headerlink" title="Mission/challenge Structure 任务/挑战结构"></a>Mission/challenge Structure 任务/挑战结构</h3><h3 id="Puzzle-Structure-谜题结构"><a href="#Puzzle-Structure-谜题结构" class="headerlink" title="Puzzle Structure 谜题结构"></a>Puzzle Structure 谜题结构</h3><h2 id="Mechanics-Key-Section-机制（重点部分）"><a href="#Mechanics-Key-Section-机制（重点部分）" class="headerlink" title="Mechanics (Key Section) 机制（重点部分）"></a>Mechanics (Key Section) 机制（重点部分）</h2><h3 id="Rules-规则"><a href="#Rules-规则" class="headerlink" title="Rules 规则"></a>Rules 规则</h3><blockquote><p>What are the rules to the game, both implicit and explicit.</p><p>游戏的规则是什么，包括隐式和显式。</p></blockquote><h3 id="Model-of-the-game-universe-游戏世界模型"><a href="#Model-of-the-game-universe-游戏世界模型" class="headerlink" title="Model of the game universe 游戏世界模型"></a>Model of the game universe 游戏世界模型</h3><blockquote><p>Think of it as a simulation of a world, how do all the pieces interact?</p><p>把它想象成一个世界的模拟，所有的部分如何相互作用？</p></blockquote><h3 id="Physics-物理"><a href="#Physics-物理" class="headerlink" title="Physics 物理"></a>Physics 物理</h3><blockquote><p>How does the physical universe work?</p><p>物理宇宙是如何运作的？</p></blockquote><h3 id="Economy-经济"><a href="#Economy-经济" class="headerlink" title="Economy 经济"></a>Economy 经济</h3><blockquote><p>What is the economy of the game? How does it work?</p><p>游戏的经济是什么？ 它是如何工作的？</p></blockquote><h3 id="Character-movement-in-the-game-玩家移动方式"><a href="#Character-movement-in-the-game-玩家移动方式" class="headerlink" title="Character movement in the game 玩家移动方式"></a>Character movement in the game 玩家移动方式</h3><h3 id="Objects-物件"><a href="#Objects-物件" class="headerlink" title="Objects 物件"></a>Objects 物件</h3><blockquote><p>how to pick them up and move them</p><p>如何拿起和移动它们</p></blockquote><h3 id="Actions-动作"><a href="#Actions-动作" class="headerlink" title="Actions 动作"></a>Actions 动作</h3><blockquote><p>including whatever switches and buttons are used, interacting with objects, and what means of communication are used</p><p>包括使用的任何开关和按钮、与对象的交互以及使用的通信方式</p></blockquote><h3 id="Combat-战斗"><a href="#Combat-战斗" class="headerlink" title="Combat 战斗"></a>Combat 战斗</h3><blockquote><p>If there is combat or even conflict, how is this specifically modeled?</p><p>如果有战斗甚至冲突，这是如何具体建模的？</p></blockquote><h3 id="Screen-Flow-界面流程"><a href="#Screen-Flow-界面流程" class="headerlink" title="Screen Flow 界面流程"></a>Screen Flow 界面流程</h3><blockquote><p>How each screen is related to every other and a description of the purpose of each screen</p><p>每个屏幕如何相互关联以及每个屏幕的用途描述</p></blockquote><h3 id="Game-Options-游戏设置"><a href="#Game-Options-游戏设置" class="headerlink" title="Game Options 游戏设置"></a>Game Options 游戏设置</h3><blockquote><p>What are the options and how do they affect game play?</p><p>有哪些选项以及它们如何影响游戏体验？</p></blockquote><h3 id="Replaying-and-saving-存档"><a href="#Replaying-and-saving-存档" class="headerlink" title="Replaying and saving 存档"></a>Replaying and saving 存档</h3><h3 id="Cheats-and-Easter-Eggs-作弊码和彩蛋"><a href="#Cheats-and-Easter-Eggs-作弊码和彩蛋" class="headerlink" title="Cheats and Easter Eggs 作弊码和彩蛋"></a>Cheats and Easter Eggs 作弊码和彩蛋</h3><h2 id="Story-and-Narrative-故事与叙述"><a href="#Story-and-Narrative-故事与叙述" class="headerlink" title="Story and Narrative 故事与叙述"></a>Story and Narrative 故事与叙述</h2><h3 id="Back-story-背景故事"><a href="#Back-story-背景故事" class="headerlink" title="Back story 背景故事"></a>Back story 背景故事</h3><h3 id="Plot-elements-剧情元素"><a href="#Plot-elements-剧情元素" class="headerlink" title="Plot elements 剧情元素"></a>Plot elements 剧情元素</h3><h3 id="Game-story-progression-游戏剧情进展"><a href="#Game-story-progression-游戏剧情进展" class="headerlink" title="Game story progression 游戏剧情进展"></a>Game story progression 游戏剧情进展</h3><h3 id="Cut-scenes-剪辑场景"><a href="#Cut-scenes-剪辑场景" class="headerlink" title="Cut scenes 剪辑场景"></a>Cut scenes 剪辑场景</h3><blockquote><p>descriptions include the actors, the setting, and the storyboard or script.</p><p>说明包括演员，设置和故事板或脚本。</p></blockquote><h2 id="Game-World-游戏世界"><a href="#Game-World-游戏世界" class="headerlink" title="Game World 游戏世界"></a>Game World 游戏世界</h2><h3 id="General-look-and-feel-of-world-世界的一般外观和感觉"><a href="#General-look-and-feel-of-world-世界的一般外观和感觉" class="headerlink" title="General look and feel of world 世界的一般外观和感觉"></a>General look and feel of world 世界的一般外观和感觉</h3><h3 id="Areas-地区"><a href="#Areas-地区" class="headerlink" title="Areas 地区"></a>Areas 地区</h3><h4 id="General-description-and-physical-characteristics-一般描述和物理特性"><a href="#General-description-and-physical-characteristics-一般描述和物理特性" class="headerlink" title="General description and physical characteristics 一般描述和物理特性"></a>General description and physical characteristics 一般描述和物理特性</h4><h4 id="How-relate-to-the-rest-of-the-world-与世界其他地方的关系"><a href="#How-relate-to-the-rest-of-the-world-与世界其他地方的关系" class="headerlink" title="How relate to the rest of the world 与世界其他地方的关系"></a>How relate to the rest of the world 与世界其他地方的关系</h4><h5 id="What-levels-use-it-什么级别使用它"><a href="#What-levels-use-it-什么级别使用它" class="headerlink" title="What levels use it 什么级别使用它"></a>What levels use it 什么级别使用它</h5><h5 id="Connections-to-other-areas-与其他区域的连接"><a href="#Connections-to-other-areas-与其他区域的连接" class="headerlink" title="Connections to other areas 与其他区域的连接"></a>Connections to other areas 与其他区域的连接</h5><h2 id="Characters-人物"><a href="#Characters-人物" class="headerlink" title="Characters 人物"></a>Characters 人物</h2><h3 id="For-each-character-对于每个人物"><a href="#For-each-character-对于每个人物" class="headerlink" title="For each character 对于每个人物"></a>For each character 对于每个人物</h3><h4 id="Back-story-背景故事-1"><a href="#Back-story-背景故事-1" class="headerlink" title="Back story 背景故事"></a>Back story 背景故事</h4><h4 id="Personality-性格"><a href="#Personality-性格" class="headerlink" title="Personality 性格"></a>Personality 性格</h4><h4 id="Appearance-外貌"><a href="#Appearance-外貌" class="headerlink" title="Appearance 外貌"></a>Appearance 外貌</h4><h4 id="Abilities-能力"><a href="#Abilities-能力" class="headerlink" title="Abilities 能力"></a>Abilities 能力</h4><h4 id="Relevance-to-the-story-与故事的相关性"><a href="#Relevance-to-the-story-与故事的相关性" class="headerlink" title="Relevance to the story 与故事的相关性"></a>Relevance to the story 与故事的相关性</h4><h4 id="Relationship-to-other-characters-与其他角色的关系"><a href="#Relationship-to-other-characters-与其他角色的关系" class="headerlink" title="Relationship to other characters 与其他角色的关系"></a>Relationship to other characters 与其他角色的关系</h4><h3 id="Artificial-Intelligence-Use-in-Opponent-and-Enemy-人工智能在对手和敌人中的使用"><a href="#Artificial-Intelligence-Use-in-Opponent-and-Enemy-人工智能在对手和敌人中的使用" class="headerlink" title="Artificial Intelligence Use in Opponent and Enemy 人工智能在对手和敌人中的使用"></a>Artificial Intelligence Use in Opponent and Enemy 人工智能在对手和敌人中的使用</h3><h3 id="Non-combat-and-Friendly-Characters-非战斗和友好角色"><a href="#Non-combat-and-Friendly-Characters-非战斗和友好角色" class="headerlink" title="Non-combat and Friendly Characters 非战斗和友好角色"></a>Non-combat and Friendly Characters 非战斗和友好角色</h3><h2 id="Levels-关卡"><a href="#Levels-关卡" class="headerlink" title="Levels 关卡"></a>Levels 关卡</h2><h3 id="Training-Level-训练关卡"><a href="#Training-Level-训练关卡" class="headerlink" title="Training Level 训练关卡"></a>Training Level 训练关卡</h3><h3 id="For-each-level-对于每个关卡"><a href="#For-each-level-对于每个关卡" class="headerlink" title="For each level 对于每个关卡"></a>For each level 对于每个关卡</h3><h4 id="Synopsis-概要"><a href="#Synopsis-概要" class="headerlink" title="Synopsis 概要"></a>Synopsis 概要</h4><h4 id="Required-introductory-material-and-how-it-is-provided-所需的介绍材料及其提供方式"><a href="#Required-introductory-material-and-how-it-is-provided-所需的介绍材料及其提供方式" class="headerlink" title="Required introductory material and how it is provided 所需的介绍材料及其提供方式"></a>Required introductory material and how it is provided 所需的介绍材料及其提供方式</h4><h4 id="Objectives-目标-1"><a href="#Objectives-目标-1" class="headerlink" title="Objectives 目标"></a>Objectives 目标</h4><h4 id="Details-of-what-happens-in-the-level-关卡中发生的事情的详细信息"><a href="#Details-of-what-happens-in-the-level-关卡中发生的事情的详细信息" class="headerlink" title="Details of what happens in the level 关卡中发生的事情的详细信息"></a>Details of what happens in the level 关卡中发生的事情的详细信息</h4><h5 id="Map-地图"><a href="#Map-地图" class="headerlink" title="Map 地图"></a>Map 地图</h5><h5 id="Critical-path-that-the-player-needs-to-take-玩家需要走的关键路径"><a href="#Critical-path-that-the-player-needs-to-take-玩家需要走的关键路径" class="headerlink" title="Critical path that the player needs to take 玩家需要走的关键路径"></a>Critical path that the player needs to take 玩家需要走的关键路径</h5><h5 id="Important-and-incidental-encounters-重要和偶然的相遇"><a href="#Important-and-incidental-encounters-重要和偶然的相遇" class="headerlink" title="Important and incidental encounters 重要和偶然的相遇"></a>Important and incidental encounters 重要和偶然的相遇</h5><h2 id="Interface-界面"><a href="#Interface-界面" class="headerlink" title="Interface 界面"></a>Interface 界面</h2><h3 id="Visual-System-视觉系统"><a href="#Visual-System-视觉系统" class="headerlink" title="Visual System 视觉系统"></a>Visual System 视觉系统</h3><h4 id="HUD-显示器"><a href="#HUD-显示器" class="headerlink" title="HUD 显示器"></a>HUD 显示器</h4><h4 id="Menus-菜单"><a href="#Menus-菜单" class="headerlink" title="Menus 菜单"></a>Menus 菜单</h4><h4 id="Camera-model-镜头机位"><a href="#Camera-model-镜头机位" class="headerlink" title="Camera model 镜头机位"></a>Camera model 镜头机位</h4><h3 id="Control-System"><a href="#Control-System" class="headerlink" title="Control System"></a>Control System</h3><blockquote><p>How does the game player control the game? What are the specific commands?</p><p>玩家如何控制游戏？ 具体命令是什么？</p></blockquote><h3 id="Audio-music-sound-effects-音频、音乐、音效"><a href="#Audio-music-sound-effects-音频、音乐、音效" class="headerlink" title="Audio, music, sound effects 音频、音乐、音效"></a>Audio, music, sound effects 音频、音乐、音效</h3><h3 id="Game-Art-游戏美术"><a href="#Game-Art-游戏美术" class="headerlink" title="Game Art 游戏美术"></a>Game Art 游戏美术</h3><blockquote><p>intended style</p><p>预期风格</p></blockquote><h3 id="Help-System-帮助系统"><a href="#Help-System-帮助系统" class="headerlink" title="Help System 帮助系统"></a>Help System 帮助系统</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 策划 </category>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏策划文件 </tag>
            
            <tag> GDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置 C# 版本的 Godot</title>
      <link href="/2023/c6bb9b86.html"/>
      <url>/2023/c6bb9b86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Godot 引擎支持使用 C# 语言进行开发，C# 语言提供了一系列性能强大的 API 让游戏运行性能更加好，但是需要注意处理它的资源回收。本文将说明怎么配置 C# 版本的 Godot，用的代码编辑器为 Visual Studio 2022</p><h2 id="食材准备"><a href="#食材准备" class="headerlink" title="食材准备"></a>食材准备</h2><p>下载 .NET 版本的 <a href="https://godotengine.org/download/windows/">Godot 引擎</a></p><p><img src="/uploads/godot-csharp-setup/download-godot-engine.png" alt="下载 Godot 引擎"></p><p>将 Godot 引擎解压到你的计算机中，任意位置即可。</p><p>下载并安装 .NET SDK 6.0 以上（亲测 8.0 可运行）<a href="https://dotnet.microsoft.com/download">DotNet SDK</a></p><p><img src="/uploads/godot-csharp-setup/dotnet-8-download-page.png" alt=".NET 8.0 下载页面"></p><p>下载 Visual Studio Community 2022 （2019 - 2022 应该都是兼容的）</p><p><img src="/uploads/godot-csharp-setup/visual-studio-download-page.png" alt="Visual Studio 2022 下载页面"></p><p>安装 Visual Studio 的时候，请选择 <code>.Net Desktop Development</code> 工作包</p><p><img src="/uploads/godot-csharp-setup/visual-studio-installer-page.png" alt="Visual Studio 2022 安装界面"></p><h2 id="Godot-环境配置"><a href="#Godot-环境配置" class="headerlink" title="Godot 环境配置"></a>Godot 环境配置</h2><p>打开 Godot 引擎创建 / 打开一个项目</p><ol><li>到 <code>Editor &gt; Editor Settings &gt; Dotnet &gt; Editor &gt; External Editor</code><ol><li>先打开 <code>Editor &gt; Editor Settings</code></li><li>在 Editor Settings 左侧找到 <code>Dotnet &gt; Editor</code></li><li>在右侧找到 <code>External Editor</code> 字段</li></ol></li><li>将 <code>External Editor</code> 字段修改为 Visual Studio</li></ol><p><img src="/uploads/godot-csharp-setup/godot-external-editor-setting.png" alt="Godot 外部编辑器环境设置"></p><h2 id="创建一个脚本进行测试"><a href="#创建一个脚本进行测试" class="headerlink" title="创建一个脚本进行测试"></a>创建一个脚本进行测试</h2><p>创建任意一种 Node 节点，然后挂载一个脚本在上方。如我创建了一个 <code>Node2D</code> 节点，将其命名为 <code>TestNode</code>。这时候保存为 <code>test_node.tscn</code> 。然后挂载一个脚本，</p><p><img src="/uploads/godot-csharp-setup/attach-csharp-script.png" alt="挂载一个 C# 脚本"></p><p>内容随意写，比如：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Godot;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">TestNode</span> : <span class="title">Node2D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Member variables here, example:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _b = <span class="string">&quot;textvar&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> _Ready()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Called every time the node is added to the scene.</span></span><br><span class="line">        <span class="comment">// Initialization here.</span></span><br><span class="line">        GD.Print(<span class="string">&quot;Hello from C# to Godot :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> _Process(<span class="built_in">double</span> delta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Called every frame. &#x27;delta&#x27; is time since the last frame.</span></span><br><span class="line">        <span class="comment">// Update game logic here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后返回到 Godot 引擎中，这时候会发现右上角运行菜单左侧出现一个锤子按钮。点击它进行项目构建。</p><p><img src="/uploads/godot-csharp-setup/build-project-button.png" alt="构建项目按钮"></p><p>等待加载完成后，运行项目。到这里就完成啦！开发愉快</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>官网文档中还有很多细节这里没提到，可以自行去看看哟。后续如果有需要，我还会继续发布心得笔记。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html">https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Godot 4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio </tag>
            
            <tag> Godot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么在 Godot 中实现多语言切换</title>
      <link href="/2023/a0acc8c4.html"/>
      <url>/2023/a0acc8c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在小游戏中，可能没那么重视多语言支持。但是想将自己的作品放入国际市场，那么还是需要在<strong>本地化（Localization）</strong>下功夫的。而 Godot 引擎已经为我们提供了一些 API 和示例<sup><a href="#1">[1]</a></sup>。而这篇文章是我在实际操作中，对于官方教程没说明白的补充。</p><p>因为自己的项目需要，所以暂时只对文本进行替换。事实上 Godot 内置的本地化功能还包括了游戏资源（语音 / 图片等……）替换。功能非常强大</p><blockquote><p>本教程并没有在游戏 UI 上深究，主要是在怎么实现最简单的多语言切换功能。</p></blockquote><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>当用户点击后左下角的旗帜标识，界面中的所有文本将会被切换。包括右下角的版本信息（那是通过代码进行替换的），所以本文会涉及到游戏文本的多语言适配。</p><p><img src="/uploads/godot-localizations/result_cn.png" width="80%" alt="游戏以中文界面展示"/><br><img src="/uploads/godot-localizations/result_en.png" width="80%" alt="Game shows in English"/></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>Godot 版本：Godot 4.x （在本教程撰写时，Godot 4.2 是可以操作的，理论上这种基础功能的 API 会一直被沿用，如果有问题，欢迎在 Github 中给出 Issue。我会去更新文章）</li><li>一个记录了本游戏所有文本及其对应翻译的 csv 文件，下方会有该 csv 文件的内容要求。</li><li>UI 素材：我用到了像素风的各国 / 地区国旗。这些文件可以在 <a href="https://lukasfdahl.itch.io/asia-flags">亚洲旗帜</a> 和 <a href="https://lukasfdahl.itch.io/american-flags">美洲旗帜</a> 中下载。感谢 <a href="https://lukasfdahl.itch.io/">lukasfdahl</a> 的贡献。<ul><li>作者声明及版权信息：Each flag is 16 x 16. The flags is free to use for anything but please credit me for them somewhere. </li><li>这些旗帜可以免费用于任何用途，但请在某处给予我署名。</li></ul></li></ul><h2 id="准备所有文件"><a href="#准备所有文件" class="headerlink" title="准备所有文件"></a>准备所有文件</h2><ol><li>我们在项目中的根目录 <code>res://</code> 下创建一个 <code>localization</code> 目录（可选，这只是为了后续项目中的文件显得有条不紊）</li><li>将下载好的 亚洲旗帜 和 美洲旗帜 拖入到这个文件夹中</li><li>右键 <code>localization</code> 文件夹，然后点击 <code>Open in File Manager</code> 在资源管理器中打开该目录</li><li>新建一个 csv 文件，名字随意，这里我将其命名为 <code>game_text.csv</code>，内容如下</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KEYS,en_US,zh_CN</span><br><span class="line">GAME_NAME,My Idle Game,我的挂机游戏</span><br><span class="line">START_GAME,Start Game,开始游戏</span><br><span class="line">SETTING,Settings,设置</span><br><span class="line">EXIT_GAME,Exit Game,退出游戏</span><br><span class="line">NEWS,Update News,游戏公告</span><br><span class="line">DATA_SETTINGS,Data Settings,游戏数据设置</span><br><span class="line">VERSION,Game Versions,游戏版本</span><br><span class="line">DEBUG,Debug,测试版</span><br></pre></td></tr></table></figure><p>很乱？没关系，我们将其转换成表格就一目了然了。当然，keys 字段用全大写，两个单词之间的空格用下划线 <code>_</code> 代替，这么做的用途是可以避免在游戏中重复使用。</p><div class="table-container"><table><thead><tr><th>KEYS</th><th>en_US</th><th>zh_CN</th></tr></thead><tbody><tr><td>GAME_NAME</td><td>My Idle Game</td><td>我的挂机游戏</td></tr><tr><td>START_GAME</td><td>Start Game</td><td>开始游戏</td></tr><tr><td>SETTING</td><td>Settings</td><td>设置</td></tr><tr><td>EXIT_GAME</td><td>Exit Game</td><td>退出游戏</td></tr><tr><td>NEWS</td><td>Update News</td><td>游戏公告</td></tr><tr><td>DATA_SETTINGS</td><td>Data Settings</td><td>游戏数据设置</td></tr><tr><td>VERSION</td><td>Game Versions</td><td>游戏版本</td></tr><tr><td>DEBUG</td><td>Debug</td><td>测试版</td></tr></tbody></table></div><p>这就是翻译文件的内容。当然你也可以加入更多国家 / 地区的文本。如繁体、日文等。可以参考<a href="https://blog.csdn.net/shenenhua/article/details/79150053">语言(文化)代码与国家地区对照表(最全的各国地区对照表)</a></p><ol><li>回到 Godot 引擎。这时候系统会自动生成两个（或多个，如果你的语言更多的话）二进制 <code>.translation</code> 文件。如果没有，将 csv 文件 reimport 重新导入就好了。</li><li>在 <code>localization</code> 文件夹中创建两个 <code>Atlas Texture</code> 类型的资源。分别命名为两种语言的标识（自定义），这里我直接用了他俩的名字 <code>zh_CN.tres</code> 和 <code>en_US.tres</code>。</li><li>将下载好的国旗集分别调整成对应的切图。</li></ol><p>完成上述步骤后，我们的 <code>localization</code> 文件夹应该包含这些文件：</p><p><img src="/uploads/godot-localizations/file_structures.png" alt="localization 目录文件"></p><h2 id="界面设计"><a href="#界面设计" class="headerlink" title="界面设计"></a>界面设计</h2><p>这里我随意设计了一下界面，可以参考最开始的成品展示，或者通过 UI 知识，自己手动设计一个游戏主菜单。</p><blockquote><p>注意，所有需要进行本地化的文本，它的占位符需要与上面定义 <code>.csv</code> 文件的 KEYS 字段名一致！比如游戏名字的 Label，它的 text = <code>GAME_NAME</code>。然后其他的字符串，如右下角的 <code>VERSION</code> 是多语言占位符。而 <code>V 1.0.0.0</code> 是普通的占位符。</p></blockquote><p><img src="/uploads/godot-localizations/ui_designs.png" alt="界面设计"></p><p>左下角是 textureButton，它的 texture 就是刚刚我们创建的 Atlas Texture 旗帜。</p><p>然后确保每一个控件（有文本的）他们的 <code>Inspector &gt; Localization &gt; Auto Translate</code> 为勾选状态（默认都是勾选的）</p><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><p>到 <code>Project &gt; Project Settings... &gt; Localization</code> 中，添加文件，将第 5 步创建的 <code>.translation</code> 文件全部添加进来。</p><p><img src="/uploads/godot-localizations/project_setting_localization.png" alt="项目设置 Localization 标签页"></p><p>到了这一步，点击项目运行，这时候所有的占位符都会自动替换成英文（默认情况下，游戏语言是 en，所以会自动替换成英文）</p><h2 id="语言切换"><a href="#语言切换" class="headerlink" title="语言切换"></a>语言切换</h2><p>接下来该为那两颗语言按钮赋能了。将他们俩的 <code>pressed()</code> 信号链接到代码中，这里我将所有主页面代码都放在 <code>title.gd</code> 里。直接上代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func _on_en_us_pressed() -&gt; void:</span><br><span class="line">TranslationServer.set_locale(&quot;en_US&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _on_zh_cn_pressed() -&gt; void:</span><br><span class="line">TranslationServer.set_locale(&quot;zh_CN&quot;)</span><br></pre></td></tr></table></figure><p>这里其实就是当按钮点击之后，使用 <code>TranslationServer</code><sup><a href="#2">[2]</a></sup> 的 <code>set_locale</code> 方法将项目中的 locale 替换成想要的语言。</p><h2 id="通过代码切换文本"><a href="#通过代码切换文本" class="headerlink" title="通过代码切换文本"></a>通过代码切换文本</h2><p>这时候可以注意到，游戏界面中右下角的版本号只替换了 Game Version 的值，对游戏中 Debug 和 测试版 的值并没有显示出来。这时需要在代码中加入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func _update_version_text():</span><br><span class="line">version_text.text = &quot;V.&quot; + Global.game_version + (&quot;_&quot; + tr(&quot;DEBUG&quot;) if Global.is_debug_mode else &quot;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func _notification(what: int) -&gt; void:</span><br><span class="line">if what == NOTIFICATION_TRANSLATION_CHANGED:</span><br><span class="line">_update_version_text()</span><br></pre></td></tr></table></figure><p>啊咧？怎么一下子这么多东西？别急，我们来逐行分析。</p><ul><li>首先是 <code>_update_version_text()</code> 函数中的执行逻辑<ul><li><code>version_text</code> 是界面设计中，用来显示版本号的 label 控件；</li><li>我们拼接字符串并赋值给 <code>version_text.text</code>。<ul><li><code>Global.game_version</code> 是我们定义了一个全局的变量（挖个坑，怎么添加全局变量），里面保存了游戏的版本号</li><li><code>Global.is_debug_mode</code> 同理。将他俩当作一个变量就好了。这个定义了游戏是否为调试模式。</li><li><code>tr(&quot;DEBUG&quot;)</code> 是调用 <code>tr</code> 函数<sup><a href="#3">[3]</a></sup>，用来获取某个翻译之后的值。 <code>DEBUG</code> 则是我们在 csv 文件中定义的 <code>KEY</code>。</li></ul></li><li>所以整个字符串拼接逻辑是：<ul><li>拼接 <code>V.</code> 和 游戏版本号。</li><li>如果游戏为调试模式（<code>is_debug_mode == true</code>），则再拼接上 <code>_Debug</code> 或 <code>_测试版</code></li></ul></li></ul></li><li>再来是 <code>_notification(what: int)</code> 函数：<ul><li>该函数只有在出发某个 notification 的时候会被调用</li><li>判断 <code>what == NOTIFICATION_TRANSLATION_CHANGED</code>，见字知意：当翻译切换时，执行操作</li><li>调用 <code>_update_version_text()</code> 来执行更新版本信息的操作。</li></ul></li></ul><p>这时候开始游戏，点击左下角的地区按钮，会看到地区切换了。</p><h2 id="修改默认语言（未在发行版本中测试）"><a href="#修改默认语言（未在发行版本中测试）" class="headerlink" title="修改默认语言（未在发行版本中测试）"></a>修改默认语言（未在发行版本中测试）</h2><p>最后！我们发现当开启游戏时，默认显示的是英文 （en）。想要调整，很简单，打开 <code>Project &gt; Project Settings... &gt; General</code> 再界面中开启 <code>Advance Settings</code>，然后在左侧找到 <code>Internationalization &gt; Locale &gt; Test</code>。将 <code>Test</code> 的值改为 <code>zh_CN</code> 即可。</p><p><img src="/uploads/godot-localizations/project_setting_internationalization.png" alt="项目设置 Internationalization"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>到这里应该实现了基础的文本 Localization 功能了。如果在实现过程中遇到麻烦，可以直接到 GitHub 上 <a href="https://github.com/Kingsmai/kingsmai.github.io/issues">点击这里</a> 给我 Issue。我会及时进行调整。谢谢您的阅读！祝您开发顺利！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a id="1">[1]</a> Internationalizing games — Godot Engine (stable) documentation in English <a href="https://docs.godotengine.org/en/stable/tutorials/i18n/internationalizing_games.html#internationalizing-games">https://docs.godotengine.org/en/stable/tutorials/i18n/internationalizing_games.html#internationalizing-games</a></p><p><a id="2">[2]</a> TranslationServer — Godot Engine (stable) documentation in English <a href="https://docs.godotengine.org/en/stable/classes/class_translationserver.html">https://docs.godotengine.org/en/stable/classes/class_translationserver.html</a></p><p><a id="3">[3]</a> Object — Godot Engine (4.2) documentation in English <a href="https://docs.godotengine.org/en/4.2/classes/class_object.html#class-object-method-tr">https://docs.godotengine.org/en/4.2/classes/class_object.html#class-object-method-tr</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 编程语言 </category>
          
          <category> Godot 4 </category>
          
          <category> 游戏开发 </category>
          
          <category> GdScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地化 Localization </tag>
            
            <tag> 游戏 UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目构思】论文格式辅助器</title>
      <link href="/2023/91ffea1c.html"/>
      <url>/2023/91ffea1c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>到了期末，大学生们最头痛的应该就是论文格式问题。我在想啊，如果大学生能够只需要操心论文的内容就行了，专心搞科研，而不是把大量时间花费在重复的设置 Word 上。我知道大部分大学的学院都会发 Word 模板文件，但是根据学生的科研内容不同、Office / WPS 的版本不同、甚至是系统地区设置不同等客观因素，肯定会有一些奇怪的格式错误。就算大家的电脑统一，版本唯一，还是可能因为个人操作或者打印机的问题而导致格式有出入。那为什么就没有一个机构把论文格式统一咧？查了一下资料，发现每个学校对论文的格式以及查重的要求和查重系统都是不一样的，一定要以学校要求的为准，一般学校都会发通告，或者询问老师格式要求<sup><a href="#1">[1]</a></sup>。那既然没有办法统一学术论文的要求，那能不能有一个可以不让学生操心论文格式的系统呢？</p><h2 id="论文格式辅助器的构思"><a href="#论文格式辅助器的构思" class="headerlink" title="论文格式辅助器的构思"></a>论文格式辅助器的构思</h2><p>想象有这么一款辅助工具，用户只需要输入自己的论文内容即可，程序会帮忙处理一切格式和引用相关的问题。呃，有没有相关的软件可以参照呢？有的，国外有一个开源软件 <a href="https://github.com/xitanggg/open-resume">OpenResume</a> 就是这种功能，它可以让用户直接输入自己的个人信息，然后系统自动生成格式统一的简历。那求职者可以节省不少时间在设计简历上。同样的，hexo 、 hugo 等框架也是让开发者 / 博主只需要关注内容，只需要直接套用主题等，而不需要繁琐的建站及 HTML 知识，让博主能够专心的思考博文，而不需要去操心页面的设计。</p><h2 id="策划"><a href="#策划" class="headerlink" title="策划"></a>策划</h2><p>我的想法是这样的，可以写个框架，就是论文中每个核心的组件样式都能更改，然后定义一个标准，通过一种数据结构去调整每个样式。学校发布格式的时候，直接改那个数据结构的值即可。比如说我们可以用 yaml 去定义格式：</p><figure class="highlight yaml"><figcaption><span>论文格式配置文件（节选）</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="string">核心:</span></span><br><span class="line">  <span class="comment"># 页边距 (mm)</span></span><br><span class="line">  <span class="string">页边距:</span></span><br><span class="line">    <span class="string">上边距:</span> <span class="number">25</span></span><br><span class="line">    <span class="string">下边距:</span> <span class="number">20</span></span><br><span class="line">    <span class="string">左边距:</span> <span class="number">30</span></span><br><span class="line">    <span class="string">右边距:</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="string">封面:</span></span><br><span class="line">  <span class="string">学院:</span> <span class="string">计算机与自动化学院</span></span><br><span class="line">  <span class="string">专业:</span> <span class="string">计算机科学与技术</span></span><br><span class="line">  <span class="string">字体:</span> <span class="string">宋体</span></span><br><span class="line">  <span class="comment"># 字号: 可以是中文的字号（小三）或数字字号 12</span></span><br><span class="line">  <span class="string">字号:</span> <span class="string">小三</span></span><br></pre></td></tr></table></figure><p>所以当学院 / 论文发布机构定义论文格式时，可以顺带发布对应的 yaml 文件。让学生去读取该文件，而学生再也不需要去操心论文格式了。直接以内容为导向，写出更加优秀的论文。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>可能因为了解学术论文的格式是每个科研人员必须掌握的技能，所以市面上没有出现类似工具。但还是希望有一个工具能够解决这个问题，让科研人员能够高效产出论文，而不需要将时间花费在各种格式调整上。当然，学院是否采纳我们的这个让学生取巧的方法去撰写论文，那就是见仁见智的事情了。</p><p>关注我，后续持续发布这个辅助工具的开发进度</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a id="1">[1]</a> 为什么网上的论文格式要求都不一样? - 欢囍的回答 - 知乎 <a href="https://www.zhihu.com/question/532929780/answer/2553717449">https://www.zhihu.com/question/532929780/answer/2553717449</a></p>]]></content>
      
      
      <categories>
          
          <category> 策划 </category>
          
          <category> 项目构思 </category>
          
          <category> 大学生相关项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文辅助器 </tag>
            
            <tag> 论文格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（5）</title>
      <link href="/2023/6fc25489.html"/>
      <url>/2023/6fc25489.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>影响机器学习效果可能的原因：算法 / 数据处理的怎么样（特征工程）</p><h2 id="为什么需要特征工程（Feature-Engineering）"><a href="#为什么需要特征工程（Feature-Engineering）" class="headerlink" title="为什么需要特征工程（Feature Engineering）"></a>为什么需要特征工程（Feature Engineering）</h2><blockquote><p>数据和特征决定了机器学习的上限，模型和算法只是逼近这个上限而已。</p><p>吴恩达老师说：Coming up with features is difficult, time-consuming, requires expert knowledge, “Applied machine learning” is basically feature engineering.</p></blockquote><p>特征工程是使用专业背景知识和技巧处理数据，是的特征能在机器学习算法上发挥更好的作用的过程。意义：会直接影响机器学习的效果。</p><ul><li>Pandas：一般用来数据清洗和数据处理</li><li>SkLearn：用来进行特征工程</li></ul><p><strong>特征工程包含内容：</strong></p><h3 id="特征抽取-特征提取"><a href="#特征抽取-特征提取" class="headerlink" title="特征抽取 / 特征提取"></a>特征抽取 / 特征提取</h3><p>假设对一篇短文做文章分类，想要用机器学习的算法去做，会出现什么问题？机器学习算法<sup><a href="#注1">[注1]</a></sup>是数学公式，无法处理字符串，所以需要对数据集进行转换成数值。将任意数据（如文本或图像）转换为可用于机器学习的数字特征。</p><blockquote><p>特征值化是为了计算机更好的去理解数据</p></blockquote><ul><li>字典特征提取（特征离散化）</li><li>文本特征提取</li><li>图像特征提取（这部分，深度学习将介绍）</li></ul><p>我们可以使用 <code>sklearn.feature_extraction</code> api 进行特征提取</p><h4 id="字典特征提取"><a href="#字典特征提取" class="headerlink" title="字典特征提取"></a>字典特征提取</h4><p>作用：对字典数据进行特征值化</p><p><code>sklearn.feature_extraction.DictVectorizer(sparse=True, ...)</code>，理解为将字典进行向量化。将向量存储到计算机中（可以通过 <strong>矩阵（Matrix）</strong> 方法去存储，也就是变为 <strong>二维数组</strong>）。所以向量可以通过 <strong>一维数组</strong> 进行存储。</p><p>比如说我们有这么一个数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">100</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">60</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么转换后的数据会变成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;city=上海&#x27;, &#x27;city=北京&#x27;, &#x27;city=深圳&#x27;, &#x27;temperature&#x27;]</span><br><span class="line">[[ 0. 1. 0. 100.],</span><br><span class="line"> [ 1. 0. 0.  60.],</span><br><span class="line"> [ 0. 0. 1.  30.]]</span><br></pre></td></tr></table></figure><p>为什么会转换成这个样子<sup><a href="#注2">[注2]</a></sup>？</p><blockquote><p>所以字典特征读取实际上是将属于类别的特征转换成 OneHot 编码。</p></blockquote><p>这个转换之后的父类就是一个 transform 转换器类，里面包含了一些方法：</p><ul><li><code>DictVectorizer.fit_transform(x)</code><ul><li>x: 字典或者包含字典的迭代器返回值</li><li>返回 sparse 矩阵<sup><a href="#注3">[注3]</a></sup></li></ul></li><li><code>DictVectorizer.inverse_transform(x)</code><ul><li>x: array 数组或者 sparse 矩阵</li><li>返回值：转换之前的数据格式</li></ul></li><li><code>DictVectorizer.get_feature_names()</code><ul><li>返回类别名称</li></ul></li></ul><p>字典特征抽取的应用场景：</p><ol><li>数据集当中，类别特征比较多的情况下，将数据集的特征转换成字典类型，再用 DictVectorizer 进行转换</li><li>拿到的数据就是数据的话，那就用字典特征抽取</li></ol><h4 id="文本特征抽取"><a href="#文本特征抽取" class="headerlink" title="文本特征抽取"></a>文本特征抽取</h4><p>用单词作为特征</p><h3 id="特征预处理"><a href="#特征预处理" class="headerlink" title="特征预处理"></a>特征预处理</h3><h3 id="特征降维"><a href="#特征降维" class="headerlink" title="特征降维"></a>特征降维</h3><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><a id="注1">[注1]</a> 机器学习算法：机器学习是一群高统计学的人使用<strong>统计方法</strong>搞出来的，所以涉及到的都是<strong>数学公式</strong>。要将一些非数学的数据进行处理，我们需要：</p><ul><li>文本类型 转换成 数值</li><li>类型 转换成 数值</li></ul><p><a id="注2">[注2]</a> 为什么会转换成那样的矩阵的解释。我们看回原始数据（字典），每个样本有两个特征。按理来说应该转换为三行两列的矩阵。但是实际上我们转换得到的是三行四列的矩阵（样本量不变，特征量变成了 4 个）。当特征中有类别（北京、上海、深圳）的表示方式为字符串，想表示为数值，并且没有数值上大小差别的数据，就需要用 OneHot 编码 / 哑变量。实际上可以理解为这样的一个表：</p><div class="table-container"><table><thead><tr><th>city=上海</th><th>city=北京</th><th>city=深圳</th><th>temperature</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>100</td></tr><tr><td>1</td><td>0</td><td>0</td><td>60</td></tr><tr><td>0</td><td>0</td><td>1</td><td>30</td></tr></tbody></table></div><p><a id="注3">[注3]</a> 为什么是返回 spouse 矩阵？spouse 矩阵是什么？当我们执行代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction <span class="keyword">import</span> DictVectorizer</span><br><span class="line"></span><br><span class="line">data = [</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">100</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">60</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;深圳&quot;</span>, <span class="string">&quot;temperature&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 1. 实例化一个转换器类</span></span><br><span class="line">transform = DictVectorizer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 调用 fit_transform 方法，传入包含字典的迭代器</span></span><br><span class="line">data_new = transform.fit_transform(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data_new)</span><br></pre></td></tr></table></figure><p>时，返回值是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0, 1)        1.0</span><br><span class="line">(0, 3)        100.0</span><br><span class="line">(1, 0)        1.0</span><br><span class="line">(1, 3)        60.0</span><br><span class="line">(2, 2)        1.0</span><br><span class="line">(2, 3)        30.0</span><br></pre></td></tr></table></figure><p>这是稀疏矩阵（Sparse Matrix），为什么要返回这种形式？当我们调用 <code>sklearn.feature_extraction.DictVectorizer(sparse=True, ...)</code> ，默认就返回 sparse 矩阵。如果需要还原成我们想看到比较直观的，可以在实例化转换器类时，这样写：<code>transform = DictVectorizer(sparse=False)</code>。这样，返回值就会变成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[  0.   1.   0. 100.]</span><br><span class="line"> [  1.   0.   0.  60.]</span><br><span class="line"> [  0.   0.   1.  30.]]</span><br></pre></td></tr></table></figure><p>可以看到，其实 sparse 矩阵的左侧时位置，右侧是值。稀疏矩阵将非零值按位置表示出来，这样存储显而易见的比较节省内存，提高加载效率</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> BiliBili 黑马自学机器学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 特征工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（4）</title>
      <link href="/2023/d77e33ec.html"/>
      <url>/2023/d77e33ec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于机器学习，我们最先需要获取数据集。一般上，广告投放也是基于机器学习去分析用户对什么事务感兴趣（有时候用户在不经意间的搜索、对话等过程中会透露），然后再对其喜好的事务进行广告投放。那么这个机器学习的数据集就来自公司产品的用户生成内容（UGC）。还有的情况是公司之间通过合作或协议，开放接口进行数据分享，让两家不同的公司同时享有共同数据。所以现实生活中会出现我在 A 平台说过这个东西，在 B 平台的广告会推送相关产品。</p><p>对于初学者，很多时候我们都没法获得大厂中的数据集，但是学习机器学习，我们可以通过一些国内外的机构所开源的数据集进行操作，去了解它的核心思路。常见的数据集有：</p><ol><li>Kaggle <a href="https://www.kaggle.com/datasets">https://www.kaggle.com/datasets</a></li><li>UCI Machine Learning Repository <a href="https://archive.ics.uci.edu/">https://archive.ics.uci.edu/</a></li><li>Scikit learn <a href="https://scikit-learn.org/stable/datasets/toy_dataset.html">https://scikit-learn.org/stable/datasets/toy_dataset.html</a></li></ol><h2 id="Scikit-learn-数据集"><a href="#Scikit-learn-数据集" class="headerlink" title="Scikit-learn 数据集"></a>Scikit-learn 数据集</h2><p>对于初学者来说，我们可以使用 scikit learn 进行学习。scikit learn 包含了许多知名的机器学习算法的实现，文档完善，易于上手，并拥有丰富的 API。</p><p>Scikit-learn 包含了以下</p><ol><li>Classification 归类</li><li>Regression 回归</li><li>Clustering 聚类</li><li>Dimensionality reduction 降维</li><li>Model Selection 模型选择</li><li>Prepossessing 预处理</li></ol><p>我们可以通过</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install Scikit-learn</span><br></pre></td></tr></table></figure><p>来安装 Scikit-learn 库。</p><h2 id="sklearn-数据集"><a href="#sklearn-数据集" class="headerlink" title="sklearn 数据集"></a>sklearn 数据集</h2><p>当我们安装好之后，我们可以访问 scikit-learn 中的数据集。使用 <code>sklearn.datasets</code> 可以加载流行的数据集。</p><ol><li><code>load_*()</code><ol><li><code>*</code> 表示需要加载的数据集，如 iris</li><li>获取小规模的数据集，数据包含在 datasets 里</li><li>常用的数据集有：<ol><li><code>load_iris()</code> 鸢尾花数据集</li><li><code>load_boston()</code> 波斯顿房价</li></ol></li></ol></li><li><code>fetch_*(data_home=None)</code><ol><li>获取大规模的数据集，需要从网络上下载，函数的第一个参数是 data_home，表示数据集下载的目录。默认是 <code>~/scikit_learn_data/</code></li><li>比如说 <code>fetch_20newsgroups(data_home=None, subset=&quot;train&quot;)</code><ol><li>subset 可选值为：<code>train</code> 训练集, <code>test</code> 测试集, <code>all</code> 全部 选择要加载的数据集</li></ol></li></ol></li></ol><h2 id="sklearn-数据集的使用"><a href="#sklearn-数据集的使用" class="headerlink" title="sklearn 数据集的使用"></a>sklearn 数据集的使用</h2><p>鸢尾花数据集中，特征值有四个：花瓣、花萼的长度、宽度；目标值有三个：setosa，vericolor，virginica</p><p>调用 fetch / load 都会返回一个 Bunch （字典格式）类型数据。它的键 key 有：</p><ul><li>data: 特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组</li><li>target: 标签数组，是 n_samples 的一维 numpy.ndarray 数组</li><li>DESCR: 数据描述</li><li>feature_names: 特征名，（新闻数据、手写数字、回归数据集没有）</li><li>target_names: 标签名</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花数据集的返回值为：\n&quot;</span>, iris)</span><br><span class="line"><span class="comment"># 返回值是一个继承自字典的 Bunch</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花的特征值：\n&quot;</span>, iris[<span class="string">&quot;data&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花的目标值：\n&quot;</span>, iris.target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花特征的名字：\n&quot;</span>, iris.feature_names)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花目标值的名字：\n&quot;</span>, iris.target_names)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;鸢尾花的描述：\n&quot;</span>, iris.DESCR)</span><br></pre></td></tr></table></figure><p><strong>拿到的数据可不可以全部用来训练模型？</strong>不行，因为训练模型的步骤其中一项是模型评估，假设我们将所有数据都拿去训练模型了，那就没有多余的数据进行模型评估，也就没有办法知道这个模型的质量了。为此我们需要保留一部分数据用于训练，构建模型；一份后续做检验模型时用，用于评估模型是否有效。一般上保留比例为：</p><div class="table-container"><table><thead><tr><th></th><th>方式一</th><th>方式二</th><th>方式三</th></tr></thead><tbody><tr><td>训练集</td><td>70%</td><td>80%</td><td>75%</td></tr><tr><td>测试集</td><td>30%</td><td>20%</td><td>30%</td></tr></tbody></table></div><h2 id="在-sklearn-进行划分"><a href="#在-sklearn-进行划分" class="headerlink" title="在 sklearn 进行划分"></a>在 sklearn 进行划分</h2><p><code>sklearn.model_selection.train_test_split(arrays, options*)</code></p><ul><li>x 数据集的特征值</li><li>y 数据集的目标值</li><li>test_size 测试集的大小，一般为 float</li><li>random_state 随机数种子，不同的种子会造成不同的随机采样结果。相同的种子采样结果相同</li><li>return 返回值：训练集特征值，测试集特征值，训练集目标值，测试集目标值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size = <span class="number">0.2</span>, random_state = <span class="number">22</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> BiliBili 黑马自学机器学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> scikit-learn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（3）</title>
      <link href="/2023/4aa90b55.html"/>
      <url>/2023/4aa90b55.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>对于一个机器学习开发流程，可以归纳为以下几个步骤。</p><ol><li>获取数据集。</li><li>进行数据预处理（也成为数据清洗）。一般进行数据清洗需要通过通过7个步骤进行处理： 选择子集，列名重命名，删除重复值，缺失值处理，一致化处理，数据排序处理，异常值处理<sup><a href="#1">[1]</a></sup>。</li><li>特征工程。将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度<sup><a href="#2">[2]</a></sup>。</li><li>机器学习算法训练，得到模型。</li><li>模型评估。如果评估结果不满意，则重新回到步骤 2 再训练一次。</li><li>应用训练好的模型</li></ol><h2 id="对于机器学习的学习框架与资料"><a href="#对于机器学习的学习框架与资料" class="headerlink" title="对于机器学习的学习框架与资料"></a>对于机器学习的学习框架与资料</h2><p>我们需要明确的知道：算法是核心，数据与计算是基础。现在的机器学习这么火，是因为它的效率很高，归功于算法的进步，以及拥有数据给他进行训练。</p><p>确定自己在这样的过程中找到定位。大部分比较复杂的模型，算法都有算法工程师去开发。很多都是名校的研究学者发明出来的，一般上自学者很难去达到这样的能力。一般上工业界不需要这么牛的技能。通常只需要做一些数据清洗、模型训练的操作。我们只需要设计着一些工作内容：</p><ol><li>分析大量的数据</li><li>分析具体的业务</li><li>应用常见的算法</li><li>特征工程、调参数、优化</li></ol><p>一般上可以去读这么几本书，但参考书比较晦涩难懂，不建议直接去读，他确实会提升你的基础，但是会磨掉你的耐心：</p><ol><li>概率论与数理统计</li><li>线性代数</li><li>高等数学</li></ol><p>一般上我们需要怎么做？首先，需要<strong>入门</strong>，了解自己需要做什么，掌握算法的基本思想，学会对问题用相应的算法去解决，利用库或框架解决问题，然后去找找<strong>实战</strong>类书籍，了解框架底层原理，深入研究</p><h3 id="机器学习库和框架"><a href="#机器学习库和框架" class="headerlink" title="机器学习库和框架"></a>机器学习库和框架</h3><p>常见的机器学习框架有</p><ol><li>scikit learn</li><li>pytorch</li><li>caffe 2</li><li>theano</li><li>chainer</li></ol><h3 id="机器学习书籍资料"><a href="#机器学习书籍资料" class="headerlink" title="机器学习书籍资料"></a>机器学习书籍资料</h3><ol><li>Machine Learning 机器学习（西瓜书） - 周志华（讲的是机器学习的底层）</li><li>Python 数据分析与挖掘实战</li><li>机器学习系统设计</li><li>面向机器智能 TensorFlow 实践</li><li>TensorFlow 技术分析与实践</li></ol><h3 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h3><ol><li>统计学习方法 ISBN：9787302275954</li><li>深度学习（花书） ISBN：9787115461476</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a id="1">[1]</a> 数据分析(二)：数据清洗步骤 - Hugh Kim的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/109413107">https://zhuanlan.zhihu.com/p/109413107</a><br><a id="2">[2]</a> 深度了解特征工程 - 正阳的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/111296130">https://zhuanlan.zhihu.com/p/111296130</a></p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> BiliBili 黑马自学机器学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（2）</title>
      <link href="/2023/f2156c30.html"/>
      <url>/2023/f2156c30.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>机器学习的定义，简单来说就是 <strong>数据</strong> -&gt; <strong>模型（结论 / 规律）</strong> -&gt; <strong>预测</strong></p><p>完整来说是：从数据中获得模型，从模型中对未知数据进行预测。</p><p>人类从大量的日常经验中归纳规律，当面临新的问题的时候，就可以利用以王总结的规律去分析现实情况，采取最佳策略。</p><p>同理，机器从大量的数据中进行训练，得出模型。对未知数据进行预测。</p><hr><p>以猫狗识别示例，给计算机大量的猫和狗的照片（数据）。并且标记哪些是猫，哪些是狗。让计算机进行训练得出模型（辨别猫和狗的规律）。当遇到新的图片，就能让计算机自动分辨哪个是猫、哪个是狗。</p><p>从数据（房屋的各种讯息），自动分析获得模型（判断房屋价格的规律），从而使机器拥有预测房屋价格的能力。</p><h2 id="数据集的构成"><a href="#数据集的构成" class="headerlink" title="数据集的构成"></a>数据集的构成</h2><p>历史数据的格式应该是：特征值 + 目标值。例如以下房屋的各种讯息</p><div class="table-container"><table><thead><tr><th>房子面积</th><th>房子位置</th><th>房子楼层</th><th>房子朝向</th><th>目标值</th></tr></thead><tbody><tr><td>80</td><td>9</td><td>3</td><td>0</td><td>80</td></tr><tr><td>100</td><td>9</td><td>5</td><td>1</td><td>120</td></tr><tr><td>80</td><td>10</td><td>3</td><td>0</td><td>100</td></tr></tbody></table></div><blockquote><p>注：</p><ul><li>对于每一行数据我们可以称之为样本</li><li>有些数据集可以没有目标值，根据特征值分成一堆</li></ul></blockquote><h2 id="机器学习算法分类定义"><a href="#机器学习算法分类定义" class="headerlink" title="机器学习算法分类定义"></a>机器学习算法分类定义</h2><p>对于机器学习，我们需要特征值和目标值。</p><p>比如说识别猫和狗，特征值就是图片、目标值就是“猫”或“狗”。目标值就是<strong>类别</strong>。目标值是<strong>类别（离散型数据）</strong>的话，则这个问题属于<strong>分类问题</strong></p><p>而对房屋价格进行预测，特征值就是房屋信息、目标值就是房屋的价格。目标值就是<strong>具体的值</strong>。目标值是<strong>具体的值（连续型数据）</strong>的话，则这个问题属于<strong>回归问题</strong></p><p>目标值为<strong>无</strong>的话，则这个问题属于<strong>无监督学习</strong>，没有一个目标去监督。</p><p>所以从上，我们可以将机器学习算法分为两类</p><table><thead>  <tr>    <th>类型</th>    <th>问题类型</th>    <th>目标值特点</th>  </tr></thead><tbody>  <tr>    <td rowspan="2">监督学习</td>    <td>分类</td>    <td>离散型数据</td>  </tr>  <tr>    <td>回归</td>    <td>连续型数据</td>  </tr>  <tr>    <td>无监督学习</td>    <td>聚类</td>    <td>无</td>  </tr></tbody></table><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>预测明天的气温是多少度？回归</li><li>预测明天是阴天、晴天还是雨天？分类</li><li>人脸年龄预测？不确定，具体看怎么定义年龄（确切年龄还是年龄层），回归 / 分类</li><li>人脸识别？分类</li></ol><h2 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h2><ul><li>监督学习（Supervised Learning）预测<ul><li>定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值（称为回归）、或者输出是有限个离散值（称为分类）</li><li>分类 - k-邻近算法、贝叶斯分类、决策树与随机森林、逻辑回归<sup><a href="#注1">[注1]</a></sup></li><li>回归 - 线性回归、岭回归</li></ul></li><li>无监督学习（Unsupervised Learning）<ul><li>定义：输入数据是由输入特征值所组成</li><li>聚类 - k-means</li></ul></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><a id="注1">[注1]</a> 逻辑回归本质上是线性回归在 sigmoid 函数上的映射，通过设定某一个阈值，超过这个阈值被标为 1，小于这个阈值被标为 0，所以是分类问题</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> BiliBili 黑马自学机器学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（1）</title>
      <link href="/2023/e0a0c3de.html"/>
      <url>/2023/e0a0c3de.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="人工智能概述"><a href="#人工智能概述" class="headerlink" title="人工智能概述"></a>人工智能概述</h2><p>人工智能 包含 机器学习，机器学习 包含 深度学习</p><h3 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h3><p>人工智能 1950 年代出现，当时的人工智能体现在“使用电脑进行下棋活动（国际跳棋）”。我的理解是有点类似于游戏 AI，给定一个规则，让 AI 对该规则进行思考并给出反馈。</p><p>1956 年 8 月达特茅斯会议——人工智能的起点。当时汇聚一群大佬（约翰·麦卡锡、马文·闵斯基、克劳德·香农 等人）汇聚在一起，讨论一个完全不食人间烟火的主题：<strong>用机器来模仿人类学习以及其他方面的智能</strong>。当时还没有定义 <strong>人工智能</strong> 这个概念。</p><p>会议开了 2 个月的时间，没有达成普遍的共识，但是对会议讨论内容起了一个名字：<strong>人工智能</strong>。因此 1956 年也被称为人工智能元年。</p><h3 id="人工智能技术有两大流派"><a href="#人工智能技术有两大流派" class="headerlink" title="人工智能技术有两大流派"></a>人工智能技术有两大流派</h3><ul><li>连接主义（仿生主义）<ul><li>研究方向：仿生人的神经网络</li></ul></li><li>逻辑主义（符号主义）<ul><li>艾伦·纽厄尔、赫伯特·西蒙 是符号主义的奠基人</li><li>人的思考是有一定的逻辑推理存在的，如果将人的思维推理过程还原出来，是否能实现人工智能</li></ul></li></ul><p>1980 年代，搞统计的学者，出现了<strong>机器学习</strong>。用统计的方法来实现人工智能。体现在 “垃圾邮箱识别”。当然，还包括其他技术</p><p>人工神经网络是属于<strong>机器学习</strong>的范畴</p><p>2010 年代，从人工神经网络进行改进，变成深度神经网络，出现了<strong>深度学习</strong>，主要体现在 “图像识别”。是人工智能百花齐放的时代。</p><h3 id="人工智能技术小结"><a href="#人工智能技术小结" class="headerlink" title="人工智能技术小结"></a>人工智能技术小结</h3><p>机器学习是人工智能的一个实现途径；深度学习是机器学习的一个方法发展而来</p><h2 id="机器学习、深度学习能做什么？"><a href="#机器学习、深度学习能做什么？" class="headerlink" title="机器学习、深度学习能做什么？"></a>机器学习、深度学习能做什么？</h2><h3 id="机器学习的技术"><a href="#机器学习的技术" class="headerlink" title="机器学习的技术"></a>机器学习的技术</h3><ul><li>挖掘、数据预测<ul><li>店铺销量预测、量化投资、广告推荐、企业客户分类、SQL 语句安全检测分类……</li></ul></li><li>图像识别<ul><li>自动驾驶（街道交通标志识别）、人脸识别……</li></ul></li><li>自然语言处理<ul><li>机器翻译（不再是 10 年前那种笨蛋翻译了）、情感分析、文本分类、自动聊天、文本检测……</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> BiliBili 黑马自学机器学习 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【游戏构思】超随机沙盒游戏（武器篇1）</title>
      <link href="/2023/126cc4f2.html"/>
      <url>/2023/126cc4f2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我想要搭建一个【无限地图，开放世界，微剧情向，超高随机性，肉鸽类，沙盒类，生存类】的究极缝合怪游戏。本篇是我疯狂想法中的其中一环——武器篇。（武器：纳尼？！我也是你 Play 的一环？）</p><h2 id="旧有系统简介"><a href="#旧有系统简介" class="headerlink" title="旧有系统简介"></a>旧有系统简介</h2><p>传统的 RPG 游戏，武器都是由游戏开发者设计好一个个固定名称的武器，这些武器往往连贴图一起设计好，可塑性及随机性低。通常只能通过随机前后缀，来区别每个武器的强度。</p><p><img src="/uploads/早期游戏武器设计.png" alt="早期游戏武器设计" width=50%/></p><h2 id="崭新武器装配框架"><a href="#崭新武器装配框架" class="headerlink" title="崭新武器装配框架"></a>崭新武器装配框架</h2><p>这里介绍我们所构思的武器装配框架！我们的武器框架参考自《无主之地 3》（Borderlands 3）的武器装配系统，如果技术行得通，我们还想加入《魔法工艺》（Magicraft）以及《Noita》的可编程武器系统。增加更多的可玩性，而不仅仅是数值上的差异。根据《无主之地 3》的开发者透露，无主之地通过不同的排列组合，游戏中拥有 10 亿（甚至有传言说超过 10 亿）把不同的枪械，每一把枪械都有自己的特性<sup><a href="#1">[1]</a></sup>。按照这个计算，假设游戏中只有一种武器——剑，而剑的主要结构有：剑刃、护手、剑柄、配重。</p><p><img src="/uploads/剑的结构.jpg" alt="剑的结构"/></p><p>假设我们的游戏中有 5 种原材料可以合成成剑的各种结构，通过排列组合则能够拥有 $5 ^ 4 = 625$ 把不同的搭配。再加上常见游戏武器种类 15 种<sup><a href="#注1">[注1]</a></sup>、若干个前后缀、以及武器镶嵌功能。玩家 / 系统能够创建的不同的武器能轻松达到数十亿之多。</p><h2 id="对应武器系统的设计雏形"><a href="#对应武器系统的设计雏形" class="headerlink" title="对应武器系统的设计雏形"></a>对应武器系统的设计雏形</h2><p>在游戏开发前期，对于每件武器，能够规划出他的构建流程如下：</p><ol><li>获取部件的原材料：史莱姆粘液、木板、铁锭……</li><li>将原材料合称为部件：剑刃、护手、剑柄、配重</li><li>将部件放入合成台中（对于代码逻辑，可以通过 Factory 设计模式来随机出一把武器，流程从手动变自动）</li><li>合成过程中，根据给定概率，随机出前后缀，并对武器数值进行微调</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>当然，除了武器，游戏中的其他东西都可以基于这套框架进行开发。</p><p>顺带记录一下武器的风格，后续可能会用到：</p><ul><li>科幻风格：这种风格的封面使用了未来科技的元素，如激光、机器人、电路等，给人一种超现实的感觉。封面的颜色以蓝色和白色为主，突出了冷静和智能的氛围。</li><li>像素风格：这种风格的封面回归了计算机的本质，用简单的像素点构成了各种武器的样式，如剑、弓、斧等。封面的颜色以红色和黑色为主，营造了一种复古和热血的氛围。</li><li>蒸汽朋克风格：这种风格的封面结合了工业时代和魔法时代的元素，如蒸汽机、齿轮、魔法符文等，给人一种奇幻和冒险的感觉。封面的颜色以棕色和金色为主，展现了一种古典和华丽的氛围。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><a id="注1">[注1]</a> 常见游戏武器种类<sup><a href="#2">[2]</a></sup></p><ol><li>近战类：<ol><li>刀</li><li>剑</li><li>枪</li><li>匕首 / 短刀</li><li>斧</li><li>铲</li><li>十字镐</li><li>锤 / 棍棒 / 钝器</li><li>旋棍</li><li>拳套 / 指虎</li><li>鞭子</li></ol></li><li>远程类：<ol><li>弓</li><li>弩</li><li>暗器</li><li>回旋镖</li><li>飞斧</li></ol></li><li>防御类：<ol><li>盾</li></ol></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a id="1">[1]</a> Borderlands 3 weapons: everything we know about guns and brands - <a href="https://www.pcgamesn.com/borderlands-3/weapons-guns-manufacturers">https://www.pcgamesn.com/borderlands-3/weapons-guns-manufacturers</a></p><p><a id="2">[2]</a> 游戏装备-萌娘百科 - <a href="https://zh.moegirl.org.cn/游戏装备">https://zh.moegirl.org.cn/游戏装备</a></p><h2 id="素材来源"><a href="#素材来源" class="headerlink" title="素材来源"></a>素材来源</h2><ol><li>游戏武器设计 - <a href="https://www.zcool.com.cn/work/ZMzg4MTQ2NjQ=.html">https://www.zcool.com.cn/work/ZMzg4MTQ2NjQ=.html</a></li><li>剑的结构-百度知道 - <a href="https://zhidao.baidu.com/question/2140383027198640548.html">https://zhidao.baidu.com/question/2140383027198640548.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 策划 </category>
          
          <category> 灵感笔记 </category>
          
          <category> 游戏构思 </category>
          
          <category> 游戏开发 </category>
          
          <category> 超随机沙盒游戏 </category>
          
          <category> 游戏类型 </category>
          
          <category> 肉鸽类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 肉鸽类游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换 Hexo 主题的步骤</title>
      <link href="/2023/73b9f9e4.html"/>
      <url>/2023/73b9f9e4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这个网站中，我采用了 <a href="https://github.com/Litreily/hexo-theme-snark">Snark</a> 主题。</p><p>首先，将主题（可以在 <a href="https://hexo.io/themes/">Hexo 官网</a>找到自己喜欢的主题）克隆下来，比如我用的 Snark 主题。通常会重定向至一个 GitHub 仓库界面，将其克隆下来。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:Litreily/hexo-theme-snark.git themes/snark</span><br></pre></td></tr></table></figure><blockquote><p>注：我配置了 SSH，所以可以通过 SSH 的方式直接 clone，没有配置的，请用 HTTPS 模式进行克隆。</p></blockquote><p>上面这段代码，意思是将这个主题克隆到 themes 文件夹下的 snark 目录中。</p><h2 id="安装主题所需依赖"><a href="#安装主题所需依赖" class="headerlink" title="安装主题所需依赖"></a>安装主题所需依赖</h2><p>一般情况下，该主题的 GitHub 仓库都有 README.md 文档，根据他的步骤做就行。比如我的这个 snark，需要安装两个依赖项：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><p>我这里安装了之后，同样的出现了 npm <span style="color: red;">ERR!</span> 报错。所以我用了 cnpm 包管理器瞎子啊，解决问题。</p><p>然后根据他的提示，在根目录下的 <code>_config.yml</code> 中禁用代码高亮。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中更改主题，这个在最后几行</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">snark</span></span><br></pre></td></tr></table></figure><h2 id="添加通用页面"><a href="#添加通用页面" class="headerlink" title="添加通用页面"></a>添加通用页面</h2><p>我们需要创建 归档、分类、标签、关于，这几个页面。输入以下代码进行创建</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page archives</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><p>我们也可以通过安装一些 hexo 插件，来增强网站功能</p><ul><li><code>npm install hexo-generator-feed --save</code> 添加 RSS 订阅功能</li><li><code>npm install hexo-generator-search --save</code> 添加本地搜索功能</li><li><code>npm install hexo-generator-sitemap --save</code> 添加 SiteMap</li></ul><p>Lorem ipsum is placeholder text commonly used in the graphic, print, and publishing industries for previewing layouts and visual mockups.<sup><a href="#1">[1]</a></sup></p><h2 id="解决运行错误"><a href="#解决运行错误" class="headerlink" title="解决运行错误"></a>解决运行错误</h2><p>我在启动时，打开页面报错内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unhandled rejection TypeError: C:\Source\NodeJs\xiaomai-blog\themes\snark\layout\_partial\after-footer.pug:9</span><br><span class="line">    7| if theme.local_search == true</span><br><span class="line">    8|     script.</span><br><span class="line">  &gt; 9|         var search_path = &#x27;#&#123;config.search.path&#125;&#x27;;</span><br><span class="line">    10|         if (search_path.length == 0) &#123;</span><br><span class="line">    11|             search_path = &#x27;search.xml&#x27;;</span><br><span class="line">    12|         &#125;</span><br><span class="line"></span><br><span class="line">Cannot read properties of undefined (reading &#x27;path&#x27;)</span><br></pre></td></tr></table></figure><p>尝试在 <code>config.yml</code> 中增加以下代码，解决问题</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">    <span class="attr">field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo 博客搭建 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 Hexo 博客的一些微调</title>
      <link href="/2023/652cb807.html"/>
      <url>/2023/652cb807.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当网站上线后，我发现最上方始终显示着 Hexo。所以还需要修改站点名称。</p><h2 id="修改网站信息"><a href="#修改网站信息" class="headerlink" title="修改网站信息"></a>修改网站信息</h2><p>打开 <code>_config.yml</code>，在最上方找到 <code>Site</code> 部分，修改成你需要的信息就行。具体的内容可以参考我的<sup><a href="#1">[1]</a></sup>：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">小麦的窝</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;一个喜欢肉鸽类游戏的程序员 | 奕用科技 CEO&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;用我所会的知识，为这个世界做出贡献&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">程序员</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">来华留学生</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">宅男</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">小麦</span> <span class="string">Andrew</span> <span class="string">Xiaomai</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a id="1">[1]</a> Hexo 官方文档 - <a href="https://hexo.io/docs/configuration#Site">https://hexo.io/docs/configuration#Site</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo 博客搭建 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo 搭建博客的总结</title>
      <link href="/2023/49a20550.html"/>
      <url>/2023/49a20550.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>今天用了几分钟搭建了这个基于 Hexo 的个人博客。具体是参考了知乎的建站文章进行一步步操作<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="一小时搭建完自己的个人网站 - 青羽的文章 - 知乎 https://zhuanlan.zhihu.com/p/78467553">[1]</span></a></sup>。可能作者的撰写的时间有点遥远（2019年），有些细节上的差别。现通过这篇博客来说明我的搭建心得。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>由于我电脑中本来就已经配置好 node.js 和 git 所以，本文中不再赘述。具体需要的前期食材（以下准备环境都是基于我计算机上的配置，随着时间推移，会有更多新的稳定版本上线，基本上会兼容）：</p><ol><li><a href="https://nodejs.org/">Node.js</a>（v18.17.1）</li><li><a href="https://git-scm.com/">Git for Windows</a>（git version 2.42.0.windows.1）</li><li>Hexo 框架</li><li><a href="https://github.com">Github</a> 账号</li><li>在 GitHub 在上面新建一个 Repository，Repository name 为 <code>GitHub用户名.github.io</code></li></ol><h2 id="配置-Git-账号"><a href="#配置-Git-账号" class="headerlink" title="配置 Git 账号"></a>配置 Git 账号</h2><p>打开控制台：右键点击 Windows Logo（下方任务栏的微软图标），找到 Terminal（中译：终端 / 控制台），然后输入配置用户名和邮箱信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;你的 GitHub 注册邮箱&quot;</span><br><span class="line">git config --global user.user &quot;你的 GitHub 用户名&quot;</span><br></pre></td></tr></table></figure><p>这俩信息忘记的话，直接点开 GitHub 去检查，在主页都会显示。主页怎么进去？打开 <a href="https://github.com">GitHub</a> 点开右上角头像，点击 <code>Your profile</code> 菜单，就能打开了。个人信息都在那边。</p><p>生成 SSH 密钥（这一步我好早之前就做过了，之前解决国内 git clone 不稳定问题的时候），所以我也不确定。按照原文要求，使用如下指令</p><p><code>ssh-keygen -t rsa -C &quot;你的 GitHub 注册邮箱&quot;</code></p><p>默认不设置密码，直接回车就行（反正我是设了的，估计就是怕别人用我电脑来瞎搞）</p><p>用文本编辑器打开生成的 id_rsa.pub 文件，Ctrl + A，Ctrl + C 复制全部内容。</p><p>打开 GitHub 的 SSH <a href="https://github.com/settings/keys">设置界面</a>，点击 <code>New SSH Key</code>，Title 任意，Key 黏贴刚刚赋值的密钥，点击 <code>Add SSH Key</code>。</p><h2 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h2><p>有请今天的主角：Hexo</p><p>选定一个文件夹作为存放博客的目录（比如我的：<code>C:/documents/sources/</code>），在资源管理器（就是显示文件夹目录的那个窗口）上方的路径中输入 <code>cmd</code> 可以直接打开控制台中，并定位到该目录。</p><p>输入命令，安装 hexo：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><blockquote><p><code>-g</code> 代表该包（hexo-cli）是安装在全局范围下的，之后可以任意调用 hexo 的指令<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="What does "npm install -g" do? https://stackoverflow.com/questions/24606341/what-does-npm-install-g-do">[2]</span></a></sup>。</p></blockquote><p>等待安装完成后，让 Hexo 初始化你的博客框架</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog-name</span><br></pre></td></tr></table></figure><p>blog-name 输入你的博客名，随意取就行。然后进入该目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog-name</span><br></pre></td></tr></table></figure><p>现在框架算是搭建好了，测试指令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>s 是 server 的缩写，启动本地服务器。默认情况下，访问网址为：<a href="http://localhost:4000/">http://localhost:4000/</a></p></blockquote><h2 id="配置网站信息"><a href="#配置网站信息" class="headerlink" title="配置网站信息"></a>配置网站信息</h2><p>在 hexo 帮你初始化好的目录（blog-name）中，会看到一个 <code>_config.yml</code> 的文件。这边建议直接用 vscode 打开整个目录。方便操作</p><p>打开 <code>_config.yml</code> 文件，配置 url</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://你的</span> <span class="string">GitHub</span> <span class="string">用户名.github.io/</span></span><br></pre></td></tr></table></figure><p>再到最下方，找到 deploy 字段，默认情况下是空的，添加以下字段：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Kingsmai/你的</span> <span class="string">GitHub</span> <span class="string">用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>保存文件，然后安装 Git 部署插件。在站点目录下打开控制台，并输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><blockquote><p><code>--save</code> 选项会将模块信息写入 <code>package.json</code> 文件中的 <code>depencies</code> 字段中，以便在生产环境中使用<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="npm install安装的四种用法（-save和-save-dev） - Jessica的文章 - 知乎 https://zhuanlan.zhihu.com/p/583833718">[3]</span></a></sup>。</p></blockquote><h3 id="npm-ERR-报错"><a href="#npm-ERR-报错" class="headerlink" title="npm ERR! 报错"></a>npm <span style="color: red;">ERR!</span> 报错</h3><p>在这个步骤中，我出现了如下报错信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! Cannot read properties of null (reading &#x27;matches&#x27;)</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in: C:\Path\To\Log\debug-0.log</span><br></pre></td></tr></table></figure><p>后来搜了一下，使用 cnpm 就能解决问题。没去深究，具体操作如下<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="hexo在GitHub上创建blog需要安装hexo-deployer-git插件包遇到的报错 - CSDN http://t.csdnimg.cn/lz60k">[4]</span></a></sup></p><ol><li>安装 cnpm <code>npm install -g cnpm</code></li><li>使用 cnpm 包管理器重新执行指令：<code>cnpm install hexo-deployer-git --save</code></li></ol><h2 id="部署！"><a href="#部署！" class="headerlink" title="部署！"></a>部署！</h2><p>执行以下两个指令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>清除 hexo 数据库，然后 g 是 generate 的缩写，表示生成静态文件；d 是 deploy 的缩写，表示部署到网站上。</p><p>这时候打开你的网站地址：<code>https://你的 GitHub 用户名.github.io/</code>，就能看到文章已经上线咯~</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>在命令行（同样，是在网站的目录中）输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n &quot;你想要的文章主题&quot;</span><br></pre></td></tr></table></figure><blockquote><p>n 是 new 的缩写，表示新建一篇文章。</p></blockquote><p>然后在目录中找到 <code>source/_posts</code> 目录，可以发现目录中出现了一个你刚刚创建的 md 文件。文章用 Markdown 语法撰写。具体可参考 <a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程 | 菜鸟教程</a></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>还是感谢青羽在知乎上给出这个教学，本人只是基于他的教学进行实践后，对于一些坑进行补充。欢迎各位朋友一起搭建属于自己的博客，记录生活哟！！</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这篇文章写完了，然后就是执行 hexo clean 和 hexo g -d 发布啦！</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">一小时搭建完自己的个人网站 - 青羽的文章 - 知乎 https://zhuanlan.zhihu.com/p/78467553<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">What does &quot;npm install -g&quot; do? https://stackoverflow.com/questions/24606341/what-does-npm-install-g-do<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">npm install安装的四种用法（-save和-save-dev） - Jessica的文章 - 知乎 https://zhuanlan.zhihu.com/p/583833718<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">hexo在GitHub上创建blog需要安装hexo-deployer-git插件包遇到的报错 - CSDN http://t.csdnimg.cn/lz60k<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo 博客搭建 </category>
          
          <category> NodeJS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Page </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>凯撒加密 Caesar Cipher</title>
      <link href="/2023/adae5e2c.html"/>
      <url>/2023/adae5e2c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>哈喽大家好，我是一个新人年更 UP 主小麦，今天教大家怎么使用 Python 实现一个凯撒加密的小工具。</p><h2 id="凯撒加密的原理"><a href="#凯撒加密的原理" class="headerlink" title="凯撒加密的原理"></a>凯撒加密的原理</h2><p>凯撒加密是由两个轮盘所组成的简易加密机制。其原理是将字母 A-Z 首尾相连，然后定义一个 0 - 25 的密钥值，并将明文的字母逐字向后推移到该值所对应的字母即可完成加密。</p><p>比如 key 值为 15，那么 A 在加密后对应字母的第 15 个字符，也就是 P。</p><p>我们只需要将加密后的信息和 key 值传递给对方，对方通过反向计算（也就是将偏移后的结果反向解码）即可破译该信息。</p><h2 id="凯撒加密的例子"><a href="#凯撒加密的例子" class="headerlink" title="凯撒加密的例子"></a>凯撒加密的例子</h2><p>比如说我们需要加密 CAT 这三个英文字母，密钥为 15，那加密过程为：</p><ol><li>C 的字符下标为 2；A 的字符下标为 0；T 的字符下标为 19。</li><li>将 2，0，19 分别 + 15，得到 17，15，34；</li><li>通过字符表，我们可以得到密文为 R P 和编码为 34 的密文，这里我们发现 34 超过了字母对照表 25 的长度，所以我们需要将其减去 26，已得到对应的数值 8。</li><li>最后我们得出加密后的文本为：RPI。</li></ol><h2 id="凯撒解密的例子"><a href="#凯撒解密的例子" class="headerlink" title="凯撒解密的例子"></a>凯撒解密的例子</h2><p>刚才我们加密后的结果为 RPI，密钥为 15，那解密过程为：</p><ol><li>R 的下标为 17；P 的下标为 15；I 的下标为 8；</li><li>将这三个数值分别 - 15，得到 2，0，-7；</li><li>同理，我们的字符表范围在 0 - 25，所以少于 0，的数值我们需要对其 + 26；</li><li>最后得到数值为 2，0，19；解密后为 CAT。<h2 id="凯撒加密的实现"><a href="#凯撒加密的实现" class="headerlink" title="凯撒加密的实现"></a>凯撒加密的实现</h2></li></ol><p>在实现之前，我们将整个业务逻辑梳理一遍</p><ol><li>得到用户输入的字符串和 key 值；</li><li>如果用户输入的 key 值超过 25，提示错误，重新输入</li><li>逐字遍历该字符串中的字符；</li><li>如果是空格，则跳过；</li><li>将该字符的编码加上 key 的值</li><li>如果 key 值超过 25，则减去 26；</li><li>将加密后的字符添加到新的字符串上；</li><li>输出加密后的字符</li></ol><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>将 key 从数值变成一个字符串</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是密码学 Cryptography</title>
      <link href="/2023/2634ccb0.html"/>
      <url>/2023/2634ccb0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>人们需要传递信息，且这份信息不能让其他人知道的时候，就需要加密所传递的信息。密码学就是一门研究加密的科学。</p><h2 id="系列内容"><a href="#系列内容" class="headerlink" title="系列内容"></a>系列内容</h2><p>友友们，我想出一系列关于用 python 实现密码学的视频，请问有感兴趣的嘛？</p><ol><li>凯撒密码 — [[凯撒加密 Caesar Cipher]]</li><li>换位法加密</li><li>仿射密码</li><li>替换式密码</li><li>维吉尼亚密码</li><li>一次性密码本</li><li>公开密钥加密</li></ol><p>大概率是周更或者每周两更。期间也会出番外来讲解一些加密原理</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 11 双层 JDBC</title>
      <link href="/2023/70d5123e.html"/>
      <url>/2023/70d5123e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="JDBC-三层"><a href="#JDBC-三层" class="headerlink" title="JDBC 三层"></a>JDBC 三层</h2><p>包括：</p><ul><li>Service 业务逻辑层</li><li>DAO 数据获取层</li><li>Helper 数据连接层</li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>引入 Dao 概念，DAO 就是和数据库打交道的对象。它的类名命名方式为 <code>表名Dao</code>。</p><p>具体就是把我们之前写在 servlet 的代码搬过来这里。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>创建一个 dao 包，然后创建一个类，类命名方式如上</p><p>以航空管理 GetCityNames 接口为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CityDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;HashMap&lt;String, Object&gt;&gt; <span class="title function_">getCityNames</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM city&quot;</span>;</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; list = MySqlHelper.executeQuery(sql, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 Servlet 的 Get 或 Post 方法就调用它</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; list = CityDao.getCityNames();</span><br><span class="line"><span class="type">string</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(list);</span><br><span class="line">response.getWriter().append(json);</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>如果 servlet 中还需要声明 List，就显得 DAO 没意义。最后我们的 json 数据要包括</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;数据段&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success / fail&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>为了实现 data 和 flag 这两个键，我们需要加上一个包 pojo。这个包是放置实体类的。</p><p>在 pojo 包里创建一个 Result 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String flag;</span><br><span class="line"><span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个属性是 Object 的原因是有可能是 List 对象，也有可能是 字符串。</p><p>然后生成 Getter 和 Setter</p><p>然后再创建无参构造方法和有参构造方法</p><p>这时候 servlet 的代码可以改为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="string">&quot;success&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">result.setData = CityDao.getCityNames();</span><br><span class="line"><span class="type">string</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(list);</span><br><span class="line">response.getWriter().append(json);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以我们的 servlet 是访问 CityDao 的函数，获得数据库信息。然后将返回值 List 添加到自定义的实体类 Result 的 data 成员变量里，再转换成字符串返回。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏套路设计</title>
      <link href="/2022/e37089f4.html"/>
      <url>/2022/e37089f4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="新手任务"><a href="#新手任务" class="headerlink" title="新手任务"></a>新手任务</h2><p>通过新手任务，让玩家可以迅速升到 10 级。升级过程中，通过打怪，可以攒齐一套初始装备。</p><p>让玩家建立初始收集装备的快感，可以见证自己的装备栏，从无到有的过程。</p><p>这是初期 RPG 游戏的基本套路。我们直接沿用，可以让玩家找到归属感，减少玩家玩游戏过程中的学习成本</p><h3 id="任务面板"><a href="#任务面板" class="headerlink" title="任务面板"></a>任务面板</h3><p>任务列表、任务内容。</p><h4 id="任务内容"><a href="#任务内容" class="headerlink" title="任务内容"></a>任务内容</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和 #c00ff00 英雄 #c 对话</span><br><span class="line">#W 这里一大堆废话</span><br><span class="line">描述事情的来龙去脉</span><br><span class="line">然后引出具体的任务</span><br><span class="line">这个任务的目标就是要击杀 #R30#W 只 独角兽。</span><br></pre></td></tr></table></figure><h3 id="设计总结"><a href="#设计总结" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>让玩家找到归属感</li><li>减少游戏带来的学习成本</li><li>减少游戏前期的流失率</li></ol><h2 id="商城系统"><a href="#商城系统" class="headerlink" title="商城系统"></a>商城系统</h2><p>提供商城系统，充值、或者做任务获得一级货币，暂且叫他元宝。实际名字根据游戏世界观而定。</p><p>可以在商城购买游戏道具。但是只能买少量的游戏道具，且只有当玩家升到 10 级之后才会开放。因为大部分玩家不会一上来就付费。提前开放会导致玩家认定这是一个氪金游戏。</p><h3 id="商城面板"><a href="#商城面板" class="headerlink" title="商城面板"></a>商城面板</h3><p>热卖、钻石商城、奇货可居、坐骑商城、时装商城、至尊商城</p><h3 id="设计总结-1"><a href="#设计总结-1" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>吊一下玩家胃口</li><li>升级过程中爱上游戏</li><li>心甘情愿的付费</li></ol><h2 id="职业系统"><a href="#职业系统" class="headerlink" title="职业系统"></a>职业系统</h2><p>10 级以后可以选择一种职业，拥有职业技能。打怪方式多了几种选择，可以选择：</p><ul><li>肉盾（少林）</li><li>近战（明教）</li><li>远攻（武当）</li><li>辅助（逍遥）</li><li>奶妈（峨眉）</li></ul><h3 id="设计总结-2"><a href="#设计总结-2" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>打怪体验有了质的提升</li><li>白嫖玩家的首个阶跃点</li><li>用户体验极佳</li></ol><h2 id="坐骑系统"><a href="#坐骑系统" class="headerlink" title="坐骑系统"></a>坐骑系统</h2><p>11 级之后赠送 30 天限时坐骑</p><blockquote><p>也有人说坐骑可以白嫖，但是骑术必须商城里买，千万不要这么干，这样只会恶心玩家。前期千万不要恶心玩家，等玩家真正入坑了，有的是机会恶心他们</p></blockquote><h3 id="设计总结-3"><a href="#设计总结-3" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>移动速度加倍</li><li>第二个白嫖的阶跃点</li><li>用户体验极佳</li></ol><h2 id="装备系统"><a href="#装备系统" class="headerlink" title="装备系统"></a>装备系统</h2><p>去野外打怪，让玩家能够打到比他等级高的装备，给他一个预判，也是一个暗示</p><blockquote><p>玩家心理活动：我要抓紧升级，这样才能戴更加牛逼的装备</p></blockquote><p>一位有追求的玩家是不会弃坑的。</p><p>升级以后，戴上高等级的装备，打怪确实变得轻松了。这时候让玩家进一步验证自己的观点</p><blockquote><p>玩家心理活动：我不断打怪练级，是值得的！</p></blockquote><p>让玩家形成自我肯定，</p><blockquote><p>玩家心理活动：我已经会玩这个游戏了！</p></blockquote><h3 id="设计总结-4"><a href="#设计总结-4" class="headerlink" title="设计总结"></a>设计总结</h3><ul><li>装备后打怪变轻松</li><li>让玩家形成自我肯定</li><li>从而更加坚定要玩下去的决心</li></ul><h2 id="背包系统"><a href="#背包系统" class="headerlink" title="背包系统"></a>背包系统</h2><p>除了掉落装备，还会掉落各种材料。每个等极段的材料都不同，直接就把背包撑满了，但是又不舍得扔掉。这时候突然掉落一种能够增加背包格子的道具，让玩家能够携带更多的道具。</p><blockquote><p>玩家心理活动：策划真是太贴心了。成功解决了我的痛点</p></blockquote><p>殊不知这个痛点也是我们埋下的。这时候，作为开发者，我们应该意识到，做游戏就是……</p><h3 id="设计总结-5"><a href="#设计总结-5" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>开发者埋坑</li><li>玩家来填坑</li><li>大家都开心</li></ol><h2 id="主线任务"><a href="#主线任务" class="headerlink" title="主线任务"></a>主线任务</h2><p>我们做任何事情，都需要有目标，有目标才会有方向，有目标才会有动力，有目标才会有人生的意义。玩游戏也是如此，给玩家制定主线任务，每到一定等级，就能触发对应的主线任务。完成主线任务，可以得到当前等级段，相对更好的装备、相对更多的经验。这样玩家才会去做主线任务</p><p>当然，每一个主线任务会有一定的门槛：</p><ul><li>BOSS 比较难打</li></ul><h3 id="设计总结-6"><a href="#设计总结-6" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>给玩家指定有阶段性的目标</li><li>提供更好的奖励激励机制</li><li>BOSS 设计时，增加一定门槛</li></ol><h2 id="场景任务"><a href="#场景任务" class="headerlink" title="场景任务"></a>场景任务</h2><p>主线任务用来投放阶段性的奖励，那么等级没有达到下一段，需要有些支线任务做填充。可以这么来设计：</p><ul><li>每 10 级切换一个场景</li><li>每个场景有对应的场景任务<ul><li>打怪类</li><li>送信类</li><li>护送类</li><li>搜集类</li></ul></li></ul><h3 id="设计总结-7"><a href="#设计总结-7" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>通过升级解锁场景</li><li>通过场景任务获得系统货币</li><li>场景任务尽量多样化</li></ol><p>完成任务可以获得金币，也是前期积累第一桶金的最好方法。金币是游戏中由系统产出的货币。就看我们要做的这个游戏发生在什么朝代了：</p><ul><li>三国：百钱</li><li>西晋：货货</li><li>唐朝：通宝</li><li>宋朝：交子</li><li>架空：？？？</li></ul><h2 id="第一个副本"><a href="#第一个副本" class="headerlink" title="第一个副本"></a>第一个副本</h2><p>升到 20 级以后，为了引入社交，提供一个经验比纯刷怪多好多的副本。副本是需要组队的，一天只能刷一次，为了避免玩家组不到队伍，做成限定时间，时间一到一定有许多玩家蜂拥而上，到时候还怕组不到队吗？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">雪域神兵</span><br><span class="line">你在雪地里面遇到了很多神奇的士兵，他们无恶不作，导致生灵涂炭，哀鸿遍野，民不聊生，为了挽救民众于水火，你决定把他们都打败。</span><br><span class="line">大战一触即发！</span><br><span class="line"></span><br><span class="line">BOSS 奖励：1 级钻石、装备制作材料、高额经验</span><br><span class="line">小怪奖励：师门材料、高额经验</span><br><span class="line"></span><br><span class="line">击杀数量：199 小怪 + 1 BOSS</span><br></pre></td></tr></table></figure><p>什么时间点最合适呢？</p><ul><li>中午 12 点：你可以捧着饭碗，一边吃一边玩，真是太适合打工族了。这个副本的特点，就是集中打几百个怪。这样在打的过程中，玩家无聊就会开始聊天，聊出感情来，后面就可以结婚了。</li></ul><p>结婚是我们后面需要设计的另一个大系统</p><h3 id="设计总结-8"><a href="#设计总结-8" class="headerlink" title="设计总结"></a>设计总结</h3><ol><li>副本时间固定</li><li>副本怪经验较高</li><li>引入社交属性</li></ol><h2 id="双倍经验"><a href="#双倍经验" class="headerlink" title="双倍经验"></a>双倍经验</h2><p>升到 30 级以后，玩家就会突然意识到升级慢起来了。没错，这也是我们提前设计好的，只要 30 级到 31 级需要的经验比 29 级到 30 级多很多倍就可以了。</p><p>让玩家能够很直观的感受出来升级变吃力了。</p><p>让后商城解锁卖双倍经验的道具，解锁条件可以设定为：等级达到 30 级。</p><p>当然，为的不显的那么赤裸裸，我们给白嫖玩家每周免费双倍经验丹，找固定的 NPC 领取就可以了。这时候，玩家想的不是升级怎么这么慢，而是：</p><blockquote><p>玩家心理活动：策划真是太贴心了，居然免费给双倍，那我就一直白嫖一直爽</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哎呀呀，你又来白嫖啦</span><br><span class="line">你这个礼拜可以领取</span><br><span class="line">5 / 10 个双倍经验丹</span><br><span class="line">省着点用啊喂</span><br></pre></td></tr></table></figure><p>【他曾经也是个做游戏的，现在……】 【精准空降到 04:25】 <a href="https://www.bilibili.com/video/BV1TG4y157f4/?share_source=copy_web&amp;vd_source=6f5d387f846ae387b7bceb8f2dbedf3b&amp;t=265">https://www.bilibili.com/video/BV1TG4y157f4/?share_source=copy_web&amp;vd_source=6f5d387f846ae387b7bceb8f2dbedf3b&amp;t=265</a></p>]]></content>
      
      
      <categories>
          
          <category> 灵感笔记 </category>
          
          <category> 游戏相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后室游戏灵感</title>
      <link href="/2022/25ca7982.html"/>
      <url>/2022/25ca7982.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>有一天你在后室，这个时候停电了，你打算去修理电箱，但这时却传来了敲门声…<br>当前任务：找到修理工具和电箱。<br>默认武器：一把三个弹匣的AK和核能手电筒，再加一把消防斧。<br>任务目标：修理完电箱后清理完丧尸。<br>注意：<br>1.后室子弹较少，请谨慎使用。<br>2.体力不足的情况下无法使用消防斧。<br>3.如果你听到有人叫你名字别回头。</p>]]></content>
      
      
      <categories>
          
          <category> 灵感笔记 </category>
          
          <category> 游戏相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考笔记 </tag>
            
            <tag> 后室 Backroom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 面向对象思想</title>
      <link href="/2022/ab666f52.html"/>
      <url>/2022/ab666f52.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>面向对象包含了两个很重要的东西——属性、方法</p><ul><li>属性：这个对象有什么特征。如：颜色、重量、位置……</li><li>方法：这个对象能干嘛。如：上色、掉落……</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote><p>这个对象有什么特征。比如人有姓名、年龄、性别等。</p></blockquote><p>格式为（方括号代表可以写、可以不写）：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[修饰符] [<span class="keyword">static</span>] 数据类型 变量名 [= 初始值];</span><br></pre></td></tr></table></figure><ul><li>修饰符分为五个<ul><li><code>public</code>——公共的，所有类都能调用它的值。</li><li><code>private</code>——私有的，相当于他的小秘密，只有他自己可以访问这个值</li><li><code>protected</code>——受保护的，只有它和它的孩子（继承它的）类可以访问这个值</li><li><code>internal</code>——同一个项目中的对象可以访问</li><li><code>protected internal</code>——可可以在其他项目中，被派生类使用</li><li>不写——相当于 private，只有他自己能访问</li></ul></li><li><code>static</code> 关键字将此变量设置为静态变量。它的特性是：<ul><li>一旦这个类（不是实例化之后的对象）被初始化之后，它的值就一直存在</li></ul></li><li>数据类型可以是任何种类，包括复合类</li><li>变量名——一般情况下，C#变量名的命名方式约定俗成为：<ul><li>private 修饰符，它的变量名之前应该有个下划线，然后采用小驼峰。如：<code>_chineseName</code></li><li>public 修饰符，采用大驼峰。如：<code>ChineseName</code></li><li>变量名不能和类名重名。</li></ul></li><li>初值。我们可以给属性设置初始值</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>在创建对象的时候，告诉它一些初始值。比如说我告诉 Person 类，你的名字是啥、年龄是啥。<br>一旦声明了构造函数，无参构造函数将不复存在</p></blockquote><p>无参构造函数——如果没有声明构造函数，那么系统默认会给一个隐形的无参构造函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>固定写法</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名 (数据类型 参数<span class="number">1</span>, 数据类型 参数<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">属性<span class="number">1</span> = 参数<span class="number">1</span>; <span class="comment">// 和 C语言 一样，右边的值赋值给左边的变量</span></span><br><span class="line">属性<span class="number">2</span> = 参数<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的用法是</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">类名 变量名 = <span class="keyword">new</span> 类名(值<span class="number">1</span>, 值<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="Getter-和-Setter"><a href="#Getter-和-Setter" class="headerlink" title="Getter 和 Setter"></a>Getter 和 Setter</h3><blockquote><p>有些属性，我们要给他规定合法值，或者一些其他的操作。那么就可以用到 Getter 和 Setter。他俩分别在赋值和获取值的时候执行。</p></blockquote><p>一个完整的、最基础的属性应该长这样：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> 数据类型 _变量名; <span class="comment">// 注意这里是 private 修饰符，所以带 _，命名方式为小驼峰</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 数据类型 变量名 <span class="comment">// 数据类型要和上面的一样。public 变量的命名方式为大驼峰。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> _变量名; &#125; <span class="comment">// 这里返回的是 private 的那个变量</span></span><br><span class="line"><span class="keyword">set</span> &#123; _变量名 = <span class="keyword">value</span>; &#125; <span class="comment">// 讲我们给予的值赋值给 _变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>get</code> 是取值</li><li><code>set</code> 是赋值<ul><li><code>value</code> 是我们赋值的那个“值”。他是个隐含变量。假设 <code>p1.Name = &quot;李四&quot;</code>，那么set 里面的 value 就等于 <code>&quot;李四&quot;</code>。</li></ul></li></ul><p>举个栗子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 有时候 _name 可能是空的</span></span><br><span class="line"><span class="keyword">if</span> (_name != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line">_name = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们给它赋值之后，可以调用某个方法让它执行某些操作，如自报家门。</span></span><br><span class="line">Introduce();</span><br><span class="line"><span class="comment">// 直接写代码</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;Name&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote><p>我们可以给对象设定一些它的“动作”。比如说人类可以开车、吃饭、睡觉。</p></blockquote><p>一个基本的方法定义为：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[修饰符] [<span class="keyword">static</span>] 返回值类型 方法名([参数<span class="number">1</span>, 参数<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 和我们一般定义的函数是一样的道理</span></span><br><span class="line"><span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法名的命名方式一定是大驼峰</li></ul><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>如果有 static 关键字修饰的属性或方法，说明他是静态的。这类属性和方法可以直接通过 <code>类名.属性名/方法名()</code> 直接调用。不需要实例化对象。具有 static 关键字的属性是全局性的，也就是说我们在 A 类里调用 <code>Person.Age += 1;</code>，那么在 B 类里访问 <code>Person.Age</code> 也是加一之后的值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">World</span> <span class="comment">// 世界类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> Age = <span class="string">&quot;46billion&quot;</span>; <span class="comment">// 这个世界多少岁了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Population = <span class="number">70</span>; <span class="comment">// 人口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 世界毁灭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Destroy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(World.Age); <span class="comment">// 46billion</span></span><br><span class="line">World.Destroy();</span><br><span class="line">World.Population++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecondProgram</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SecondMethod</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(World.Population); <span class="comment">// 71</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒人方法"><a href="#懒人方法" class="headerlink" title="懒人方法"></a>懒人方法</h2><ul><li>ctor 回车，TAB。创建构造函数</li><li>cw 回车，TAB。Console.WriteLine() 的懒人方法</li><li>propfull 回车，TAB。创建一个带有 getter 和 setter 的属性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 期末学习报告</title>
      <link href="/2022/63b47942.html"/>
      <url>/2022/63b47942.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>通过这门课程，学习了 C# 这一门高级语言。</p><p>C# 可以完成很多事情。例如：</p><ol><li>编制 ASP.NET 后端服务程序</li><li>编制 Window Form 桌面程序</li><li>配合 XAML 标记语言，可以编写 WPF 应用程序。</li><li>使用 Unity 引擎可以快速开发一款多端运行的游戏。</li></ol><p>认真学习了有关程序流程结构的相关知识。</p><ol><li>顺序结构：程序由上往下逐行执行。</li><li>分支结构：当表达式的条件成立，则执行对应的代码块。</li><li>一个完整的 C# 程序主要包含以下部分：<ol><li>命名空间（Namespace）声明：可以理解为 C# 的文件夹，不同的命名空间下可以包含相同名字的类。</li><li>一个类（Class）</li><li>类的成员方法：用于执行该对象实例化之后某些特定的操作</li><li>类的成员变量：也称作属性，用于保存该实例化之后的对象属性值。</li><li>一个 Main 方法：是所有 C# 程序的入口函数</li><li>语句（Statement）和表达式（Expression）：语句用于让程序执行某件操作，而表达式可以用于得到某些数据的处理结果</li><li>注释：用于说明这行代码的用处，是团队协作中甚至是个人项目必不可少的东西，让你在很久之后再次打开这个项目时能够快速地明白该代码段是在处理什么事情。</li></ol></li></ol><p>学习到了许多关键字，以及相应的语法结构</p><p>如 delegate（委托）搭配 events（事件）使用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TootaioFramework</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line"><span class="comment">// 声明委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegateEvent</span>(<span class="params"><span class="built_in">int</span> param1, <span class="built_in">int</span> param2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> MyDelegateEvent OnEventTriggered;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数，这个函数会调用该委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>()</span> &#123;</span><br><span class="line"><span class="comment">// 其他代码段</span></span><br><span class="line"><span class="comment">// 执行事件，如果该事件有被挂上，则执行该委托，并传递对应的参数</span></span><br><span class="line">OnEventTriggered?.Invoke(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AnotherClass</span> &#123;</span><br><span class="line"><span class="comment">// 执行该代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">myClass.OnEventTriggered += EventTriggered;</span><br><span class="line">myClass.DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是所需要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EventTriggered</span>(<span class="params"><span class="built_in">int</span> param1, <span class="built_in">int</span> param2</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 执行某些代码段</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;The params are: <span class="subst">&#123;param1&#125;</span> and <span class="subst">&#123;param2&#125;</span>.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习了面向对象的思想，</p><p>面向对象包含了两个很重要的东西——属性、方法</p><ul><li>属性：这个对象有什么特征。如：颜色、重量、位置</li><li>方法：这个对象能干嘛。如：上色、掉落</li></ul><p>并学会了运用它来解决一些问题。例如，动物们都会发出叫声，而他们的叫声各不相同。这就可以用多态来实现。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TootaioExercise</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个动物类</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动物可以获取名字</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">GetName</span>()</span>;</span><br><span class="line">        <span class="comment">// 动物可以有叫声</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Cry</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 狗子继承 动物类</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Cry</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;name&#125;</span>，是只<span class="subst">&#123;type&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 猫子继承 动物类</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Cry</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;喵喵喵&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GetName</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;我叫<span class="subst">&#123;name&#125;</span>，是只<span class="subst">&#123;type&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 我们使用 动物类来定义一个狗子，和一个猫子</span></span><br><span class="line">            Animal dodo = <span class="keyword">new</span> Dog();</span><br><span class="line">            Animal lele = <span class="keyword">new</span> Cat();</span><br><span class="line">            dodo.name = <span class="string">&quot;多多&quot;</span>;</span><br><span class="line">            dodo.type = <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">            lele.name = <span class="string">&quot;乐乐&quot;</span>;</span><br><span class="line">            lele.type = <span class="string">&quot;橘猫&quot;</span>;</span><br><span class="line">            <span class="comment">// 因为动物类有声明了他们的共同函数，所以可以直接调用该函数。这就是多态</span></span><br><span class="line">            dodo.Cry();</span><br><span class="line">            dodo.GetName();</span><br><span class="line">            lele.Cry();</span><br><span class="line">            lele.GetName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一些心得。</p><p>在这个学期，我尝试用 Unity 开发一款小游戏。游戏成品可在官方网站 <a href="https://tootaio.com/demo/">https://tootaio.com/demo/</a> 下载体验。其中学会了 Unity 引擎的使用，了解怎么根据 Unity 以及其他优秀工具开放的 API 来进行开发。游戏功能包括：</p><ul><li>点击屏幕控制角色移动。</li><li>随机生成平台</li></ul><p>学到的知识点有：</p><ul><li>对象池 - 用于优化游戏运行性能。对象池的好处是可以通过循环使用 Unity GameObject，来减少内存分配的执行事件。在游戏开始之后几乎不用额外动态的分配内存空间给予程序。这大大的提高了游戏在手机端上运行的性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 第 4 课笔记</title>
      <link href="/2022/c9c071ee.html"/>
      <url>/2022/c9c071ee.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>创建 Windows Application 窗体应用 (.NET Framework)</p><p>在解决方案资源管理器（Solution Explorer）中，</p><ol><li>引用 Reference 包含了系统库，还有一些第三方库</li><li>App.config 当前应用的配置文件</li><li>Form1.cs 资源文件（窗体的逻辑代码）<ol><li>Form1.Designer.cs 源码文件（界面设计的源码）</li><li>Form1.resx 资源文件</li></ol></li><li>Program.cs 主方法源码文件。</li></ol><p>工具箱：包含了所有用到的控件</p><p>控件包含了</p><ol><li>Properties 属性<ol><li>可以修改控件的名称</li></ol></li><li>Events 事件<ol><li>设置每个事件的调用函数</li></ol></li></ol><p>从窗体设计界面到后台代码编辑器的方式有三种：</p><ol><li>在 Event 设置事件，回车</li><li>双击控件，它会自动创建点击事件（命名规则为 <code>该控件的名字_click</code>）</li><li>快捷键 F7</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 第 3 课笔记</title>
      <link href="/2022/e0fb646d.html"/>
      <url>/2022/e0fb646d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while-循环条件"><a href="#while-循环条件" class="headerlink" title="while 循环条件"></a>while 循环条件</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式) &#123;</span><br><span class="line"><span class="comment">// 执行这里的代码（中间这段代码称为循环体）</span></span><br><span class="line"><span class="comment">// 需要让上面的条件在某一次循环之后为假，跳出循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如：重复 n 次打印文本</p><ul><li>条件：次数</li><li>循环体：打印文本</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;文本&quot;</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 这一段至少会执行一次</span></span><br><span class="line"><span class="comment">// 如果 while 条件为真，则再执行一遍</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件表达式)</span><br></pre></td></tr></table></figure><p>以下是个案例</p><ul><li>循环体：修改论文，询问老师是否通过</li><li>条件：老师给的答复</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 询问导师论文通过与否</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;撰写论文中……&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;论文写好啦！&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我的论文可以通过吗？&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> answer = Console.ReadLine();</span><br><span class="line">&#125; <span class="keyword">while</span> (answer.Equals(<span class="string">&quot;No&quot;</span>))；</span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环变量; 循环条件; 改变循环变量) &#123;</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>与之对立的是<strong>面向过程</strong>，强调的是完成这件事情的动作。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>类：将相同属性和方法的对象进行封装，完成类的概念<ul><li>人类：年龄、性别、身高 | 吃饭、睡觉</li><li>车类：速度、马力 | 行驶</li></ul></li><li>字段：就是所存放的数据，如上面的年龄、性别、身高</li><li>属性</li><li>方法：就是这个类能执行的事情，如上面的吃饭、睡觉</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _name; <span class="comment">// 私有字段命名方式通常为 _ 开头</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> IsMale;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性，声明的属性类型必须和他所对应的字段类型相符</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"><span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125; <span class="comment">// value 是内置变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性可以用来让阻止用户输入越界</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> _age; &#125;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">value</span> &lt; <span class="number">0</span> || <span class="keyword">value</span> &gt; <span class="number">104</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">value</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">_age = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isMale</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">_name = name;</span><br><span class="line">_age = age;</span><br><span class="line">IsMale = isMale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明对象并使用</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;小强&quot;</span>, <span class="number">21</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 person 的名字</span></span><br><span class="line">person.Name = <span class="string">&quot;小麦&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于属性，value 是内置的，是我们赋值的“值”</li><li>要访问对象的属性和方法，使用 <code>.</code> 运算符</li></ul><h3 id="三大特征——封装、继承、多态"><a href="#三大特征——封装、继承、多态" class="headerlink" title="三大特征——封装、继承、多态"></a>三大特征——封装、继承、多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>上面我们定义了一个 Person 类，那么程序员也属于 Person，我们可以继承他，获取人类有的能力，并且可以定义自己所需的能力。</p><blockquote><p>一次继承只能有一个</p></blockquote><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Programmer</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 可以有自己的字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _language;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _computer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Programmer</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">bool</span> isMale, <span class="built_in">string</span> language, <span class="built_in">string</span> computer</span>) : <span class="comment">// 用分号运算符来实现调用父类的方法</span></span></span><br><span class="line"><span class="function"><span class="title">base</span>(<span class="params">name, age, isMale</span>) <span class="comment">// 调用父类构造函数（根据父类构造函数对应的参数，都要给上）</span></span></span><br><span class="line">&#123;</span><br><span class="line">_language = language;</span><br><span class="line">_computer = computer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以有自己的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以有自己的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Coding</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>:</code> 运算符实现继承</p><p>这时候我们可以通过创建 Programmer 对象，可以访问 Person 的属性</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;小强&quot;</span>, <span class="number">21</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 person 的名字</span></span><br><span class="line">person.Name = <span class="string">&quot;小麦&quot;</span>;</span><br><span class="line"></span><br><span class="line">Programmer programmer = <span class="keyword">new</span> Programmer(<span class="string">&quot;小刘&quot;</span>, <span class="number">24</span>, <span class="literal">false</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;Apple&quot;</span>);</span><br><span class="line"><span class="comment">// 可以调用 Programmer 定义的函数</span></span><br><span class="line">programmer.Coding();</span><br><span class="line"><span class="comment">// 可以调用 Person 定义的函数</span></span><br><span class="line">programmer.Eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承的核心概念在于：<br>把所有相同的属性提高一个档次，称为父类。比如程序员类、学生类和老师类都有姓名、年龄等属性。那么我们就把这个属性提高成 人 类。让这程序员类、学生类和老师类都继承人类。<br>这样，程序员类、学生类和老师类都拥有人类的特征，并且还有自己的方法。</p></blockquote><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><blockquote><p>同一个事件在不同的对象上会产生不同的效果</p></blockquote><p>我们可以在同一个范围中定义多个相同名字的函数，但是函数的参数必须不同。可以是参数类型不同，可以是参数数量不同</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestPolymorphism</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c</span>)</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TestPolymorphism dataClass = <span class="keyword">new</span> TestPolymorphism();  </span><br><span class="line"><span class="built_in">int</span> add1 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">int</span> add2 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;add1 :&quot;</span> + add1);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;add2 :&quot;</span> + add2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h5><p>用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。</p><ul><li>您不能创建一个抽象类的实例。</li><li>您不能在一个抽象类外部声明一个抽象方法。</li><li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。</li><li>抽象类是实现多态的一种方法</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">area</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span>: <span class="title">Shape</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> length;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"> <span class="built_in">int</span> a=<span class="number">0</span>, <span class="built_in">int</span> b=<span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">length = a;</span><br><span class="line">width = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">area</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Rectangle 类的面积：&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (width * length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">RectangleTester</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line"><span class="built_in">double</span> a = r.area();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>,a);</span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="virtual-虚方法"><a href="#virtual-虚方法" class="headerlink" title="virtual 虚方法"></a>virtual 虚方法</h5><p>当有一个定义在类中的函数需要在继承类中实现时，可以使用<strong>虚方法</strong>。</p><ul><li>虚方法是使用关键字 <strong>virtual</strong> 声明的。</li><li>在子类方法中使用 <strong>override</strong> 声明方法。</li><li>虚方法可以在不同的继承类中有不同的实现。</li><li>对虚方法的调用是在运行时发生的。</li><li>动态多态性是通过 <strong>抽象类</strong> 和 <strong>虚方法</strong> 实现的。</li></ul><p><a href="https://www.runoob.com/csharp/csharp-polymorphism.html">https://www.runoob.com/csharp/csharp-polymorphism.html</a></p><h5 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h5>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 第 2 课笔记</title>
      <link href="/2022/2175bbad.html"/>
      <url>/2022/2175bbad.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="C-Sharp-的结构有哪些特点"><a href="#C-Sharp-的结构有哪些特点" class="headerlink" title="C Sharp 的结构有哪些特点"></a>C Sharp 的结构有哪些特点</h2><ol><li>命名空间实现的分层管理</li><li>命名空间下包含若干个类型（其中最重要的是“类”）</li><li>类下面包含函数或方法</li><li>方法由语句组成</li></ol><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">成员定义（字段定义、方法定义等）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法和函数的定义"><a href="#方法和函数的定义" class="headerlink" title="方法和函数的定义"></a>方法和函数的定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">声明部分</span><br><span class="line">执行部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Sharp-关键概念"><a href="#C-Sharp-关键概念" class="headerlink" title="C Sharp 关键概念"></a>C Sharp 关键概念</h2><ol><li>程序 Program<ol><li>编译出来的最终运行单位 exe</li></ol></li><li>命名空间 Namespace<ol><li>相当于 Java 的包</li><li>用于在同一个程序中定义同一个名称的类</li></ol></li><li>类型 Type<ol><li>分为基础类型：整数、浮点数……</li><li>复杂类型：字符串、用户定义的类</li></ol></li><li>成员 Member<ol><li>在一个类之下的数据（变量）</li></ol></li><li>程序集 Assembly<ol><li></li></ol></li></ol><h2 id="C-Sharp-程序的开发历程"><a href="#C-Sharp-程序的开发历程" class="headerlink" title="C Sharp 程序的开发历程"></a>C Sharp 程序的开发历程</h2><p>语句 -&gt; 方法 -&gt; 类 -&gt; 命名空间</p><h2 id="C-Sharp-数据类型"><a href="#C-Sharp-数据类型" class="headerlink" title="C Sharp 数据类型"></a>C Sharp 数据类型</h2><p>整数、浮点数、字符、Double</p><p>字符串</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>接收用户输入，获取两个字符串，将其字符串链接（用 <code>+</code> 运算符），保存在新的变量之中，然后输出。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Uni_Learning</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> firstString; <span class="comment">// 用于保存第一个字符串</span></span><br><span class="line">            <span class="built_in">string</span> secondString; <span class="comment">// 用于保持第二个字符串</span></span><br><span class="line">            <span class="built_in">string</span> combinedString; <span class="comment">// 用于保存合并之后的字符串</span></span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入第一个字符串：&quot;</span>);</span><br><span class="line">            firstString = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入第二个字符串：&quot;</span>);</span><br><span class="line">            secondString = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并字符串</span></span><br><span class="line">            combinedString = firstString + secondString;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;合并之后的字符串为：&quot;</span>);</span><br><span class="line">            Console.WriteLine(combinedString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一题，我们学会了强制转换。然后重点！Console.ReadLine() 接收的是字符串。就算用户输入 <code>16</code>，那也是字符串。</p><p>所以我们需要使用 Convert.ToInt32 函数将其转换为整数型。</p><p>同样的，Convert 类还包含了一大堆其他的函数可以转换成各种数据：Base64、Float等等</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>输入两个数字，比较大小，用方法实现<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Uni_Learning</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> x, y;</span><br><span class="line">            <span class="built_in">int</span> max;</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">            <span class="comment">// 用 Convert.ToInt32 强制转换为整型</span></span><br><span class="line">            x = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">            Console.Write(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">            y = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用函数获取最大值</span></span><br><span class="line">            max = Max(x, y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出结果，有三种方式输出数据：</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一种，缺点是容易少写加号或引号</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大值是：&quot;</span> + max + <span class="string">&quot;。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二种，使用占位符</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;最大值是：&#123;0&#125;。&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三种，使用 C# 6.0 的新特性 String Interpolation</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;最大值是：<span class="subst">&#123;max&#125;</span>。&quot;</span>); <span class="comment">// 这个比较人性化</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Max</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用三目运算符</span></span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>所以这一题我们学会了<strong>字符串链接</strong>和<strong>几种不同的输出</strong></p><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><p>输入姓名、高数、语文、英语三门课的成绩，显示：XX，你的总成绩为 XX 分，平均成绩为 XX 分。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Uni_Learning</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> name; <span class="comment">// 姓名</span></span><br><span class="line">            <span class="built_in">float</span> math, chinese, english; <span class="comment">// 三门课的成绩</span></span><br><span class="line">            <span class="built_in">float</span> total, avg; <span class="comment">// 总成绩，平均分</span></span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入您的姓名：&quot;</span>);</span><br><span class="line">            name = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入高数成绩：&quot;</span>);</span><br><span class="line">            <span class="comment">// 字符串转换为浮点数 它返回布尔值，也就是说如果用户输入的不是浮点数的话，那么会返回 false，可以配合 if else 进行错误纠正</span></span><br><span class="line">            <span class="comment">// 然后第二个参数一定要配上 out。因为他的参数接受的是 ref，也就是这个变量的“地址”</span></span><br><span class="line">            <span class="built_in">float</span>.TryParse(Console.ReadLine(), <span class="keyword">out</span> math);</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入语文成绩：&quot;</span>);</span><br><span class="line">            <span class="built_in">float</span>.TryParse(Console.ReadLine(), <span class="keyword">out</span> chinese);</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">&quot;请输入英文成绩：&quot;</span>);</span><br><span class="line">            <span class="built_in">float</span>.TryParse(Console.ReadLine(), <span class="keyword">out</span> english);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得总分和平均分</span></span><br><span class="line">            total = math + chinese + english;</span><br><span class="line"></span><br><span class="line">            avg = total / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            <span class="comment">// 我用字符串模板的方式进行拼接 $&quot;&quot;</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span>，你的总成绩为<span class="subst">&#123;total&#125;</span>分，平均成绩为<span class="subst">&#123;avg&#125;</span>分&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本日学习"><a href="#本日学习" class="headerlink" title="本日学习"></a>本日学习</h2><ol><li>顺序结构<ol><li>C# 程序是顺序的、从上往下逐行执行的。</li></ol></li><li>跳转结构<ol><li>当程序遇到函数时，就会暂停在执行到的地方，然后进入函数，当函数执行完毕或者遇到 return 关键字时，继续执行刚刚的代码</li></ol></li><li>选择语句<ol><li>if（平时用的比较多，不解释）</li><li>switch<ol><li>因为有 default，可以用来接收并处理不是预期所要的用户输入等数据。</li></ol></li></ol></li><li>循环语句<ol><li>while</li><li>do</li><li>for</li></ol></li><li>跳转语句<ol><li>goto（不建议使用）<ol><li>会照成程序结构被破坏（Spaghetti Code 面条代码）</li><li>降低代码可读性</li></ol></li><li>break</li><li>continue</li><li>return</li><li>throw<ol><li>抛出异常</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 第 1 课笔记</title>
      <link href="/2022/b897ddac.html"/>
      <url>/2022/b897ddac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="net-指向两个"><a href="#net-指向两个" class="headerlink" title=".net 指向两个"></a>.net 指向两个</h2><ol><li>.net 平台</li><li>.net Framework 框架</li></ol><h2 id="C-用途"><a href="#C-用途" class="headerlink" title="C# 用途"></a>C# 用途</h2><ul><li>桌面应用程序<ul><li>QQ</li><li>腾讯会议</li></ul></li><li>开发 Web 应用程序</li><li>手机开发<ul><li>Windows Phone</li></ul></li><li>3D 游戏开发、虚拟现实<ul><li>Unity3D 开发引擎</li></ul></li></ul><h2 id="C-主要特点"><a href="#C-主要特点" class="headerlink" title="C# 主要特点"></a>C# 主要特点</h2><ol><li>语法简洁</li><li>优越的面向对象</li><li>与 Web 紧密结合</li><li>完整的安全性及完整的错误处理机制</li><li>实用性和兼容性强</li></ol><h2 id="NET-是啥"><a href="#NET-是啥" class="headerlink" title=".NET 是啥"></a>.NET 是啥</h2><p>简而言之，就是给你在开发上提供一套较为完整的武器。让你可以快速开发</p><h3 id="简洁的比喻"><a href="#简洁的比喻" class="headerlink" title="简洁的比喻"></a>简洁的比喻</h3><p>厨师 —— 开发者<br>厨房 —— .NET 平台<br>调料、厨具—— .NET Framework 框架<br>食材 —— C#<br>菜 —— 程序</p><p>.NET 就相当于 Java 的 JVM，只不过是微软与生俱来的。用于跨平台运行 C# 应用</p><p>类库相当于 Java 的 Util 包之类的，或者说 C 语言的 stdlib.h 这些</p><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><p>简称 VS，是微软开发的 IDE。</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li>打开 Visual Studio，点击 Create New Project</li><li>选择 Console App （没有的话，上面搜）</li><li>然后里面的项目名之类的默认（学习用不用纠结）</li><li>.NET Core 版本选低版本一点（.Net core 3.5）</li></ol><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System; <span class="comment">// 类库（所以我们可以对系统（包括控制台）进行操作）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span> <span class="comment">// 相当于 Java 的包（可以在别的引用 using 这个命名空间）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> <span class="comment">// 类 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主程序入口，每个控制台程序有且仅有一个 Main 函数</span></span><br><span class="line">        <span class="comment">// string[] args 是系统调用的参数</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用 Console 类的 WriteLine 函数，输出 Hello World</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World&quot;</span>)；</span><br><span class="line">            Console.Readkey(); <span class="comment">// 避免程序直接退出（需要接受用户输入才继续执行）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目目录（文件列表）"><a href="#项目目录（文件列表）" class="headerlink" title="项目目录（文件列表）"></a>项目目录（文件列表）</h2><p>打开项目文件目录，里面的文件列表：</p><ol><li>obj 文件夹是系统指向的文件，在开发的时候需要用到</li><li>bin 文件夹是当项目运行的时候，所导出的可执行文件保存的位置，里面<ol><li>debug 是调试的可执行文件，这里面包含了完整的调试信息。用于开发用</li><li>release 是当我们需要输出给其他人使用的发行包</li></ol></li><li>.csproj 文件是 Visual Studio 的项目文件，保存了项目信息</li><li>Program.cs 是我们程序的源码。在 C# 里，源码的文件名不像 Java，可以和 class 名不相同</li></ol><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不确定对不对</span></span><br><span class="line">Console.Read(); <span class="comment">// 接收用户输入</span></span><br><span class="line">Console.ReadLine(); <span class="comment">// 会等待直到用户按下回车，一次读入一行</span></span><br><span class="line">Console.ReadKey(); <span class="comment">// 则是等待用户按下任意键，一次读入一个字符。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSharp 配置和创建新项目</title>
      <link href="/2021/e83a265a.html"/>
      <url>/2021/e83a265a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a> 下载 Visual Studio</p><p>下载 Community 2019（其他两个版本属于专业版，需要付费）社区版的功能齐全，所以下载社区版就行。</p><p>安装之后需要等待，因为微软服务器在国外，所以要安装很久。</p><p>为了方便打开 Visual Studio，</p><p>以 Win 10 为例，打开开始菜单，在里面搜 Visual Studio Installer 和 Visual Studio 2019，可以右键将其固定到开始菜单：</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20Location.png"/></p><p>先打开 Visual Studio Installer，点击 Visual Studio Community 2019 的 Modify</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20Installer%20Home.png"/></p><p>在弹出的窗口中，勾选 .NET desktop development，然后点击右下角的 Install while downloading，等待下载。</p><p>然后我们打开 Visual Studio，首先会叫你注册账号，下面有个不显眼的链接可以点击直接跳过（应该是叫 Skip）</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20Home.png"/></p><p>点击 Create New Project, 在上方搜 Console，然后在列表中选择 Console App（注意每个列表项中有语言，选择 C# 的），</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20Create%20Console%20App%201.png"/></p><p>点击右下角的 Next，然后我们可以给项目名称 Project Name 取上自己喜欢的名字，其他的目录默认就行（可以选择自己喜欢的位置）。最后点击 Next，选择 .Net Core 3.1，再点击 Create 创建项目。</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20Create%20Console%20App%202.png"/></p><p>最后 Visual Studio 界面长这样：</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Visual%20Studio%20New%20Console%20App.png"/></p><h2 id="Unicode-乱码解决"><a href="#Unicode-乱码解决" class="headerlink" title="Unicode 乱码解决"></a>Unicode 乱码解决</h2><p>有时候运行会出现乱码，如下</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Unicode%20Problem.png"/></p><p>打开设置，搜索 region 或者 地区，打开 Region Setting / 地区设置。</p><p>把 Country or region 改为 China</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Unicode%20Region%20Setting.png"/></p><p>滑倒最下方，找到 Additional date, time &amp; regional settings。如果是全屏设置的话，那么这个选项就在右侧</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Additional%20Regional%20Settings%20Link.png"/></p><p>点开 Region（区域选项）</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Region%20Setting%20Link.png"/></p><p>点击 Administrative 标签页，点击 Change system locale… 按钮</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Region%20Administrative%20Page.png"/></p><p>在弹出框里的下拉菜单找到 Chinese (Simplified, China)，点击 Ok，点击 Apply，然后关闭设置界面，可能需要重启才能生效。</p><h2 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h2><p>我们可以通过 ctrl + space 组合键在任意字中（字符串除外）唤出智能代码提示。</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Code%20Intelligence.png"/></p><p>如果没有弹出任何代码提示，肯定是 ctrl + space 组合键被其他软件占用了。通常是被微软输入法占用了。这时候右键微软输入法，然后点击 Key configuration</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Windows%20IME%20Key%20configuration.png"/></p><p>在弹出的界面中取消勾选 Ctrl + Space 即可</p><p><img src="/uploads/csharp-create-project/C-Sharp%20Windows%20IME%20Uncheck%20Ctrl%20Space.png"/></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Studio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【群成员QA】JavaScript 字符串拼接问题</title>
      <link href="/2021/abdbb30f.html"/>
      <url>/2021/abdbb30f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假设你的 obj 对象长这样（其他的不管）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">data</span>: [&#123;</span><br><span class="line"><span class="attr">scheduleId</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">status</span>: <span class="string">&quot;Confirmed&quot;</span></span><br><span class="line">&#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设你的 Button 字符串长这样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">&quot;&lt;button onclick=&#x27;updateScheduleStatus(&quot;</span> + obj.<span class="property">data</span>[<span class="number">0</span>].<span class="property">scheduleId</span> + <span class="string">&quot;, &quot;</span> + obj.<span class="property">data</span>[<span class="number">0</span>].<span class="property">status</span> + <span class="string">&quot;)&#x27;&gt;&lt;/button&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><p>他的拼接结果如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;updateScheduleStatus(1, Confirmed)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显然，updateScheduleStatus() 的第二个参数将会变成一个名叫 Confirmed 的变量。且这个变量是不存在的。<br>我们实际要的输出结果是：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;updateScheduleStatus(1, &quot;Confirmed&quot;)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样 Confirmed 才会是字符串，而非变量</p><p>解决方案：这里我们用了键盘数字 1 左侧（esc 键下方）的 ` 号作为整个字符串的开关号（也称作 JavaScript 模板字符串），然后把我们需要输出的变量用 <code>$&#123;&#125;</code> 包含起来</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">`&lt;button onclick=&#x27;updateScheduleStatus(<span class="subst">$&#123;obj.data[<span class="number">0</span>].scheduleId&#125;</span>, &quot;<span class="subst">$&#123;obj.data[<span class="number">0</span>].status&#125;</span>&quot;)&#x27;&gt;&lt;/button&gt;`</span></span><br></pre></td></tr></table></figure><p>注意，我们的 status 那边的前后放了 <code>&quot;&quot;</code> 这样，就会变成字符串了。</p><p>拼接结果结果如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;updateScheduleStatus(1, &quot;Confirmed&quot;)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完美解决</p><p>PS: 你的<strong>单双引号需要注意位置</strong>哈（onclick 之后用的是单引号，所以后面的字符串就要用双引号。反之亦然）</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> JavaScript </category>
          
          <category> QA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Minecraft Dungeon 主城系统</title>
      <link href="/2021/c1ebf72a.html"/>
      <url>/2021/c1ebf72a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>主城一开始只有选择关卡的功能，玩家可以通过游玩不同的任务（地图）找到商人。</p><h2 id="常驻商人"><a href="#常驻商人" class="headerlink" title="常驻商人"></a>常驻商人</h2><blockquote><p>以下仅仅记载我目前所解锁的</p></blockquote><p>商人分为几个种类</p><ul><li>普通装备</li><li>铁匠铺：将武器放入铁匠铺进行强化，需要赢得几个关卡，才能强化成功。</li><li>豪华装备</li><li>神秘装备：抽奖</li><li>僵尸猪人：用金块兑换强力武器</li><li>送礼：在线上模式中，可以通过该商人分享游戏道具</li></ul><p>每个商店都有货品栏位，比如说最开始卖普通装备的商人货架只有 2 个栏位，然后通过“解救村民的数量”解锁更多栏位。其他商店的货架也有同样的机制，只不过任务点不相同。</p><h2 id="货币系统"><a href="#货币系统" class="headerlink" title="货币系统"></a>货币系统</h2><p>玩家有三种不同的货币系统。</p><ul><li>最开始的绿宝石货币，用于购买装备</li><li>附魔点数，每升一级送一个点数。可以用来附魔装备，使装备更强，一旦附魔则不能拆卸。除了将装备变卖可以返还<strong>全部</strong>附魔点数</li><li>金块，有些装备的背景颜色是金色的，备注：Glided。这类装备在回收之后会返还金块。超级稀有</li></ul><h2 id="关卡非线性"><a href="#关卡非线性" class="headerlink" title="关卡非线性"></a>关卡非线性</h2><p>基础重要的商人通常都在不同场景的第一关。不同场景之间不是线性的，我可以选择任意一个场景进行挑战。这样我就可以在前期体验不同的地形和生物群系。并解锁对应的商人以及玩法。</p>]]></content>
      
      
      <categories>
          
          <category> 灵感笔记 </category>
          
          <category> 游戏相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考笔记 </tag>
            
            <tag> Minecraft Dungeon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minecraft 游戏节奏思考</title>
      <link href="/2021/cb827cdd.html"/>
      <url>/2021/cb827cdd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>像 Minecraft 一样休闲的生存03e</p><p>玩家可以自行选择游戏难度。游戏难度不会线性增加</p><ul><li>游戏刚开始的僵尸生成频率和游戏末期的频率相同</li><li>影响游戏难度的，是玩家换了个生物群系<ul><li>平原 -&gt; 僵尸少</li><li>地底 -&gt; 僵尸多。以此类推</li></ul></li><li>或者是别的地方有其他比较强的怪物</li><li>怪物的能力不会线性增加。怪物难度根据物种而不同</li></ul><p>这样玩家就可以选择在某个阶段进行悠闲的 Farming<br>让玩家对游戏有更多的控制权，可以决定游戏应该怎么玩</p><p>为什么玩家要去挑战更强的怪物？</p><ul><li>解锁装备，有些强力装备的合成配方不是与生俱来的</li><li>可能因为玩家自身强度变高，需要的基本物资已经不足以支撑或者说枯燥乏味，所以要解锁新的东西</li><li>总的来说，就是挑战更高级的怪物有好东西</li></ul>]]></content>
      
      
      <categories>
          
          <category> 灵感笔记 </category>
          
          <category> 游戏相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考笔记 </tag>
            
            <tag> Minecraft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 第三课</title>
      <link href="/2021/58fccdb6.html"/>
      <url>/2021/58fccdb6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本教程未完结，还有很多东西还没写</p></blockquote><h1 id="流程控制【第三课】"><a href="#流程控制【第三课】" class="headerlink" title="流程控制【第三课】"></a>流程控制【第三课】</h1><p>前面的课程我们对python语法有个基本的理解，这节课之后，我们能够使用python写出一个简单的输入输出程序。</p><p>让我们来运行这么一段程序——打印小于1000的斐波那契序列：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; <span class="number">1000</span>:</span><br><span class="line">    <span class="built_in">print</span>(a, end=<span class="string">&#x27;, &#x27;</span>)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line"><span class="comment"># 输出结果：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987,</span></span><br></pre></td></tr></table></figure><p>观察上面的程序，有几个知识点：</p><ol><li>第一行和第四行用了<strong>多重赋值</strong>，同时获得新值0, 1。等号右表达式求值顺序为从左到右</li><li><code>print(a, end=&#39;, &#39;)</code>，这里的end是print函数的<strong>命名参数</strong>，用途是：将print输出语句之后的文本替换为<code>,</code>默认是<code>\n</code>换行。以此来完成不换行输出</li><li>while关键字，接下来单元所要讲解的东西</li></ol><h2 id="条件语句（Conditional）"><a href="#条件语句（Conditional）" class="headerlink" title="条件语句（Conditional）"></a>条件语句（Conditional）</h2><p>在继续讲解之前，我们来了解计算机里一个很重要的概念——条件判断。在计算机的认知里，只有0和1两种区别。即1为真、0为假。知道这个有什么用呢？</p><p>我们来举个栗子：</p><blockquote><p>有一个密码门，每个人都可以输入他们的名字，但只有叫“Bob”的人才能进入</p></blockquote><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>这时候我们就需要用到<code>if</code>判断语句。顾名思义：<code>if</code>就是<strong>如果</strong>的意思，事实上大部分的编程语言都可以这么理解。而Python是最好理解的其中一个编程语言——它的语法是这样的：如果 条件：条件成立要干什么。所以接着我们上面的例子，代码应该长这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入您的名字：&quot;</span>) <span class="comment"># 获取用户输入的名字</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;Bob&quot;</span>: <span class="comment"># 判断是否有权限进入</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎您！&quot;</span>) <span class="comment"># 如果有权限，则输出这段文字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;验证完毕&quot;</span>) <span class="comment"># 不管有没有权限，都会输出这段文字（注意前面没有空格，也没有tab）</span></span><br></pre></td></tr></table></figure><p>运行代码之后，他会让用户输入名字，如果用户输入的是Bob，则会输出：<code>欢迎您！验证完毕</code>，但如果用户输入别的名字，则只会输出<code>验证完毕</code>。</p><p>这里我们需要注意的是：Python 里没有花括号<code>&#123;&#125;</code>的概念，用<strong>缩进(Indent)</strong>来辨认某一个<strong>块级语句</strong>。同级连续的缩进代表当前语句块是属于同一阶级的。</p><p>什么意思呢？如果我们把代码改成这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入您的名字：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;Bob&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎您！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;验证完毕，&quot;</span>) <span class="comment"># 这个语句缩进了，和上面并行</span></span><br><span class="line">    <span class="comment"># 上两句只有在条件为真的时候，才会执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序执行完毕！&quot;</span>) <span class="comment"># 这个语句无论有没有权限，都会执行</span></span><br></pre></td></tr></table></figure><p>我们再次运行代码，输入<code>Bob</code>，这时候程序会输出：<code>欢迎您！验证完毕，程序执行完毕！</code>，但如果输入别个名字，这次只会输出<code>程序执行完毕！</code>。</p><p>如果需要解释方便记忆的话，可以将这个语法结构理解为一整套单元项目，比如我们的目录，它的同一级的单元将会作为用一个缩进长度</p><p>好，我们学会了单分支判断。那么我们来换个题目，我们应该如何解决这个问题呢？</p><blockquote><p> 有一家娱乐中心，只能允许21岁的人士进入，小于21岁的人则会被请离开</p></blockquote><h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h3><p>if语句要的是<strong>条件成立</strong>则完成什么事情，那么我们还需要另一个东西，表示<strong>条件不成立</strong>则执行什么语句。这时候我们要使用<code>else</code>来处理<strong>条件不成立</strong>时的操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;请输入您的年龄：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(age) &lt; <span class="number">21</span>: <span class="comment"># 注意：由于input接收输入的是字符串，所以需要转换为整形数据类型才能进行比较。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;年龄小于21，禁止入内！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎光~临！&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行这段代码片段，我们会发现当我们输入的值小于<code>21</code>时，他会输出禁止入内的消息、反之会输出欢迎光临。</p><p>以上就是双分支语句了。那么现在又有另一个需求，我们又该如何解决这个问题呢？</p><blockquote><p>有一家游乐园，里面的设施只有高度介于140 - 180的人才能游玩，否者会根据高度显示玩家过矮或过高</p></blockquote><h3 id="if-elif-语句"><a href="#if-elif-语句" class="headerlink" title="if-elif 语句"></a>if-elif 语句</h3><p>刚刚提到的双分支条件判断只能处理一个条件，那么如果我们需要当不能满足这个条件的话，判断另一个条件，如果某一个条件为真，则执行该语句。我们可以通过这段代码完成上述要求：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">height = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入您的身高：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> height &lt; <span class="number">140</span>: <span class="comment"># 当身高小于140cm时，</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的高度不足，不能参与此活动&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> height &gt; <span class="number">180</span>: <span class="comment"># 当身高大于180cm时，</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的高度过高，参与此活动会有危险&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您的高度达到标准，请尽情享受！&quot;</span>)</span><br></pre></td></tr></table></figure><p>那么上面就是我们刚刚根据要求所编程的代码片段。需要注意的是，这个<code>if-elif</code>的流程是：<strong>当<em>从上往下</em>有其中一项为真，则不会再执行其他判断语句</strong>。</p><h2 id="循环（Loop）"><a href="#循环（Loop）" class="headerlink" title="循环（Loop）"></a>循环（Loop）</h2><h1 id="后续课程"><a href="#后续课程" class="headerlink" title="后续课程"></a>后续课程</h1><h2 id="详解print-函数（讲完函数再来讲这个）"><a href="#详解print-函数（讲完函数再来讲这个）" class="headerlink" title="详解print()函数（讲完函数再来讲这个）"></a>详解<code>print()</code>函数（讲完函数再来讲这个）</h2><p>当我们阅读python的<code>builtins.pyi</code>源码时会发现<code>print()</code>函数长这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">*values: <span class="built_in">object</span>, sep: <span class="type">Optional</span>[Text]=..., end: <span class="type">Optional</span>[Text]=..., file: <span class="type">Optional</span>[_Writer]=..., flush: <span class="built_in">bool</span>=...</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(value, ..., sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>他的参数解释大概是这样的：</p><ul><li>values: 必须，在标准输出流、或默认在<code>sys.stdout</code>上打印values的值</li><li>可选参数列表：<ul><li>file: 一个类文件的对象（流stream），默认值为<code>sys.stdout</code></li><li>sep: 两个值之间插入的字符串，默认是一个空格</li><li>end: 在最后一个value之后加上的字符串，默认是换行<code>\n</code></li><li>flush: whether to forcibly flush the stream.</li></ul></li></ul><p>让我们来阅读这么一段代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="什么是创建新的实例（id不相同）"><a href="#什么是创建新的实例（id不相同）" class="headerlink" title="什么是创建新的实例（id不相同）"></a>什么是创建新的实例（id不相同）</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 第二课</title>
      <link href="/2021/15e26ee4.html"/>
      <url>/2021/15e26ee4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Python教学【第二课】"><a href="#Python教学【第二课】" class="headerlink" title="Python教学【第二课】"></a>Python教学【第二课】</h1><h2 id="Python基础：数据类型"><a href="#Python基础：数据类型" class="headerlink" title="Python基础：数据类型"></a>Python基础：数据类型</h2><p>我们来看这么一段代码，并运行他：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="string">&quot;10&quot;</span></span><br><span class="line">z = <span class="number">10.0</span></span><br><span class="line"><span class="built_in">print</span>(x + x, <span class="built_in">type</span>(x)) <span class="comment"># 20   &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(y + y, <span class="built_in">type</span>(y)) <span class="comment"># 1010 &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(z + z, <span class="built_in">type</span>(z)) <span class="comment"># 20.0 &lt;class &#x27;float&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>通过分析运行过程，上面声明了三种不同数据类型下10的变量，我们可以看到，不同类型的数据类型相加产生不一样的结果：</p><ol><li>x 是整数型 int -&gt; integer，相加之后值为整形20</li><li>y 是字符串型 str -&gt; string，相加之后值为字符串”1010”，这就是字符串拼接</li><li>z 是浮点型 float，相加之后值为浮点型20.0</li></ol><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>Python的解释器(Python Interpreter)是个很强大的功能。它能够实时的将您所输入的代码反馈到终端界面上，让您查看这段代码的执行结果。事实上，在Python解释器中所输入的Python语句都能在代码里写出来。</p><p>在终端输入<code>python</code>即可进入python解释器中（前提是你得在安装python过程中勾选Add to Path选项）。这时，您的终端界面应该长这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\username&gt;python</span><br><span class="line">Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="进行数学运算"><a href="#进行数学运算" class="headerlink" title="进行数学运算"></a>进行数学运算</h3><p>进入解释器之后，我们可以在<code>&gt;&gt;&gt;</code>之后写入我们的python语法，我们试试输入几个简单的数学公式。每输入一个公式之后，解释器会直接写出答案：</p><p>python支持多种数学运算符，<code>+ - * /</code>只是其中几个，我们将在后续课程进行讲解；<code>()</code>符对公式进行分组。和数学一样，python也遵循”先乘除，后加减”的运算原则，所以我们需要通过括号对某些公式的优先级进行分组。</p><p><code>/</code>一定返回一个浮点数，如果结果只是要获得一个整数，可以使用<code>//</code>运算分；我们也可以使用<code>%</code>计算余数</p><p><code>**</code>用来计算乘方</p><p><code>=</code>用于给变量赋值，赋值不会有结果显示出来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># 普通的除法返回一个浮点数</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># 底数分割丢弃小数部分</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># %运算符返回除法的余数</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5的平方</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">7</span>  <span class="comment"># 2的7次幂</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>height = <span class="number">5</span> * <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width * height</span><br><span class="line"><span class="number">900</span></span><br></pre></td></tr></table></figure><p>如果访问一个没有定义（未赋值）的变量，尝试访问它时就会报错。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n  <span class="comment"># 尝试访问一个未初始化的变量</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">&#x27;n&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>上一次打印出来的值会被保存在变量<code>_</code>，你可以通过访问变量<code>_</code>继续使用这个值。<br><strong>注意：</strong>这个变量是只读的，不要尝试向他赋值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tax = <span class="number">12.5</span> / <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price = <span class="number">100.50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price * tax</span><br><span class="line"><span class="number">12.5625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>price + _</span><br><span class="line"><span class="number">113.0625</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(_, <span class="number">2</span>)</span><br><span class="line"><span class="number">113.06</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用单引号<code>&#39;... ...&#39;</code>或双引号<code>&quot;... ...&quot;</code>包含起来的一串字符称为字符串，<code>\</code>可以用来转义；输出的字符串会加上引号，<code>print()</code>函数会生成可读性更强的输出，即略去两边的引号，并且打印出经过转义的特殊字符:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;spam eggs&#x27;</span>  <span class="comment"># 用单引号包含</span></span><br><span class="line"><span class="string">&#x27;spam eggs&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;doesn\&#x27;t&#x27;</span>  <span class="comment"># 用 &#x27;\&#x27; 来转义单引号</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;doesn&#x27;t&quot;</span>  <span class="comment"># 用双引号包含，中间的单引号就不需要转义</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;\&quot;Yes,\&quot; they said.&quot;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span>)</span><br><span class="line"><span class="string">&quot;Isn&#x27;t,&quot;</span> they said.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;First line.\nSecond line.&#x27;</span>  <span class="comment"># \n 是换行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  <span class="comment"># 没有调用print函数，\n 包含在输出里</span></span><br><span class="line"><span class="string">&#x27;First line.\nSecond line.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)  <span class="comment"># 调用print(), \n 转译成换行</span></span><br><span class="line">First line.</span><br><span class="line">Second line.</span><br></pre></td></tr></table></figure><p>如果不希望前置<code>\</code>的字符被转义，可以使用<strong>原始字符串</strong>模式，在引号前面加上<code>r</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;C:\some\name&#x27;</span>)  <span class="comment"># \s 无意义，但 \n 是换行</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\some\name&#x27;</span>)  <span class="comment"># 加上r之后，\n不再被转译成换行</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure><p>第一堂课我们提到了多行字符串的输入，也就是三个单引号<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>或三个双引号<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>，字符串的回车会直接包含在字符串中，如果不想要包含该行的回车，可以用<code>\</code>跳过：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;\ # 如果不加上反斜杠，这里将输出个换行</span></span><br><span class="line"><span class="string">Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">     -h                        Display this usage message</span></span><br><span class="line"><span class="string">     -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 输出（注意最开始的换行没有被包含进来）</span></span><br><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br></pre></td></tr></table></figure><p>我们学会了<code>+</code>能够连接两个字符串，那么<code>*</code>可以对字符串进行重复；两个相邻的字符串也将会自动连接在一起，把很长的字符串拆开分别输入的时候尤其有用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&quot;un&quot;</span> + <span class="string">&quot;ium&quot;</span> <span class="string">&quot;Py&quot;</span> <span class="string">&quot;thon&quot;</span> <span class="comment"># 注意字符串的输出</span></span><br><span class="line">unununiumPython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;将多个字符串放在括号中&#x27;</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;以使它们连接在一起。&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;将多个字符串放在括号中以使它们连接在一起。&#x27;</span></span><br></pre></td></tr></table></figure><p>但是字符串的自动相连只能对两个字面值这么做，变量或表达式不行，如果想链接变量或表达式，可以用<code>+</code>，但前提是被连接的必须是字符串：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix = <span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix <span class="string">&#x27;thon&#x27;</span>  <span class="comment"># can&#x27;t concatenate a variable and a string literal</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    prefix <span class="string">&#x27;thon&#x27;</span></span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    (<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>字符串是可以被 <em>索引</em> （下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串；索引也可以用负数，这种会从右边开始数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># 第0位字符</span></span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># 第五位字符</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">1</span>]  <span class="comment"># 最后一个字符</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>]  <span class="comment"># 最后第二个字符</span></span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">6</span>]</span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br></pre></td></tr></table></figure><p>除了索引，字符串还支持 <em>切片</em>。索引可以得到单个字符，而 <em>切片</em> 可以获取子字符串，切片的开始总是被包括在结果中，而结束不被包括。这使得 <code>s[:i] + s[i:]</code> 总是等于 <code>s</code>；切片的索引有默认值：省略开始索引时默认为0，省略结束索引时默认为到字符串的结束</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">&#x27;tho&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">4</span>] + word[<span class="number">4</span>:]</span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]   <span class="comment"># character from the beginning to position 2 (excluded)</span></span><br><span class="line"><span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:]   <span class="comment"># characters from position 4 (included) to the end</span></span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>:]  <span class="comment"># characters from the second-last (included) to the end</span></span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br></pre></td></tr></table></figure><p>您也可以这么理解切片：将索引视作指向字符 <em>之间</em> ，第一个字符的左侧标为0，最后一个字符的右侧标为 <em>n</em> ，其中 <em>n</em> 是字符串长度。例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> | P | y | t | h | o | n |</span><br><span class="line"> +---+---+---+---+---+---+</span><br><span class="line"> 0   1   2   3   4   5   6</span><br><span class="line">-6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure><p>第一行数标注了字符串非负的索引的位置，第二行标注了对应的负的索引。那么从 <em>i</em> 到 <em>j</em> 的切片就包括了标有 <em>i</em> 和 <em>j</em> 的位置之间的所有字符。</p><p>对于使用非负索引的切片，如果索引不越界，那么得到的切片长度就是起止索引之差。例如， <code>word[1:3]</code> 的长度为2.</p><p>使用过大的索引会产生一个错误（数组越界），但是，切片中的越界索引会被自动处理::</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>]  <span class="comment"># the word only has 6 characters</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of <span class="built_in">range</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:<span class="number">42</span>]</span><br><span class="line"><span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">42</span>:]</span><br><span class="line"><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 中的字符串不能被修改，它们是<strong>不可变</strong>的。因此，向字符串的某个索引位置赋值会产生一个错误:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:] = <span class="string">&#x27;py&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>如果需要一个不同的字符串，应当新建一个:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;J&#x27;</span> + word[<span class="number">1</span>:]</span><br><span class="line"><span class="string">&#x27;Jython&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + <span class="string">&#x27;py&#x27;</span></span><br><span class="line"><span class="string">&#x27;Pypy&#x27;</span></span><br></pre></td></tr></table></figure><p>内建函数 <code>len()</code>返回一个字符串的长度:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;supercalifragilisticexpialidocious&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(s)</span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><p>这只是字符串的其中一部分，后续会通过实例等讲解更多字符串的用法</p><h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>Python里的数组叫做列表（个别教程上也叫他序列），它的定义方式是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>] <span class="comment"># 这个alist列表将会贯彻接下来这个单元的教程</span></span><br></pre></td></tr></table></figure><p>和字符串一样（实际上字符串可以理解为一个数组），列表里面的元素也可以通过下标来访问。当然也包括切片（Slices）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Xiaomai&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name[<span class="number">3</span>], alist[<span class="number">3</span>]) <span class="comment"># o 7</span></span><br><span class="line"><span class="built_in">print</span>(alist[-<span class="number">1</span>]) <span class="comment"># 9 最后一个元素</span></span><br><span class="line"><span class="built_in">print</span>(alist[<span class="number">2</span>:]) <span class="comment"># [5, 7, 9] 第二个元素开始到最后一个</span></span><br><span class="line"><span class="built_in">print</span>(alist[:<span class="number">2</span>]) <span class="comment"># [1, 3] 第一个元素开始到第二个</span></span><br></pre></td></tr></table></figure><p>跟字符串很相似，使用<code>+</code>运算符可以拼接列表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist += [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(alist) <span class="comment"># [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>和字符串不一样的是：列表的元素可以被改变</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist[<span class="number">5</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(alist) <span class="comment"># [1, 3, 5, 7, 9, 11, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p><strong>Index函数：</strong>我们可以用list的index函数找到某个元素的下标：比如我们需要替换<code>alist</code>列表里值为<code>11</code>的元素，可以通过这行代码。但是Index参数里的数据值没有出现在列表里，则会报错</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist[alist.index(<span class="number">4</span>)] = <span class="number">13</span> <span class="comment"># 等价于：alist[6] = 13</span></span><br><span class="line"><span class="built_in">print</span>(alist) <span class="comment"># [1, 3, 5, 7, 9, 11, 13, 6, 8, 10]</span></span><br><span class="line">alist.index(<span class="number">22</span>) <span class="comment"># ValueError: 22 is not in list</span></span><br></pre></td></tr></table></figure><p><strong>Append函数：</strong>用于在数组末尾添加元素</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist.append(<span class="number">666</span>)</span><br><span class="line"><span class="built_in">print</span>(alist) <span class="comment"># [1, 3, 5, 7, 9, 11, 13, 6, 8, 10, 666]</span></span><br><span class="line">alist.append([<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(alist) <span class="comment"># [1, 3, 5, 7, 9, 11, 13, 6, 8, 10, 666, [6, 6, 6]]</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以知道，list的元素可以包含不止一种数据类型</p><p>利用切片，我们也可以对列表的某一个片段的值进行增加、修改、删除等操作。或者直接清空整个列表。这个过程不会“创建”新的列表实例（进阶教学里解释）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alist = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Ball&quot;</span>, <span class="string">&quot;Covid&quot;</span>, <span class="string">&quot;Donkey&quot;</span>, <span class="string">&quot;Egg&quot;</span>, <span class="string">&quot;Food&quot;</span>] <span class="comment"># 重新初始化数组</span></span><br><span class="line">alist[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&quot;Graph&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Igloo&quot;</span>] <span class="comment"># 原先三个，替换三个</span></span><br><span class="line">alist[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&quot;Joker&quot;</span>, <span class="string">&quot;Knight&quot;</span>] <span class="comment"># 原先三个，替换两个 -&gt; 少一个</span></span><br><span class="line">alist[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">&quot;Light&quot;</span>, <span class="string">&quot;Monkey&quot;</span>, <span class="string">&quot;Nurse&quot;</span>, <span class="string">&quot;Order&quot;</span>] <span class="comment"># 原先三个，替换四个 -&gt; 多一个</span></span><br><span class="line">alist[<span class="number">2</span>:<span class="number">5</span>] = [] <span class="comment"># 清空这段切片的元素</span></span><br><span class="line">alist[:] = [] <span class="comment"># 清空整个列表，用的是旧的列表实例</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 第一课</title>
      <link href="/2021/undefined.html"/>
      <url>/2021/undefined.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本教程是小麦根据自己的开发经验和研究对python知识点的整理，尝试使用简单易懂的方式让读者入门python这门强大的编程语言。主要参考官方的Python教程</p><h1 id="课前须知"><a href="#课前须知" class="headerlink" title="课前须知"></a>课前须知</h1><h2 id="Python环境安装"><a href="#Python环境安装" class="headerlink" title="Python环境安装"></a>Python环境安装</h2><p>到<a href="https://www.python.org/">Welcome to Python.org</a>下载一个Python。本教程用的是<code>Python 3.8.6</code>版本。</p><h1 id="Python-教学【第一课】"><a href="#Python-教学【第一课】" class="headerlink" title="Python 教学【第一课】"></a>Python 教学【第一课】</h1><h2 id="常用CMD指令"><a href="#常用CMD指令" class="headerlink" title="常用CMD指令"></a>常用CMD指令</h2><p><code>dir</code> - directory，显示当前文件夹下的目录列表</p><p><code>cd &lt;文件夹名|完整路径&gt;</code> - change directory，跳转到某个目录<br><code>cd ..</code> 跳转到上一个目录<br><code>cd /</code>跳转到根目录</p><p><code>cls</code> - clear screen 清屏</p><p><code>&lt;盘符&gt;:</code> - 如<code>D:</code>跳转到该盘下。</p><p><code>python &lt;文件名&gt;.py</code> 执行python文件</p><h2 id="Python-基础：Hello-World"><a href="#Python-基础：Hello-World" class="headerlink" title="Python 基础：Hello, World!"></a>Python 基础：Hello, World!</h2><h3 id="注释"><a href="#注释" class="headerlink" title="# - 注释"></a><code>#</code> - 注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python里的单行注释是长这样的</span></span><br><span class="line"><span class="comment"># 注释可以用来取消掉某行代码的执行（被注释的代码将不会被执行）</span></span><br><span class="line"><span class="comment"># 注释是用来阐明代码的，不会被 Python 解释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Python 里还有另一种长注释，可以通过三个单引号或双引号包含起来</span></span><br><span class="line"><span class="string">这样的话，就可以写多行注释而不需要每一行都添加个井号。</span></span><br><span class="line"><span class="string">事实上这个写法也是个多行字符串，只是如果我们不去对这段字符串进行任何操作，就可以当作多行注释来用</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="输出print-在显示器上"><a href="#输出print-在显示器上" class="headerlink" title="输出print() - 在显示器上"></a>输出<code>print()</code> - 在显示器上</h3><p>能输出的字段包括但不限于字符串（除了以下三个，还能输出其他类型的数据）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Python语句结尾不需要 ‘;’，否则会爆错！</p><p>可以在不用进行类型转换的情况下输出多个不同类型的数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myName = <span class="string">&quot;Andrew&quot;</span></span><br><span class="line">myAge = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(myName, myAge) <span class="comment"># Andrew 20</span></span><br></pre></td></tr></table></figure><h3 id="输入input-用户从键盘输入"><a href="#输入input-用户从键盘输入" class="headerlink" title="输入input() - 用户从键盘输入"></a>输入<code>input()</code> - 用户从键盘输入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myName = <span class="built_in">input</span>(<span class="string">&quot;Please input your name: &quot;</span>) <span class="comment"># input的参数（括号里的字符串）是给用户的输入提示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is: &quot;</span> + myName)             <span class="comment"># &#x27;+&#x27; 号可以用来拼接字符串（后续会详解）</span></span><br></pre></td></tr></table></figure><p><code>input()</code>函数的返回值（用户输入的值）一定是字符串，不论用户输入的是任意类型的值</p><h3 id="变量及赋值"><a href="#变量及赋值" class="headerlink" title="变量及赋值"></a>变量及赋值</h3><p>python 是一个<strong>弱类型</strong>的语言，定义变量时不需要声明数据类型。变量的数据类型通过赋值时右侧的数据值类型决定。这叫<strong>隐式声明(implicit declaration)</strong></p><p><code>=</code>用于赋值变量，将<code>=</code>右侧的<strong>数据值</strong>或<strong>表达式结果</strong>赋值给左侧的变量名。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myVar = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 这时候myVar就是个字符串类型的变量</span></span><br><span class="line">myVar = <span class="number">123</span>    <span class="comment"># 这时候myVar就是个整数型的变量</span></span><br></pre></td></tr></table></figure><h3 id="检查变量类型、类型转换"><a href="#检查变量类型、类型转换" class="headerlink" title="检查变量类型、类型转换"></a>检查变量类型、类型转换</h3><p><code>type()</code>类用于检查某个变量值（或表达式）的类型</p><p><code>int()</code>类用于将数字字符串转换为整数型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myNum = <span class="built_in">input</span>()    <span class="comment"># 获取用户输入变量值（假定用户输入的一定是数字）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(myNum)) <span class="comment"># 输出结果：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment"># str就是string的简写</span></span><br><span class="line"><span class="comment"># 也就是变量myNum的类型是字符串</span></span><br></pre></td></tr></table></figure><p>如果用户输入数值，且该数值需要进行数学运算，则需要转换类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(myNum) + <span class="number">1</span>) <span class="comment"># 假设用户输入的值是 5，那么输出就会变为6</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>但是用户如果输入的是非数值，则会报错<code>invalid literal for int() with base 10: &#39;&#39;</code></p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><code>+</code>号用来进行字符串与字符串拼接</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="string">&quot;world!&quot;</span>) <span class="comment"># 输出结果：Hello, world!</span></span><br></pre></td></tr></table></figure><p>但是字符串不能与非字符串进行拼接</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="number">123</span>) <span class="comment"># 这是错误写法</span></span><br></pre></td></tr></table></figure><p>上面会报错：<code>can only concatenate str (not &quot;int&quot;) to str</code>意思是：字符串只能与字符串（str）拼接而不是整数（int）</p><p><strong>解决方法：</strong></p><p>用<code>str()</code>转换为字符串类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="built_in">str</span>(<span class="number">123</span>)) <span class="comment"># 类型转换</span></span><br></pre></td></tr></table></figure><h2 id="第一课小结"><a href="#第一课小结" class="headerlink" title="第一课小结"></a>第一课小结</h2><p>用上面学到的知识点，可以写出一个基本的功能：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">userName = <span class="built_in">input</span>(<span class="string">&quot;请输入您的名字：&quot;</span>)  <span class="comment"># 获取用户输入，并给予输入提示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;您好，&quot;</span> + userName)          <span class="comment"># 打招呼</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入您需要计算的值&quot;</span>)</span><br><span class="line">varA = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;初值：&quot;</span>))         <span class="comment"># 获取用户输入，并转换成整数</span></span><br><span class="line">varB = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;被加数：&quot;</span>))</span><br><span class="line">answer = varA + varB               <span class="comment"># 整数型 + 整数型 = 整数型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;答案：&quot;</span> + <span class="built_in">str</span>(answer))       <span class="comment"># 因为answer是整数型，所以需要转换为字符串类型</span></span><br></pre></td></tr></table></figure><p>我们又学会了一个新的写法：<code>int(input())</code><br>当python遇到这个语句时，他会先执行<code>input()</code>，获取用户输入的数据，然后再执行<code>int()</code>转换input的返回值</p><p>当然，你也可以这么写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;答案：&quot;</span> + <span class="built_in">str</span>(varA + varB))</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;答案：&quot;</span>, varA + varB)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>两个数据值相加得到的结果可以理解为表达式的返回值（这句有点绕），拆分来看就是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(varA + varB) <span class="comment"># 假设：varA = 16, varB = 32</span></span><br><span class="line"><span class="built_in">str</span>(<span class="number">16</span> + <span class="number">32</span>)</span><br><span class="line"><span class="built_in">str</span>(<span class="number">48</span>)</span><br><span class="line"><span class="string">&quot;48&quot;</span> <span class="comment"># 最终结果</span></span><br></pre></td></tr></table></figure><p>所以由此可见，python是一门简单易学，且灵活的编程语言。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 笔记</title>
      <link href="/2021/2da2039a.html"/>
      <url>/2021/2da2039a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="C-笔记"><a href="#C-笔记" class="headerlink" title="C++笔记"></a>C++笔记</h1><h2 id="C-源程序打印Hello-World"><a href="#C-源程序打印Hello-World" class="headerlink" title="C++源程序打印Hello World"></a>C++源程序打印Hello World</h2><blockquote><p>假设你已经装好了Mingw编译器，没有安装的话，请自行移步网络上找教程</p></blockquote><p><strong>第1步：</strong>为了方便教学，我们在桌面创建一个文件夹，名为<code>cpp-tutor</code></p><p><strong>第2步：</strong>在<code>cpp-tutor</code>文件夹里创建一个txt文件，文件名为<code>hello</code>，后缀名由<code>txt</code>改为<code>cpp</code>，将以下内容输入进文件内容</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第3步：</strong>使用<code>Win键 + R</code>打开运行窗口，输入<code>cmd</code>打开命令控制符</p><p><strong>第4步：</strong>在命令控制符里输入</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">%USERPROFILE%</span>/Desktop/cpp-tutor</span><br></pre></td></tr></table></figure><p>打开刚刚创建好的文件夹</p><blockquote><p>默认情况下，打开控制台的默认路径就已经是<code>C:\Users\用户名</code>了，这时候只需要输入<code>cd Desktop/cpp-tutor</code>即可</p></blockquote><p><strong>第5步：</strong>然后输入</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">g++ ./hello.cpp -o helloworld</span><br></pre></td></tr></table></figure><p>此程序用于编译刚才写好的<code>hello.cpp</code>C++源程序，并将其输出的可执行文件<code>.exe</code>命名为helloworld</p><p>接下来，如果没有出现报错（控制台没有出现任何东西，视为编译通过。也可以通过检查刚刚创建的文件夹里有没有<code>helloworld.exe</code>来判断是否编译成功）</p><blockquote><p>或者可以通过在控制台输入<code>dir</code>，输出文件列表查看列表中是否出现<code>helloworld.exe</code></p></blockquote><p><strong>第6步：</strong>然后输入</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">helloworld.exe</span><br></pre></td></tr></table></figure><p>执行刚才编译好的可执行文件。接下来你应该会在控制台上发现<code>Hello, world!</code>被打印输出了。</p><p>我们可以将<strong>第5步和第6步</strong>合并为一句：</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">g++ hello.cpp -o helloworld &amp;&amp; helloworld.exe</span><br></pre></td></tr></table></figure><p>用了<code>&amp;&amp;</code>号，意思是：当编译成功，则直接执行exe文件。</p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// &lt;iostream&gt; 头文件定义了标准数据输入输出流，使程序能够将文字输出到控制台上。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// std 命名空间包含C++标准库的而功能（cout、endl）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个C系程序有且仅有一个main函数，是整个程序的入口。返回值必须是int类型，代表程序运行的异常代码。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl; <span class="comment">// C++的输出语句的语法，`endl`表示换行，可以用`\n`来代替`endl`。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0表示此程序正常退出。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最简单的输出语句了。</p><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><p>输出语句的其他用法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;其实可以分很多行来写&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;比如这一句包含很多句子，&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;这么写就能提高代码可读性&quot;</span> &lt;&lt; endl; <span class="comment">// 这一个将会被当作一句输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我们也可以通过\n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;来实现换行\n&quot;</span>; <span class="comment">// 用 \n 取代endl，达成换行效果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> myVariable = <span class="number">10</span>; <span class="comment">// 声明一个整型变量myVariable，并赋值10给它</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">30</span>, b = <span class="number">15</span>; <span class="comment">// 同时声明两个整数型变量，并分别赋值30, 15给它们</span></span><br><span class="line">    <span class="type">int</span> sum = a + b; <span class="comment">// 将上面声明的a, b变量相加，并赋值给新声明的sum变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们可以通过cout输出每个变量的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myVariable = &quot;</span> &lt;&lt; myVariable &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a</span><br><span class="line">        &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入语句"><a href="#输入语句" class="headerlink" title="输入语句"></a>输入语句</h2><p>我们可以通过输入语句获取用户的输入</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> userInput; <span class="comment">// 声明变量，可以不赋值。</span></span><br><span class="line">    <span class="comment">// C++没有默认值，当下分配到的地址值原先是多少，就是它的默认值（MSVC）</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个整数值：&quot;</span>; <span class="comment">// 输入提示</span></span><br><span class="line">    cin &gt;&gt; userInput; <span class="comment">// 获取用户输入（注意箭头朝右）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所输入的值是：&quot;</span> &lt;&lt; userInput &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> x = <span class="number">100</span>;  <span class="comment">// unsigned 只能保存正数，long 占用默认两倍的字节</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> y = <span class="number">16</span>;           <span class="comment">// short 是只占用默认一半的字节</span></span><br><span class="line">    <span class="type">float</span> pi = <span class="number">3.14</span>;            <span class="comment">// float 占用4个字节</span></span><br><span class="line">    <span class="type">double</span> temp = <span class="number">36.8</span>;         <span class="comment">// double 占用8个字节</span></span><br><span class="line">    string txt = <span class="string">&quot;Hello world&quot;</span>; <span class="comment">// string 是一个字符串，是C++标准库里的。</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;              <span class="comment">// char 字符</span></span><br><span class="line">    <span class="type">bool</span> isLearning = <span class="literal">true</span>;     <span class="comment">// bool 只有两个值：true 和 false</span></span><br><span class="line">    <span class="type">bool</span> isPlaying = <span class="number">0</span>;         <span class="comment">// 也可以用数值0、1代替，将其输出，将会输出0和1，而不是true和false</span></span><br><span class="line">    cout &lt;&lt; isLearning &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对char型的一些研究"><a href="#对char型的一些研究" class="headerlink" title="对char型的一些研究"></a>对char型的一些研究</h3><p>char型变量用于保存一个字符，如A，b等等。用一段程序来进行研究，研究目的是创建一个“令白嫖党看不懂的”版权信息</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// char 叫多字节字符，一个 char 占一个字节</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> ascii_A = (<span class="type">int</span>)ch;                  <span class="comment">// 将字符转换成ASCII码</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; ascii_A &lt;&lt; endl; <span class="comment">// A : 65</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个英文字符都能转换成对应的ASCII（美国信息交换标准代码）</span></span><br><span class="line">    <span class="comment">// 所以：</span></span><br><span class="line">    <span class="type">char</span> copyright[] = <span class="string">&quot;Made by Xiaomai&quot;</span>; <span class="comment">// 这是版权信息</span></span><br><span class="line">    cout &lt;&lt; copyright &lt;&lt; endl;            <span class="comment">// Made by Xiaomai</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到它的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(copyright) / <span class="built_in">sizeof</span>(copyright[<span class="number">0</span>]);</span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl; <span class="comment">// 16（包括结束标识符\0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历转换成ASCII码</span></span><br><span class="line">    <span class="type">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        temp = (<span class="type">int</span>)copyright[i];</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; <span class="string">&quot;, &quot;</span>; <span class="comment">// 将每一个字符的ASCII码输出出来</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl; <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里先运行一遍，获取每个字符的ASCII码</span></span><br><span class="line">    <span class="comment">// 复制控制台中的这一段：77, 97, 100, 101, 32, 98, 121, 32, 88, 105, 97, 111, 109, 97, 105, 0</span></span><br><span class="line">    <span class="comment">// 最后一个逗号不需要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的字符数组，数组元素为上面的这一串ASCII码</span></span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="number">77</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">98</span>, <span class="number">121</span>, <span class="number">32</span>, <span class="number">88</span>, <span class="number">105</span>, <span class="number">97</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// Made by Xiaomai</span></span><br><span class="line">    <span class="comment">// 就可以得到一个记录版权信息的字符串了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来是让这组信息在特定时间点之后才出现</span></span><br><span class="line">    <span class="comment">// 注意：time函数需要引用头文件&lt;ctime&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">time</span>(<span class="number">0</span>) &gt; <span class="number">1621094400</span>) &#123;</span><br><span class="line">        <span class="comment">// 2021年5月16日之后才会显示</span></span><br><span class="line">        <span class="comment">// 至于UNIX时间戳，自行谷歌计算</span></span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把过程简化，最后我们只需要这么几行：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a[] = &#123;<span class="number">77</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">98</span>, <span class="number">121</span>, <span class="number">32</span>, <span class="number">88</span>, <span class="number">105</span>, <span class="number">97</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">time</span>(<span class="number">0</span>) &gt; <span class="number">1621094400</span>) &#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个嘛，你把它藏在你的程序中间，可以防止有人白嫖你的作业去交。比较适合坑新手~</p><h4 id="汉字引发的惨案"><a href="#汉字引发的惨案" class="headerlink" title="汉字引发的惨案"></a>汉字引发的惨案</h4><p>不说了，看半成品……毫无头绪</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">4</span>] = <span class="string">&quot;我&quot;</span>;  <span class="comment">//前三个字节存放汉字&#x27;我&#x27;,最后一个字节存放字符串结束符\0</span></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl; <span class="comment">// 我</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> ni = <span class="string">&#x27;你&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wchar_t 被称为宽字符，一个 wchar_t 占 2 个字节。</span></span><br><span class="line">    <span class="type">wchar_t</span> hans = <span class="string">L&#x27;我&#x27;</span>; <span class="comment">// 等价于 L&#x27;\x6211&#x27;</span></span><br><span class="line">    <span class="type">int</span> ascii_hans = (<span class="type">int</span>)hans;</span><br><span class="line">    cout &lt;&lt; hans &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; ascii_hans &lt;&lt; endl; <span class="comment">// 我 :</span></span><br><span class="line"></span><br><span class="line">    <span class="type">wchar_t</span> wstr[<span class="number">2</span>] = <span class="string">L&quot;中&quot;</span>; <span class="comment">// 前两个字节(前一个 wchar_t)存放汉字&#x27;中&#x27;,最后两个字节(后一个 wchar_t)存放字符串结束符\0</span></span><br><span class="line">    <span class="type">wchar_t</span> wstr2[<span class="number">3</span>] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">    cout &lt;&lt; wstr &lt;&lt; endl; <span class="comment">// 这里会输出地址，我还要研究怎么输出文字</span></span><br><span class="line">    cout &lt;&lt; wstr2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">11</span>, <span class="number">45</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">88</span>&#125;; <span class="comment">// 声明一个长度为5的数组，然后赋值</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 打印的是地址值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组下标从0开始，所以要打印第n个元素时，下标需为n-1：</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第2个元素为：&quot;</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp 基础 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（19）准备武器</title>
      <link href="/2021/db6458d9.html"/>
      <url>/2021/db6458d9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>欢迎来到第六部分！重头戏！！！战斗系统。</p><p>首先，我们需要裁剪所需的武器图片素材</p><p><img src="/uploads/unity2020-rpg/20210815%20Weapons.png"/></p><p>裁剪之后，点击 Apply。在 Project 面板中，我们把 weapon_0 拖曳到 Hierarchy 面板中 Player 下。使其属于 Player 游戏物件的子物件。然后在 weapon_0 的 Inspector 面板中，增加一个新的 Sorting Layer。</p><p>我们调整一下武器的位置。注意，由于武器的父组件是玩家，所以武器的位置是相对于玩家的（也就是说 0, 0 的位置是在玩家正中央）。我们将位置和大小做调整：Position x = 0.064，y = 0.08；Scale x&amp;y = 0.7。然后我们可以运行游戏，当玩家两面走动的时候，武器会随着玩家的朝向变动。</p><p>然后我们给 weapon_0 加上 BoxCollider2D，再创建一个 Weapon 脚本，它继承了 Collidable 类，武器也需要检测碰撞。</p><p>我们声明几个变量，变量用途都写在注释上了。升级系统需要获取武器的 SpriteRenderer 是因为我们要给其改变不同的武器样式（更换图片）。挥动武器有冷却，还有记录上一次挥动的时间戳，具体原理和文字显示时长一样。</p><p>覆盖 Start 函数，让它调用父类的 Start 函数，因为我们也需要获取 BoxCollider 组件，另外我们也需要获取 SpriteRenderer 组件。</p><p>覆盖 Update 函数，也需要调用父类的 Update 函数，因为该函数会调用 OnCollide 函数检测碰撞。在 Update 函数里要检测当玩家点击空格键，且 <code>当前时间 - 最后一次挥动时间 大于 冷却时间</code> 时，挥动一次并记录这次挥动的时间点。</p><p>写上 Swing 函数，这将会是挥动武器所需要做的操作</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Weapon</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对怪物造成的伤害</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damagePoint = <span class="number">1</span>; <span class="comment">// 对怪物造成的伤害</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> pushForce = <span class="number">2.0f</span>; <span class="comment">// 击退敌人的力度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 升级系统</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> weaponLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer spriteRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挥动武器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> cooldown = <span class="number">.5</span>f; <span class="comment">// 每 0.5 秒挥动一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> lastSwing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Start();</span><br><span class="line">        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Update();</span><br><span class="line">        <span class="comment">// 点击空格攻击</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Time.time - lastSwing &gt; cooldown)</span><br><span class="line">            &#123;</span><br><span class="line">                lastSwing = Time.time;</span><br><span class="line">                Swing();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挥动武器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Swing</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;挥动武器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行游戏，你会发现控制台会持续输出 Player，这是因为我们的武器位置重叠在了玩家身上，玩家和武器都有碰撞体，所以会触发 OnCollide 函数，输出当前碰撞的物体（也就是玩家）。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（18）文字系统 3</title>
      <link href="/2021/7ac9d386.html"/>
      <url>/2021/7ac9d386.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们回到 GameManager 类，才参考对象那里加上一个新的 FloatingTextManager。因为显示文字的函数会被游戏中的各种元素调用（箱子、NPC、怪物……），我们不想在每个地方都有一个 reference 所以统一在 GameManager 设置它。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考对象</span></span><br><span class="line"><span class="keyword">public</span> Player player;</span><br><span class="line"><span class="keyword">public</span> FloatingTextManager floatingTextManager;</span><br></pre></td></tr></table></figure><p>然后我们在 GameManager 类里新建一个函数 ShowText（创建函数的位置和 SaveState 函数同级），参数列表和 FloatingTextManager 的 Show 函数一致。然后调用 floatingTextManager 的 Show 函数，将所有参数值传递进去。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 显示浮动文字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowText</span>(<span class="params"><span class="built_in">string</span> message, <span class="built_in">int</span> fontSize, Color color, Vector3 position, Vector3 motion, <span class="built_in">float</span> duration</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    floatingTextManager.Show(message, fontSize, color, position, motion, duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在别的类需要显示浮动文字，只需要使用如下代码：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GameManager.instance.ShowText(<span class="string">&quot;要显示的信息&quot;</span>, <span class="number">14</span>, Color.yellow, 坐标, 位移量, <span class="number">3000f</span>);</span><br></pre></td></tr></table></figure><hr><p>回到 Unity 引擎，在 Hierarchy 面板中选中 GameManager。首先我们把 Hierarchy 面板中的 Player 拖到 GameManager 的 Player 属性中。</p><p>在 Hierarchy 面板中右键，创建 UI / Panel 将其重命名为 FloatingTextManager。这时候就会看见 Hierarchy 中出现三个游戏物件：Canvas、FloatingText 和 EventSystem。</p><p>然后把 Inspector 中的 Image 组件删掉，添加 FloatingTextManager 组件。这个组件我们在代码中定义了两个属性。首先我们把 FloatingTextManager（也就是自己）元素拖到 Text Container 属性里。另一个是 Text Prefab，我们需要创建一个文字预制件。</p><p>在 Hierarchy 面板中，右键 FloatingText 元素，创建 UI / Text 重命名为 FloatingText，这时候发现新建的 FloatingText 元素在 FloatingTextManager 元素之下。我们修改其中的属性值：</p><ul><li>Width = 300; Height = 80</li><li>Font Size = 24</li><li>Aligment 居中，上下居中</li><li>Color = 白色</li></ul><p>然后我们将 FloatingText 拖曳到 Prefab 文件夹里。</p><p><img src="/uploads/unity2020-rpg/20210821%20Floating%20Text.png"/></p><p>再回到 FloatingTextManager，将 Prefab 文件夹里的 FloatingText 拖曳到 TextPrefab 属性里。最后再删除 Hierarchy 面板中的 FloatingText 元素。</p><p>最后回到 GameManager，将 Hierarchy 面板中的 FloatingTextManager 拖曳到 Floating Text Manager 属性中。</p><h2 id="在游戏中显示"><a href="#在游戏中显示" class="headerlink" title="在游戏中显示"></a>在游戏中显示</h2><p>打开 Chest 代码，原先我们获得金币的提示在 Debug.Log，那么现在我们将其用 ShowText 函数取代。参数如下：</p><ul><li>显示字符串：获得 XXX 金币</li><li>字体大小： 24</li><li>颜色：黄色</li><li>位置：在箱子的上方显示</li><li>动效：向上飘</li><li>显示时长：1 秒</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Sprite emptyChest; <span class="comment">// 空箱子的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> goldAmount = <span class="number">10</span>; <span class="comment">// 箱子里拥有的金币</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!collected) <span class="comment">// 当还未被拾取</span></span><br><span class="line">        &#123;</span><br><span class="line">            collected = <span class="literal">true</span>;</span><br><span class="line">            GetComponent&lt;SpriteRenderer&gt;().sprite = emptyChest;</span><br><span class="line">            Debug.Log(<span class="string">&quot;获得了&quot;</span> + goldAmount + <span class="string">&quot;金币！&quot;</span>);</span><br><span class="line">            GameManager.instance.ShowText(</span><br><span class="line">                <span class="string">$&quot;获得<span class="subst">&#123;goldAmount&#125;</span>金币！&quot;</span>, </span><br><span class="line">                <span class="number">24</span>, </span><br><span class="line">                Color.yellow, <span class="comment">// 可以使用 new Color(r, g, b) 来自定义颜色。里面的值是 0 - 1 而非 0 - 255</span></span><br><span class="line">                transform.position, <span class="comment">// 在箱子的上方</span></span><br><span class="line">                Vector3.up * <span class="number">25</span>, <span class="comment">// 向上飘</span></span><br><span class="line">                <span class="number">1.0f</span>); <span class="comment">// 显示 1 秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试游戏，我们得到如下结果：</p><p><img src="/uploads/unity2020-rpg/20210821%20Floating%20Text%20Show.png"/></p><p>如果同时触发多个箱子，会发现 Hierarchy 面板中会出现多个 FloatingText(Clone)。当他们显示完毕之后，会呈现灰色。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（17）文字系统 2</title>
      <link href="/2021/fbb14778.html"/>
      <url>/2021/fbb14778.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这是文字系统的第二部分，这一部分，我们将创建一个 GameObject 包含一个 Manager 脚本，用来负责我们所有地图上的文字。</p><p>创建一个新的脚本 FloatingTextManager。这个类需要有一个包含了所有 FloatingText 的列表，所以这堆 FloatingText 可以作为对象池重复使用。每次重复使用的时候，我们需要修改文字内容、颜色、位置等其他属性。</p><p>我们需要定义两个成员变量，类型为 GameObject。textPrefab 是文字组件的预制件，用于之后在对象池里生成这个组件（我们过后就好像复制 textPrefab 在游戏界面中）。textContainer 是所有文字组件的父级组件。</p><p>然后再有一个保存 FloatingText 类型的列表，这就是我们的对象池。</p><p>接下来准备一个函数 GetFloatingText，这个函数用于从对象池里找到未被激活（未使用）的 FloatingText。如果找不到，或者说对象池为空，那么就创建一个新的 FloatingText。新的 FloatingText 的 GameObject 就是文字预制件（textPrefab），然后他的父组件为 textContainer。再来获取它的 Text 控件。最后将创建好的 FloatingText 对象加入到对象池里。</p><p>在 FloatingTextManager 里我们也要有个 Show 函数，在 FloatingText 的 Show 函数只是让当前文字显示，而 FloatingTextManager 的 Show 函数将会对这个文字组件进行属性设置（文本、颜色之类的）。</p><p>所以 Show 函数，我们需要的参数有：需要显示的文字、字体大小、字体颜色、位置、移动方向、显示时长。然后分别给他赋值。floatingText.text 是一个 Text 类型，里面包含了 text、fontSize、color 等属性。Unity 里有两个不同的坐标系—— World 和 Screen：World 是世界坐标，也就是和地图是同一个坐标系的，另一个是 Screen 屏幕坐标，所有的 UI 都是在 Screen 坐标上。所以，我们需要调用 Camera.main.WorldToScreenPoint 函数将 World 坐标系转换为 Screen 坐标系。</p><p>最后再写上 Update 函数，我们需要便利对象池里的 FloatingText 对象，然后调用它的 UpdateFloatingText 函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FloatingTextManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject textContainer;</span><br><span class="line">    <span class="keyword">public</span> GameObject textPrefab;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;FloatingText&gt; floatingTexts = <span class="keyword">new</span> List&lt;FloatingText&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> FloatingText <span class="title">GetFloatingText</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FloatingText text = floatingTexts.Find(t =&gt; !t.isActive); <span class="comment">// 遍历 FloatingText 列表，找到未被激活的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            text = <span class="keyword">new</span> FloatingText();</span><br><span class="line">            text.gameObj = Instantiate(textPrefab);</span><br><span class="line">            text.gameObj.transform.SetParent(textContainer.transform); <span class="comment">// 设置 gameObj 的父</span></span><br><span class="line">            text.text = text.gameObj.GetComponent&lt;Text&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入到 floatingTexts 对象池中</span></span><br><span class="line">            floatingTexts.Add(text);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="built_in">string</span> message, <span class="built_in">int</span> fontSize, Color color, Vector3 position, Vector3 motion, <span class="built_in">float</span> duration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FloatingText floatingText = GetFloatingText();</span><br><span class="line"></span><br><span class="line">        floatingText.text.text = message;</span><br><span class="line">        floatingText.text.fontSize = fontSize;</span><br><span class="line">        floatingText.text.color = color;</span><br><span class="line">        floatingText.gameObj.transform.position = Camera.main.WorldToScreenPoint(position); <span class="comment">// 转换世界坐标至界面坐标。</span></span><br><span class="line">        floatingText.motion = motion;</span><br><span class="line">        floatingText.duration = duration;</span><br><span class="line"></span><br><span class="line">        floatingText.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (FloatingText floatingText <span class="keyword">in</span> floatingTexts)</span><br><span class="line">        &#123;</span><br><span class="line">            floatingText.UpdateFloatingText();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这篇文章就是准备对象池和其操作。下一篇我们将会学习怎么使用它。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（16）文字系统 1</title>
      <link href="/2021/8deaa023.html"/>
      <url>/2021/8deaa023.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>欢迎来到第五部分——文字系统。在这个部分，我们将会实现一个悬浮文字。大概说一下这个部分的学习内容：</p><ul><li>对象池：这是一种设计模式，因为我们有多个文字需要显示，所以在每次显示一个文字都创建一个 Game Object 再销毁，对系统性能消耗挺高。所以我们将创建几个 Game Object，当需要显示文字的时候，就激活这个 Game Object 让它显示在屏幕上，否则就让它休眠。</li></ul><p>文字系统需要比较多的逻辑：</p><ul><li>需要显示的文字</li><li>被激活了没</li><li>显示在界面上的时长</li><li>显示在界面上的位置</li><li>有没有动画效果</li><li>字体颜色和字形</li></ul><p>所以我们需要创建一个新的脚本，用于编写文字的逻辑代码。脚本名称为 FloatingText。这个脚本是专注于文字的逻辑类代码。</p><p>编辑代码，这次我们不需要继承 MonoBehavior 类。首先我们引用 UnityEngine.UI 命名空间（using 语句）。然后里边定义六个成员变量（变量用途我都写在代码注释了）。</p><p>然后我们定义两个函数，Show 和 Hide，Show 显示函数将 isActive 设置为 true，然后更新 lastShown 时间，最后再把该 gameObj 的激活状态设置为 isActive 的值。Hide 隐藏函数将 isActive 设置为 false，然后一样把 gameObj 的激活状态设置为 isActive 的值。</p><p>UpdateFloatingText 函数首先判断当前文字是否被激活（显示）没有的话直接跳过。否则就检测 当前时间 - 最后一次显示时间 是否大于 显示时长，是的话则隐藏该文字。最后再给文字加上动态效果。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FloatingText</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isActive;</span><br><span class="line">    <span class="keyword">public</span> GameObject gameObj;</span><br><span class="line">    <span class="keyword">public</span> Text text;</span><br><span class="line">    <span class="keyword">public</span> Vector3 motion;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> duration;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lastShown;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">true</span>;</span><br><span class="line">        lastShown = Time.time;</span><br><span class="line">        gameObj.SetActive(isActive);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hide</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isActive = <span class="literal">false</span>;</span><br><span class="line">        gameObj.SetActive(isActive);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateFloatingText</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isActive)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Time.time - lastShown &gt; duration)</span><br><span class="line">        &#123;</span><br><span class="line">            Hide();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gameObj.transform.position += motion * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（15）PlayerPrefs</title>
      <link href="/2021/5fb51f82.html"/>
      <url>/2021/5fb51f82.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上篇文章，我们写好了 GameManager 的基础架构，然后今天我们来完善 SaveState 和 LoadState 函数。</p><h2 id="Awake-函数"><a href="#Awake-函数" class="headerlink" title="Awake 函数"></a>Awake 函数</h2><p>首先我们修改一下 Awake 函数，在 Awake 调用的时候，需要判断 instance（也就是 GameManager 对象）如果不是空的，则删除该 GameObject，然后直接跳出函数。如果是空的，则将这个 GameManager 对象指向 instance 变量（就是上章说的自己指向自己）。</p><p><strong>为什么判断 GameManager 对象是否为空？</strong>因为如果我们回到同一场景（比如说从 Main 去到 Dungeon1 再回到 Main），这样就会出现两个 GameManager 了。所以我们需要判断，如果 instance 不为空，就代表已经有一个 GameManager 存在，那么就删掉这个新的冲突的 GameManager。</p><p>还有一种解决方式是：我们将这个 GameManager 提取出来单独放在一个 Scene 里（比如说加载界面）而这个 Scene 只会被调用一次。那么就能解决这个BUG。</p><p>引用 UnityEngine.SceneManagement 命名空间（第四行使用的 using 关键字），然后给 SceneManager 的 sceneOnload 事件加上 LoadState，当此场景被加载的时候，自动调用该 LoadState 函数。因为是个事件，所以 LoadState 函数的参数也需要做对应的更改，括号内加上 <code>Scene scene, LoadSceneMode mode</code> 即可。</p><p>最后在 Awake 函数里加上 <code>DontDestroyOnload</code> 函数，然后把 gameObject 传递进去，意味着让 Unity 知道加载新场景时不要销毁目标对象。所以 GameManager 在你切换场景的时候，不会被销毁。他会一直存在于你的游戏中。</p><hr><h2 id="SaveState-函数"><a href="#SaveState-函数" class="headerlink" title="SaveState 函数"></a>SaveState 函数</h2><p>在 SaveState 里，我们需要保存四个信息：玩家所选的皮肤、金币、经验值和武器等级。我们使用字符串来保存这些信息。字符串的构成为：<code>皮肤序号|所持金币|经验值|武器等级</code> 每个数值用 | 号作为分隔符（如果你的键盘上没有这个符号，可以长按 ALT 键，顺序按下数字键盘的 1 2 7 即可）。因为皮肤和武器等级系统还没做好，所以我们直接用字符串 0 作为暂时的替代数据。金币和经验值可以直接获取成员变量 gold 和 experience，由于这俩成员变量是 int 类型，所以我们需要调用 ToString 函数将其转换成字符串类型。另外，<code>&quot;|&quot;</code> 一定要用双引号，虽然说单引号也行，但是为了安全起见，我们需要用字符串而非字符。</p><p>然后把这行字符串保存在 PlayerPref 对象里。使用的是 SetString 函数，第一个参数是 key，是数据保存的唯一标识符，第二个参数则是 value 也就是数据。</p><hr><h2 id="LoadState-函数"><a href="#LoadState-函数" class="headerlink" title="LoadState 函数"></a>LoadState 函数</h2><p>在 LoadState 里，首先需要判断 PlayerPrefs 里有没有保存数据（游戏刚开始会触发一次 LoadState，这时候 PlayerPrefs 对象是没有数据的）。我们使用 HasKey 函数来检查是否存在 SaveState 数据。如果没有，则直接跳出函数。</p><p>我们声明一个数组，这个数组用来保存 PlayerPrefs 对象所储存的字符串。我们用 GetString 获得 SaveState 所保存的字符串，然后用 Split 函数将其拆散成数组。上面说到，SaveState 所保存的字符串格式是这个样子的：<code>皮肤序号|所持金币|经验值|武器等级</code> 所以 Split 函数我们传入字符 ‘|’ 作为拆散的标记点。这样，数组下标 0 就是皮肤序号，以此类推。</p><p>接着我们对每个数据进行对应的赋值即可。</p><p>完整 GameManager 代码如下</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">        SceneManager.sceneLoaded += LoadState;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏资源</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Sprite&gt; playerSprites;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Sprite&gt; weaponSprites;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; weaponPrices; <span class="comment">// 武器升级所需要的价格</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; xpTable; <span class="comment">// 升到下一级所需的经验值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考对象</span></span><br><span class="line">    <span class="keyword">public</span> Player player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> experience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存游戏状态</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 要保存：</span></span><br><span class="line"><span class="comment">     * INT preferedSkin</span></span><br><span class="line"><span class="comment">     * INT gold</span></span><br><span class="line"><span class="comment">     * INT experience</span></span><br><span class="line"><span class="comment">     * INT weaponLevel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> state = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        state += <span class="string">&quot;0&quot;</span> + <span class="string">&quot;|&quot;</span>; <span class="comment">// 皮肤</span></span><br><span class="line">        state += gold.ToString() + <span class="string">&quot;|&quot;</span>; <span class="comment">// 金币</span></span><br><span class="line">        state += experience.ToString() + <span class="string">&quot;|&quot;</span>; <span class="comment">// 经验值</span></span><br><span class="line">        state += <span class="string">&quot;0&quot;</span>; <span class="comment">// 武器等级</span></span><br><span class="line"></span><br><span class="line">        PlayerPrefs.SetString(<span class="string">&quot;SaveState&quot;</span>, state);</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">&quot;Save State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载游戏状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadState</span>(<span class="params">Scene scene, LoadSceneMode mode</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PlayerPrefs.HasKey(<span class="string">&quot;SaveState&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>[] data = PlayerPrefs.GetString(<span class="string">&quot;SaveState&quot;</span>).Split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        <span class="comment">// &quot;皮肤|金币|经验值|武器等级&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 更改角色皮肤</span></span><br><span class="line">        gold = <span class="built_in">int</span>.Parse(data[<span class="number">1</span>]);</span><br><span class="line">        experience = <span class="built_in">int</span>.Parse(data[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 更改武器等级</span></span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">&quot;Load State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>其实 SaveState 函数里，保存数据时我们可以使用 SetInt 函数代替 SetString 函数。这样我们可以保存比较大量的游戏数据，并且不容易搞混。</p><hr><h2 id="保存游戏的时机"><a href="#保存游戏的时机" class="headerlink" title="保存游戏的时机"></a>保存游戏的时机</h2><p>由上，当场景被加载的时候，会调用一次 LoadScene。所以加载场景没问题了，接下来我们要知道什么时候需要保存信息。我选择保存的时机为切换地点（触碰传送门）的时候。所以我们修改传送门 Portal.cs 的碰撞脚本如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Portal</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] sceneNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collider.name == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 保存游戏信息</span></span><br><span class="line">            GameManager.instance.SaveState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 传送玩家到随机的地图上。</span></span><br><span class="line">            <span class="built_in">string</span> sceneName = sceneNames[Random.Range(<span class="number">0</span>, sceneNames.Length)]; <span class="comment">// 随机获取一个地图名称</span></span><br><span class="line">            UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName); <span class="comment">// 加载地图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都做好之后，我们开始游戏，然后选中 Game Manager 游戏物件，然后将其 Gold 属性增加至 10，接下来往上走到传送门，当玩家到第二个场景的时候，会发现 10 这个数值也被带过去 Dungeon1 场景了。也会发现因为调用了 DontDestroyOnLoad 函数和，所以 Game Manager 游戏物件会被带到 Dungeon1 场景。</p><p>我们再次启动游戏，也会发现游戏会自动加载我们的 10 个黄金。</p><p><img src="/uploads/unity2020-rpg/20210815%20Save%20N%20Load%20State.png"/></p><h2 id="用代码删除存档"><a href="#用代码删除存档" class="headerlink" title="用代码删除存档"></a>用代码删除存档</h2><p>当我们需要删除档案，在某个地方（比如说新建游戏的按钮或者开始游戏的 Awake 函数）调用 PlayerPrefs.DeleteAll() 函数即可。</p><h2 id="删除游戏存档（高级版，删除存档）"><a href="#删除游戏存档（高级版，删除存档）" class="headerlink" title="删除游戏存档（高级版，删除存档）"></a>删除游戏存档（高级版，删除存档）</h2><p>当我们调用 SaveState 函数，那么游戏数据将会保存在 PlayerPrefs 里。根据 <a href="https://docs.unity3d.com/ScriptReference/PlayerPrefs.html">Unity 官方文档</a> 中，不同的系统和发行方式，PlayerPrefs 保存在不同的位置。这里我们的开发环境是 Windows10，我们来讲解怎么删除 PlayerPrefs 所保存的数据。</p><p>点击 Windows 键 + R 打开运行窗口，然后输入 regedit，点击回车。</p><p>在注册表里找到此路径（影响路径的因素有很多，我经过一番摸索，在这里找到本项目的保存路径）：</p><p><img src="/uploads/unity2020-rpg/Run%20Regedit.png"/></p><p><code>HKEY_CURRENT_USER\SOFTWARE\Unity\UnityEditor\DefaultCompany\TopDown Dungeon</code></p><ul><li><code>HKEY_CURRENT_USER\SOFTWARE\Unity\UnityEditor</code> 这是因为我们现在在 Unity Editor 里进行开发，所以它保存在里面</li><li>DefaultCompany 可以在 Project Setting 面板里进行修改。这是公司名字</li><li>TopDown Dungeon 也是可以在 Project Setting 面板里修改。这是游戏名字</li></ul><p>然后直接删除 TopDown Dungeon 这个文件夹就行了。你可以从里面找到 SaveState 字段，也就是我们定义保存的数据，他是个二进制的字段，但是点进去之后，会在右侧看到所保存的字段：0|10|0|0</p><p><img src="/uploads/unity2020-rpg/20210815%20Save%20Location.png"/></p><p>删除之后，重新运行游戏，就会发现游戏将不会读取数据了。直到下一次保存之前，都是全新档。</p><p>那么这一部分学习了怎么去保存游戏信息。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（14）GameManager</title>
      <link href="/2021/235e0781.html"/>
      <url>/2021/235e0781.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前面三个部分，我们已经把游戏的基本内容做好了（角色移动、场景设计、碰撞触发某些功能）。现在，我们需要给游戏打上地基，让游戏可以保存玩家信息——金币、经验值、武器等……</p><p>那么我们在 Scripts 文件夹里创建一个新的脚本 <strong>GameManager</strong>，Unity 默认会将此脚本的图标变更为齿轮状。双击编辑它。首先，我们定义一个 instance 变量，类型是 GameManager（也就是我们现在创建的脚本），修饰符为 public static。修饰符是 static，这意味着这个变量是全局的。我可以在任何一个类访问 GameManager.instance 来访问到这个 GameManager</p><p>我们让游戏的 GameManager 自己获取自己，所以重写 Awake 函数，内容是 instance = this。意味着这个类的 instance 对象指向他自己。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 Unity，我们先解决一个很久的问题 Sample Scene 有点太开玩笑了，我们打开 Scene 文件夹，然后将其重命名为 Main。注意，记得先保存再命名。</p><p>然后我们在 Main 场景的 Hierarchy 面板中，右键 Create Empty 命名为 Game Manager。这是一个空的游戏物件，意味着他除了能够记录位置之外，就没有其他属性了。我们将其坐标设置为 0（可以直接右键 Transform，然后选择 Reset Component）。</p><p>将 GameManager 脚本嵌入到 Game Object 里。</p><p>Game Manager 是用于保存游戏中的所有主要信息，所以我们给他定义几个成员变量，另外还有两个函数，用于保存和读取游戏状态。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 游戏资源</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Sprite&gt; playerSprites;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Sprite&gt; weaponSprites;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; weaponPrices; <span class="comment">// 武器升级所需要的价格</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; xpTable; <span class="comment">// 升到下一级所需的经验值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参考对象</span></span><br><span class="line">    <span class="keyword">public</span> Player player;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> gold;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> experience;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给大家一些建议，比如我们可以在切换场景的时候保存游戏、或者当玩家拾取道具的时候可以保存游戏，这一切都取决于你。另外读取游戏的时间点可以是在当场景被加载后。Unity 提供了回调函数执行这个操作，接下来我们就去学习这些回调函数。</p><p>那么本章就简单的讲解 GameManager 的用途。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（13）传送门</title>
      <link href="/2021/9e393d82.html"/>
      <url>/2021/9e393d82.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>哈喽大家好，还记得我们在设计第一个地图（有箱子的那个）时画了个凸起的地方吧？这次我们会在那里放置一块碰撞体，当玩家走过去之后，将会被传送到 Dungeon1 场景。</p><p>我们在 SampleScene 的 Hierarchy 面板中，右键创建一个 Game Object 并命名为 Portal（传送门），给其新增 BoxCollider2D 组件，调整它的位置。强迫症，所以我将这个 GameObject 的位置修改为 X = 0，Y = 1.36，Collider 的 Offset 设置为 0，Size 为 0.48 和 0.16，都是 8 和 16 的倍数。</p><p><img src="/uploads/unity2020-rpg/20210814%20Portal%20Collider.png"/></p><p>创建一个新的脚本（Script），命名为 Portal，然后将其拖拽到我们刚刚创建的 Game Object（Portal）里。双击编辑该脚本。因为是传送门，我们不需要从它这儿获取到什么东西。所以它的继承应该是 Collidable。</p><p>重写 OnCollide 方法。我们要实现的逻辑是，当玩家踏入这个区域时，随机传送到一个地牢里。</p><p>定义一个字符串数组，里边保存了需要传送的场景名称。在 OnCollide 函数里，当玩家碰撞到之后，从 sceneNames 数组中获得随机一个地图名称。然后调用 LoadScene 函数，将随机抽到的 sceneName 传递进去，让玩家传送过去新的地图。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Portal</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>[] sceneNames;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collider.name == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 传送玩家到随机的地图上。</span></span><br><span class="line">            <span class="built_in">string</span> sceneName = sceneNames[Random.Range(<span class="number">0</span>, sceneNames.Length)]; <span class="comment">// 随机获取一个地图名称</span></span><br><span class="line">            UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName); <span class="comment">// 加载地图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到 Unity，右上角点击 File / Build Settings。然后看见上方有个列表，默认列出了 SampleScene。现在我们在 Project 面板中打开 Scenes 文件夹，然后将 Dungeon1 场景拖曳到该列表下加入到该列表里。</p><p>最后，<strong>不需要点击 Build</strong>，直接点击 × 关闭窗口。</p><p>所有我们在项目文件里编辑好的场景，都不会被保存进游戏里面。只有在 Build Setting 里注册该场景之后，他才会被 Unity 构建，从而在你的游戏里存在此场景。</p><p>这个设定在于：开发者可以构建一些测试场景。这些场景是不会被玩家所进入的。开发者只需要将这些测试场景在 Build Setting 里删除，则当游戏导出时就不会包含在里面了。</p><p><img src="/uploads/unity2020-rpg/20210814%20Build%20Setting.png"/></p><p>在 Hierarchy 面板中，选中 Portal 的 Game Object，然后在 Inspector 面板中，Scene Names 点击 + 号，增加一个元素，然后输入 Dungeon1（地牢的名字）。以后如果绘制了更多的地牢，那么就往里边加名字就行了。</p><p>最后最后，在 Dungeon1 场景中，将玩家和摄像头脚本拖入场景中（这边建议将玩家 Player 和 Main Camera 转换为预制件，然后 Main Camera 的 LookAt 记得将 Player 拖进去）。然后调整玩家和镜头的初始位置，我把它放在了带了点样式的地板那个位置（注意，玩家的位置 Position 和镜头的位置一致，这样才会使其居中）。</p><p><img src="/uploads/unity2020-rpg/20210814%20Dungeon1%20With%20Player.png"/></p><p>回到 SampleScene 场景，然后走到传送点的位置，就可以实现传送了。</p><p>那么这一部分就学习到这里，这部分我们讲解了和地图上的物件进行交互（和箱子、NPC交互）以及通过碰撞交互实现传送。下一部分我们将学习怎么保存游戏信息，比如保存玩家金币、经验值等，带到下一关卡。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（12）触碰箱子获取金币</title>
      <link href="/2021/81b2720e.html"/>
      <url>/2021/81b2720e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>这篇文章我们将继续完善箱子功能。但在此之前，我们需要在 Collidable 类和 Chest 类中增加一层 Collectible 类（原先是 Chest 类继承了 Collidable 类；现在是 Chest 类继承 Collectible 类，Collectible 类继承 Collidable 类）。因为之后会有一些物体是碰撞之后，被玩家捡起来的。</p><p>添加这层继承关系是因为，假如之后我们有武器了，当武器挥动的时候，应该是碰撞（Collidable）处理而非获取（Collectible）处理。而箱子则是获取（Collectable）处理。</p><p>所以，修改之后代码如下：</p><p>Chest.cs</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(collider.name + <span class="string">&quot;This is called from Chest.cs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collectable.cs</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collectable</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collectable-类"><a href="#Collectable-类" class="headerlink" title="Collectable 类"></a>Collectable 类</h2><p>接下来，我们要修改 Collectable.cs 的代码。因为是继承了 Collidible 类，所以我们覆盖重写 OnCollide 函数。它需要判断碰撞对象是否为玩家，如果是的话，则将 collected 设置为 true。</p><p>这里的 collected 的修饰符是 protected。该修饰符只能允许自己和自己的子类访问，别人是无法访问的。</p><p>所以现在知道的概念是：当这个物品被玩家触碰之后，它可以被拾取。至于怎么样被拾取（拾取之后获得什么，或者该物件有什么外观上的变化），则通过继承该类的子类进行定义。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collectable</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">bool</span> collected; <span class="comment">// protected 修饰符只能让自己和儿子访问</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当触碰的对象是玩家</span></span><br><span class="line">        <span class="keyword">if</span>(collider.name == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            OnCollect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        collected = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，我们通过判断碰撞对象的名字是否为 Player 来检测对方是否为玩家，所以回到我们的 Unity，在 Hierarchy 面板中选中 player_0 然后将其重命名为 Player。</p><h2 id="Chest-类"><a href="#Chest-类" class="headerlink" title="Chest 类"></a>Chest 类</h2><p>所以现在我们知道，Chest 类继承了 Collectable 类，用人话来说，就是他是能够被拾取的。所以原先我们覆盖重写的是 OnCollide 函数，现在将其删掉，替换为 OnCollect 函数。意味着<strong>当被捡起来时</strong>该干嘛干嘛。</p><p>这次重写 OnCollect 函数，我们保留了 base.OnCollect() 函数的调用。这是因为父类（Collectable 类）里这个函数将 collected（判断是否被捡起来的布尔值）设置为 true。当然，如果你觉得代码可读性降低了的话，你也可以删除 base.OnCollect() 函数，然后替换为 collected = true 语句。</p><p>在这里的 OnCollect 函数，首先我们要判断这件物品是否没被获取过，如果没被获取过，则才可以被获取。那么对于箱子，我们原本的图片箱子是装满了金币的，当玩家触碰之后，金币将会被获取，而箱子变为空的。</p><p>所以我们声明一个 Sprite 对象，这个对象用于保存空箱子的图片。然后再声明一个 int 数值，记录宝箱中拥有的金币数量。这两个变量的修饰符都是 public，所以你可以再 Inspector 面板中直接进行修改。</p><p>在 OnCollect 函数里，我们获取 SpriteRenderer 组件（你打开 Inspector 面板就会看到其实图片就是被这个组件渲染上去的），然后将它的 sprite 属性改为上面定义的 Sprite 对象。</p><p>我们再用 Debug.Log 函数暂时输出“玩家获取了多少金币”这个信息。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collectable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Sprite emptyChest; <span class="comment">// 空箱子的图片</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> goldAmount = <span class="number">10</span>; <span class="comment">// 箱子里拥有的金币</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!collected) <span class="comment">// 当还未被拾取</span></span><br><span class="line">        &#123;</span><br><span class="line">            collected = <span class="literal">true</span>;</span><br><span class="line">            GetComponent&lt;SpriteRenderer&gt;().sprite = emptyChest;</span><br><span class="line">            Debug.Log(<span class="string">&quot;获得了&quot;</span> + goldAmount + <span class="string">&quot;金币！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 Unity 界面，我们从 Artwork 文件夹中的 Atlas 图集里找到 chest_1 图片（这是我们之前裁剪好的空箱子），在 Hierarchy 面板中选中 chest_0，然后把 chest_1 图片长按拖曳到 Inspector 面板中的 Empty Chest 栏里。或者点击 Inspector 面板中，Empty Chest 右侧的小圆圈，可以直接选择所需的图片。</p><p>所以按照上面的代码逻辑，当玩家碰撞到这个箱子，则会触发，图片将会替换为 emptyChest 我们赋值的图片，然后显示信息“获得了xx金币！”。</p><p><img src="/uploads/unity2020-rpg/20210814%20Chest%20Obtain.png"/></p><p>我们可以将 chest_0 命名为 Chest（规范命名），然后将其从 Hierarchy 面板中直接拖曳到 Project 面板中的 Prefabs 文件夹里。这样我们就能直接从 Prefabs 文件夹拖曳出来到游戏场景，从而生成多个箱子。Prefab 就是预制件，也就是已经提前设定好的游戏物件。</p><p>当然，拖出来的每个箱子也能有自己所拥有的金币。</p><p><img src="/uploads/unity2020-rpg/20210814%20Multiple%20Chests.png"/></p><p>那么本章就学到这里。今天就学会了怎么和地图上的物件进行交互。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（11）CSharp 继承</title>
      <link href="/2021/f1cc100.html"/>
      <url>/2021/f1cc100.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>大家好啊，上个文章我们做了个基本的碰撞触发事件，但是只是输出了个 Debug.Log 那么这一章我们将详细地说怎么去实现一些效果，比如打开箱子获得物品。</p><p>那么首先我们就需要到我们的 Atlas 图块里把箱子的像素图切出来。打开 Sprite Editor，开始干活！首先，我们把之前弄好的褐色木箱子改名为 crate，而找到宝箱，他有六个图，我们选两个（一个空的，一个满的）使用即可。将满的命名为 chest_0，另一个为 1。裁剪好了之后点击 Apply。</p><div style="display: flex; justify-content: space-between;">  <img src="/uploads/unity2020-rpg/20210813%20Atlas%20Crate.png"/>  <img src="/uploads/unity2020-rpg/20210813%20Atlas%20Chest.png"/></div><p>然后将 chest_0 图块从 Project 面板拖到游戏场景 Scene 中随便一个位置（注意，不要贴着墙壁，因为墙面有 Collider 演示的时候会造成混淆），这时候你会发现只有一个框框，宝箱没看见。这是因为它的 Sorting Layer 在 Default，被地板当着了，所以我们新建一个 Sorting Layer 命名为 Interactable，将他的位置放在 Floor 和 Actor 之间，也就是在视觉效果里，看见该箱子在地板之上，在角色之下。</p><p>我们给 chest_0 添加一个 BoxCollider2D，然后把 Collidable 脚本也给他套上。这样当我们靠近箱子的时候，Console 就会源源不绝地显示出 player_0。测试好了之后，我们将挂在 chest_0 的 Collidable 脚本给去掉（右键，Remove Component）。</p><p>然后在 Script 文件夹里，创建一个新的 C# Script，将其命名为 Chest。然后双击打开</p><h2 id="编程概念：继承"><a href="#编程概念：继承" class="headerlink" title="编程概念：继承"></a>编程概念：继承</h2><p>打开源文件之后，我们发现代码上写的一行 <code>public class Chest : MonoBehavior</code> 这是 Unity 提供的库，它包含了我们现在用的 RigidBody2D、Collider2D、GetComponent&lt;&gt;() 等一系列不是原生 C# 的代码。MonoBehavior 可以理解为 Unity 的核心架构。所以所有的脚本都继承 MonoBehavior 才能和 Unity 引擎进行交互。</p><p>在 Visual Studio 里，我们双击 MonoBehavior 这行字，然后点击 F12 就可以找到它的源码，然后检查里面所包含的函数和其他信息。然后发现 MonoBehavior 也继承了 Behavior，Behavior 也继承了 Component……。就是这一层层的继承，才能让你在开发中使用那么多不是原生 C# 的函数和对象。</p><p>在这里，我们需要将 Chest 原本继承的 MonoBehavior 改为我们写的 Collidable 类。所以现在的层级关系为：Chest &lt; Collidable &lt; MonoBehavior……</p><p>现在，我们清空我们的代码段，使其成为这样：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Chest 脚本插入 chest_0 游戏物件里。</p><p>现在运行游戏，会发现拥有 Chest 脚本的箱子也会在玩家靠近时触发 Collidable 的代码。</p><p>那么我们是可以对这个 Debug.Log 进行改变的。因为我们在 Collidable 类里声明了 protected virtual OnCollide 函数，virtual 修饰符让你有机会覆盖重写该函数。</p><p>当我们在 Visual Studio 中输入 protected override 然后他就会自动提示你可以覆盖重写的函数。我们选择 OnCollide 函数，系统就会自动帮你补齐代码。</p><p>补齐的代码中，出现一行 base.OnCollide(collider); 语句，base 关键字指向的是父类，也就是说当调用这个函数的时候，可以调用父类声明的 OnCollide 函数。这里我们把这行语句删掉，然后直接写下箱子被角色碰撞到需要的行为。作为继承测试，我们先写上这么一句。然后运行，就会发现：Console 面板中输出的是我们覆盖重写之后的信息了。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">Collidable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(collider.name + <span class="string">&quot;This is called from Chest.cs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/uploads/unity2020-rpg/20210813%20Inheritance%20Demo.png"/></p><p>那么本章就聊到这里。主要讲解了 C# 的继承机制，以及概念。这篇比较深奥，有问题的小伙伴在下方评论区留言，我将会给予答复。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（10）可碰撞物体</title>
      <link href="/2021/d6873b7f.html"/>
      <url>/2021/d6873b7f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>欢迎来到第三部分。这一部分我们将设计一些可以让玩家碰撞之后与其交互的物体。在开始之前，我们打开 Scene 文件夹，然后双击开回 SampleScene 场景（<strong>记得先保存 Dungeon1 场景</strong>）</p><p>我们需要创建一个名为 Collidable 的脚本（Script），这个脚本是放在非玩家单位（如NPC，可破坏物品）的，当玩家触碰到拥有 Collidable 脚本的物体时，将会触发某些设定好的行为。</p><p>在 Scripts 文件夹里右键点击 Create / C# Script 创建脚本，将其命名为 Collidable 然后打开文件。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>首先我们声明三个变量：</p><ol><li>ContractFilter2D 是 public 修饰符，意味着我们可以在 Unity 的 Inspector 面板中对其进行调整。它用于过滤需要检测的游戏物品。</li><li>BoxCollider2D 用于获取当前游戏物体（也就是被挂上此脚本的物体）中的 BoxCollider2D。我们之后需要对这个 BoxCollider2D 进行操作。</li><li>Collider2D 数组用于保存 BoxCollider2D 所碰撞到的所有物体。Collider2D 是所有碰撞体（如 BoxCollider2D、CircleCollider 2D 等）的父类。</li></ol><p>我们用了 protected virtual 修饰符来修饰 Start 和 Update 函数，是因为这个类将会作为父类。也就是它会有儿子继承它。在 Start 函数里，我们首先获取了当前游戏物体的 BoxCollider2D。</p><p>然后在 Update 函数里，我们调用 BoxCollider2D 的 OverlapCollider 函数。该函数用于检测经过 ContactFilter2D 过滤之后的游戏物件，然后将碰撞到的物体保存在 Collider2D 数组里。</p><p>我们使用 for 循环遍历 Collider2D 数组，如果遍历到的元素为 null 则跳过该轮循环，否则就调用我们定义的 OnCollide 函数，传递当前碰撞的元素进去。最后手动清除 Collider2D 数组元素，将当前遍历到的元素设置为 null，以准备下一次循环使用。</p><p>我们定义了一个 OnCollide 函数，里面只写了一句 Debug.Log 函数。在这个章节，我们先将 Update 函数里传递进来的 Collider2D 对象名字输出出来。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Collidable</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ContactFilter2D filter;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D boxCollider;</span><br><span class="line">    <span class="keyword">private</span> Collider2D[] hits = <span class="keyword">new</span> Collider2D[<span class="number">10</span>]; <span class="comment">// 检测所碰撞的物体，最大能检测 10 个</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxCollider = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 碰撞</span></span><br><span class="line">        boxCollider.OverlapCollider(filter, hits); <span class="comment">// 检测当前 GameObject 所碰撞到的物体，然后加入到 hits 数组里。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hits.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hits[i] == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            OnCollide(hits[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 手动清除数组</span></span><br><span class="line">            hits[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当被碰撞的时候被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollide</span>(<span class="params">Collider2D collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(collider.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这段代码拖到 Test_NPC 上，然后开始游戏。当玩家接触到 NPC 时，Console 会输出玩家的名字</p><p><img src="/uploads/unity2020-rpg/20210813%20Collide%20Log.png"/></p><p>上面我们写了个 OnCollide 函数，这就是今天的重点。我们将用其他脚本继承 Collidable 脚本，然后重新实现这个 OnCollide 函数，因为 OnCollide 函数的调用时间在 Update 函数里。所以举个例子：</p><ol><li>当我们在箱子的脚本中重写这个函数，则箱子就会有自己的行为</li><li>而当我们给 NPC 重写这个函数，NPC 也一样有自己的行为。</li></ol><p>那么本章内容就到这里啦！喜欢我的文章的小伙伴可以点击 Discord 社交图标加入我们的服务器哦！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（9）创建地牢</title>
      <link href="/2021/c42f4339.html"/>
      <url>/2021/c42f4339.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我们需要创建一个新的场景（Scene）来创建地牢。先保存现在正在编辑的场景，然后同时按下 CTRL + N ，选择 2D 场景创建一个新的场景。然后 CTRL + S 保存场景，我将其命名为 Dungeon1，保存在 Scenes 文件夹里。</p><p>选中 Main Camera 物件，将其 Size 属性调整成 1。</p><p>创建 2D Object / Tilemap / Rectangular 物件，将其命名为 Floor，并把 Grid 的 Size 属性 改为 0.16。</p><p>这样，我们就有和上一个场景一样的设置了。</p><p>接下来，我们点击 Floor，给其绘制地板地图。绘制完成之后，效果如下：</p><p><img src="/uploads/unity2020-rpg/20210812%20Dungeon%20Floor.png"/></p><p>在 Grid 物件中右键，新建 2D Object / Tilemap / Rectangular 物件，命名为 Other。这个将用作绘制地牢装饰物（如墙体之类的）。开始绘制墙壁，我们还加了个回复泉水。效果如下：</p><p><img src="/uploads/unity2020-rpg/20210812%20Dungeon%20Decoration.png"/></p><p>然后再用深色块吧其他位置补上，让玩家看不到蓝色的背景。修改之后如下：</p><p><img src="/uploads/unity2020-rpg/20210812%20Dungeon%20Walls.png"/></p><p>然后再创建一个 2D Object / Tilemap / Rectangular ，将其命名为 Collision。Layer 调整为 Blocking，然后 Order In Layer 调整为 5。再添加一个Tilemap Collider2D。把你所不要让玩家经过的区域用深色块围起来。（记得把 Tile Palette 的 Active Tilemap 改为 Collision 层）。</p><p>当画好之后，将 Tilemap Render 的勾取消即可。</p><p><img src="/uploads/unity2020-rpg/20210812%20Dungeon%20Walls%20Collider.png"/></p><p>到这里，我们的第二部分《Tilemap 和地牢设计》就告一段落啦，</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个部分，我们讲解了怎么去使用 Tilemap、怎么去绘制地图，以及怎么让玩家只在固定的空间内行走。</p><p>那喜欢我的教学文章的话，可以进入我们的 Discord 服务器进行交流哦！我们下个文章再见啦！拜拜。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（8）绘制地图</title>
      <link href="/2021/7f501c31.html"/>
      <url>/2021/7f501c31.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上篇文章，我们把调色板做好了。这时候点击调色板的画笔工具（注意，不要在 Edit 模式下点击）然后将鼠标放到 Scene 面板上，可以看到图块可以被画到游戏界面上。可是很奇怪，好像画面上只能放置几个图块，然后感觉图块之间的间隔特别大。</p><p>这是因为我们导入这个图集（Atlas）的时候，设置的 Pixel Per Unit 是 100，所以代表一个方块有 100 × 100 个像素点。可是我们的图块实际上只有 16 × 16 个像素点。</p><p>在 Hierarchy 面板中，点击 Grid 然后在其 Inspector 面板中的 Cell Size 属性值里 x 和 y 分别写上 0.16（我们在设镜头设置那篇文章中有提到过）。这是因为图块定义 100PPU，可实际是 16PPU，所以 16 / 100 = 0.16。调整完之后，就可以顺利在界面上进行绘制了。</p><p><img src="/uploads/unity2020-rpg/20210811%20Tilemap%20Setting.png"/></p><p>我们在 hierarchy 面板中创建的 floor 图层用于放置作为背景的图块（例如地板），我们还可以另外添加如 wall、accessories 图层。并且对某些图层设置碰撞体，使角色不能通过该碰撞体或者触发陷阱。</p><p>回到 Tile Palette 面板，我们选择黑色的图块（wall_0）然后点击画笔右侧的矩形工具。回到 Scene 界面，确保我们是看得到镜头的边界的（如上图）如果看不到，点击 Main Camera，然后在 Inspector 界面中展开 Camera 组件即可。</p><p>我们在镜头边界的右上五个开始，点击并拖曳鼠标到镜头右下五格，可以看到界面中出现一片深色区域。</p><p><img src="/uploads/unity2020-rpg/20210811%20Background%20Tile.png"/></p><p>我们选择浅色的图块，作为地板，然后绘制一个凸字形的区域。在游戏里，玩家可以在这个区域（浅色块）间自由行动。绘制完之后，因为玩家移动，镜头会跟随，所以玩家在走到边缘的时候可能会看到边上没有被黑色块覆盖的区域，这些区域将会被显示成蓝色（默认镜头背景色）造成出戏。</p><p>为了防止这事情发生，所以我们需要延长黑色块的大小。因为我们现在选的是地板块（浅色），我们可以点击 ctrl 键，然后点击黑色块来获取该图块。并且在需要增加图块的位置长按拖曳鼠标画上即可。成品如下：</p><p><img src="/uploads/unity2020-rpg/20210811%20Adding%20Floor.png"/></p><p>地板绘制好之后，我们需要做一些装饰。所以我们在 Hierarchy 面板中的 Grid 右键点击它，然后选择 2D Object / Tilemap / Rectangle 创建新的 Tilemap 层，将其命名为 Design。这个层将作为装饰、不带有碰撞体。</p><p>和 Floor 一样，Design 的 Sorting Layer 也需要选择 Floor。然后发现 Floor 的 Order In Layer 为 0，这是该 Sorting Layer 下的排序，从 0 开始，0 最先被渲染，接着是 1……所以我们将 Design 的 Order In Layer 设置为 1。</p><p>在 Tile Palette 面板中，将 Active Tilemap 切换为 Design（也就是刚刚我们创建的 Game Object），接下来就可以在地图上绘制装饰物了。以下是几个快速操作手段：</p><ol><li>按 B 键可以快速切换到笔刷工具</li><li>按 CTRL 键可以在地图上选取所需的图块<ol><li>按 CTRL 键并长安选中拖曳鼠标可以选中多个图块</li></ol></li><li>按 SHIFT 键可以删除不想要的图块</li><li>可以在 Tile Palette 长按鼠标并拖曳以批量选取一套（比如回复泉水由三个块组成，可以直接在调色盘上拖拽通知选中三个图块）</li></ol><p>最后画出来的地图结果如下（我偷偷在 Tile Palette 中加了个带墙体的柱子）：</p><p><img src="/uploads/unity2020-rpg/20210811%20Dungeon%20Map.png"/></p><h2 id="阻挡物-Collider"><a href="#阻挡物-Collider" class="headerlink" title="阻挡物 Collider"></a>阻挡物 Collider</h2><p>我们在 Grid 的 Game Object 上右键，创建 2D Object / Tilemap / Rectangle 然后将其命名为 Collision，Sorting Layer 改为 Floor 而 Order In Layer 改为 5（确保他在所有图层之前）</p><p>我们用深色的块来涂，表示障碍物。这里可以通过 Scene 界面种 右下角的 Focus On 下拉框，选择 Tilemap，这样就能清楚的看到我们绘制的图块。绘制之后效果如下：</p><p><img src="/uploads/unity2020-rpg/20210811%20Map%20Collider.png"/></p><p>然后我们选中 Hierarchy 面板中的 Collision 物体，点击 Inspector 面板中的 Layer 下拉框，选择之前我们创建的 Blocking 图层。然后下方点击 Add Component 按钮添加 Tilemap Collider2D 组件。再来吧 Tilemap Renderer 左侧的勾取消掉，你就只会看到一个个绿色的方块，而不会看到当着视线的深色图块了。</p><p>我们把 Scene 面板中右下角 Focus On 切换为 None，以恢复正常视觉效果。</p><p><img src="/uploads/unity2020-rpg/20210811%20Map%20Collider%20Final.png"/></p><p>接下来我们测试游戏，可以发现玩家只能在我们规定的范围内移动了。但是仔细观察，角色似乎怎么走都在箱子前方，有点违和，我们也会在接下来的教学中修改这个 BUG。</p><p>那么本教学就到这里了，记得注册我们的官网账号和加入我们的 Discord 服务器，以获取更多游戏开发的资讯哦！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（7）创建 Tile Palette</title>
      <link href="/2021/1a298ba8.html"/>
      <url>/2021/1a298ba8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本来这篇文章需要推迟发布的……因为最近正在考虑入手工作机，刚刚都一直在挑选电脑。但是已经跟各位读者约定日更2篇了，只能硬着头皮冲！</p><p>上个教学，我们搞了一堆地图块，现在我们要将其转换成 Tilemap 以便我们可以用画笔的方式直接把图块画上去制作地图。</p><p>在上方菜单栏点击 Window / 2D / Tile Palette，弹出 Tile Palette 面板。因为要一直用到 Tile Palette 所以我们将他的面板固定在某个比较容易使用的位置。通过点击 Tile Palette 标签，可以直接拖动面板，将其放置在所需的位置即可，我们放在如下位置：</p><p><img src="/uploads/unity2020-rpg/20210811%20Tile%20Palette%20Window%20Position.png"/></p><p>然后我们在 Hierarchy 面板中右键，2D Object / Tilemap / Rectangular 创建 Tilemap，然后将其命名为 floor（不是命名 Grid 而是明明 Grid 的子组件）。然后我们点击刚刚命名的 floor 组件，可以看到他有个 Tilemap Renderer 的元件。里面有个属性是 Sorting Layer。是不是感觉似曾相识？之前我们在设置角色被地板当着的时候有用到这个属性。当时我们没有给地板创建一个 Layer。</p><p>那么现在需要点击下拉列表，然后点击 Add Sorting Layer 添加新的图层。然后界面跳转之后，点击 + 号添加新图层，然后新图层名字命名为 Floor。创建完毕之后，确保你的 Floor 层在 Actor 层之上。拖曳图层的 = 按钮，就可以调整它们的排序。</p><p>Sorting Layer 决定了什么东西先被渲染。所以这里是先渲染地板，再渲染玩家。玩家才会出现在地板之上。</p><p>添加图层之后，我们回到 floor 的 Tilemap Renderer 然后将 Sorting Layer 修改为 Floor</p><p><img src="/uploads/unity2020-rpg/20210811%20Add%20Floor%20Layer.png"/></p><p>在 Tilemap Palette 面板中，点击 Create New Palette 创建新的（图块）调色盘，我们将其命名为 Dungeon。</p><p>在这款游戏里我们只用一种调色盘。在其他游戏比如说 Warcraft III 里提供的地图创建功能里有几种不同的图块分别对应不同的场景和季节。</p><p>然后点击 Create，选择我们需要的文件夹。我将其放在 Artwork / Level 文件夹里</p><p><img src="/uploads/unity2020-rpg/20210811%20Create%20New%20Palette.png"/></p><p>我们回到 Project 面板，找到我们需要加为图块的图片。按住 CTRL 多选，我们先选择四个箱子，然后拖曳到 Tilemap Palette 面板中，这里就由原先的灰色背景转为一个网格状的样子。</p><p>放开鼠标，他会让你保存文件。我们将创建一个文件夹，完整路径为：Artwork / Level / Tile 然后就可以看到我们选中的四个箱子图片已经在上面了。并且我们可以在 Project 面板中找到这个文件夹，然后选择每一个图块对其进行微调。</p><p>这时候不出意外的话，箱子的图片是凌乱的。我们需要对其进行排列，来方便我们后续的工作。我们在 Tile Palette 中点击 Edit 按钮。然后键盘点击 S 键选择需要移动的图块，再点击 M 键用鼠标拖曳图块到所需的位置。完成之后：</p><p><img src="/uploads/unity2020-rpg/20210811%20Edit%20Tile%20Palette.png"/></p><p>再次点击 Edit 结束修改，然后重复上面的步骤，把 floor, wall, pillar, healingFountain, stair。这边建议你一次过导入之后，在做调整。调整的时候可以点击 Tile Palette 右上角的三个点，然后选择 Maximize 将这个窗口全屏显示。记得在修改之前点击激活 Edit。修改之后长这样：</p><p><img src="/uploads/unity2020-rpg/20210811%20Tile%20Palette.png"/></p><p>到这里，我们的准备工作就做完了。接下来我们将使用它对地图进行绘制。我们可以点击右上角的三个点，取消 Maximize 的勾，让这个窗口恢复原本的大小和位置。</p><p>那么这篇教学比较短，喜欢这篇文章的小伙伴记得注册我们的官网账号以订阅文章，并且获取更多福利哦！我们下一个教程再见啦~拜拜！</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（6）准备更多图块</title>
      <link href="/2021/fe0d906d.html"/>
      <url>/2021/fe0d906d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>欢迎来到本系列教程的第二部分！第一部分我们讲解了工程创建直到玩家移动，现在我们来开始设计游戏场景。</p><p>首先，我们把之前在 Hierarchy 面板中放置的所有图块（wall 和 floor）删掉，只留下 player_0, Test_NPC 和 Main Camera。还记得怎么操作吗？因为是连贯的，所以我们点击第一个 wall 或 floor，长按 shift 再点击最后一个 wall 或 floor 就可以选取所有了，然后再点 delete 键将其删除。</p><p>接下来，我们要使用 Unity 的 Tilemap 来绘制地图。在这之前，我们需要更多的地图图块，所以回到 Project 面板，找到我们的 Atlas 图集，点击 Sprite Editor 进行切片。先前我们已经切了 wall_0 和 floor_0，我们知道这个图集里所有的图块都是 16 × 16 的单位。就算它比较高，那么也是 32 × 16，都是 16 的倍数。</p><h2 id="准备图块"><a href="#准备图块" class="headerlink" title="准备图块"></a>准备图块</h2><p>那么接下来我们切几个图，注意所有名字都从 0 开始，以方便管理，如：wall_0, wall_1。接下来我们切好几个图：</p><ol><li>地板</li><li>墙壁</li><li>回复泉水</li><li>楼梯</li><li>柱子</li><li>箱子</li></ol><div style="display: flex;">  <img src="/uploads/unity2020-rpg/20210810%20Floor%20Atlas.png"/>  <img src="/uploads/unity2020-rpg/20210810%20Wall%20Atlas.png"/>  <img src="/uploads/unity2020-rpg/20210810%20HealingFountain%20Atlas.png"/>  <img src="/uploads/unity2020-rpg/20210810%20Stair%20Atlas.png"/>  <img src="/uploads/unity2020-rpg/20210810%20Pillar%20Atlas.png"/>  <img src="/uploads/unity2020-rpg/20210810%20Chest%20Atlas.png"/></div>    <p>然后我们还有一个不是 16 × 16 的块，也就是火把，这里我们用 8 × 21，也就是说我们不一定要根据它规定的样式进行切片。可以自己定义规则</p><p><img src="/uploads/unity2020-rpg/20210810%20Torch%20Atlas.png"/></p><p>切片好了之后，我们点击 Apply 保存图块设定</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（5）镜头跟随</title>
      <link href="/2021/c86d9551.html"/>
      <url>/2021/c86d9551.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>比起传统的镜头跟随，我更喜欢一种镜头 - 玩家在一定的范围里移动，镜头位置保持不变，当玩家超出该移动范围，则镜头开始追随玩家，直到玩家再次出现在限定的范围里。</p><p>点击 Main Camera 打开摄像头的 Inspector 界面，我们添加一个自定义脚本，命名为：CameraMotor，创建方法和创建 Player 脚本是一样的。然后我们将 Project 面板里的 CameraMotor 文件拖拽到 Scripts 文件夹里。</p><p>双击用 Visual Studio 打开 CameraMotor 源文件</p><p>删掉所有在 CameraMotor 类里面的函数（Start 和 Update），然后 ctrl + shift + m 打开 Unity 函数库，找到 LateUpdate 函数，点击添加。该函数在 Update 和 FixedUpdate 之后才被调用。因为我们需要在逻辑上让玩家先移动，镜头才跟随。这样不会让玩家产生奇怪的视觉效果。</p><p>在代码里，我们需要镜头跟随一个目标，所以我声明一个变量 public Transform lookAt; 将其修饰符写为 public，以便我们可以在 Inspector 面板中访问它。</p><p>然后我们再定义两个 float 类型的数据 bound。这将用作规定摄像机允许玩家行走且不移动摄像头的边界。</p><p>然后在刚刚添加的 FixedUpdate 函数里开始编程：</p><p>我们需要记录两个帧之间距离的差距，一开始声明一个 Vector3 类型数据 delta，值为 0 （Vector3.zero）。然后我们需要检测目标是否碰到边界，如果碰到边界则移动目标。我们用目标的位置减去相机的位置（计算目标位置和中心点的距离），如果目标超出边界，则开始移动镜头</p><p>我们用 transform.position.x &lt; lookAt.position.x 来判断目标在焦点的右侧；反之（else）就在左侧。在右侧的话，就要修改 delta.x（也就是函数一开始我们定义的位移）为计算出来的边界位移减去边界。</p><p>当修改完 x y 轴，我们就可以移动镜头了。用 transform.position 获取当前 GameObject（也就是摄像机的位置）然后赋值为：transform.position + new Vector3(delta.x, delta.y, 0); <strong>注意，这里的变量是 delta.x 而不是 deltaX</strong></p><p>最后一个参数（z 轴）为 0 是因为我们不能移动镜头的高度。解释：虽然是 2D 游戏，但是镜头 z 轴的位置位于角色以及地板等精灵图的 10 个单位。这就好比你的桌子上有一张纸，然后你要拍摄这张纸，需要在比纸高一点的地方，才能拍到纸上的内容。这里就有小伙伴要问了，为什么修改摄像机 z 轴的值，没有近大远小的效果？这是因为一开始我们创建项目的时候，对摄像机的模式定义为 Orthographic（正交视图），因此不会有透视效果。</p><p>完整代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraMotor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform lookAt; <span class="comment">// 镜头需要聚焦的目标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> boundX = <span class="number">0.15f</span>; <span class="comment">// 角色能够离开中心的最大距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> boundY = <span class="number">0.05f</span>; <span class="comment">// 上下轴</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Update 和 FixedUpdate 之后才被调用。因为玩家先移动，镜头才跟随</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 delta = Vector3.zero; <span class="comment">// 记录两个帧之间的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测目标是否在 x 轴的边界里。</span></span><br><span class="line">        <span class="built_in">float</span> deltaX = lookAt.position.x - transform.position.x; <span class="comment">// 目标的位置 - 相机的位置</span></span><br><span class="line">        <span class="keyword">if</span> (deltaX &gt; boundX || deltaX &lt; -boundX) <span class="comment">// 判断如果出界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transform.position.x &lt; lookAt.position.x) <span class="comment">// 目标在焦点的右侧</span></span><br><span class="line">            &#123;</span><br><span class="line">                delta.x = deltaX - boundX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 目标在焦点的右侧</span></span><br><span class="line">            &#123;</span><br><span class="line">                delta.x = deltaX + boundX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测目标是否在 y 轴的边界里</span></span><br><span class="line">        <span class="built_in">float</span> deltaY = lookAt.position.y - transform.position.y;</span><br><span class="line">        <span class="keyword">if</span> (deltaY &gt; boundY || deltaY &lt; -boundY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transform.position.y &lt; lookAt.position.y) <span class="comment">// 目标在焦点的上方</span></span><br><span class="line">            &#123;</span><br><span class="line">                delta.y = deltaY - boundY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 目标在焦点的下方</span></span><br><span class="line">            &#123;</span><br><span class="line">                delta.y = deltaY + boundY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动镜头</span></span><br><span class="line">        transform.position += <span class="keyword">new</span> Vector3(delta.x, delta.y, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 Unity，很关键的一步，我们需要先在 Hierarchy 面板点击 Main Camera，然后确保它的 Inspector 面板中，我们刚刚写的代码元件已经被加载完毕，加载完毕的效果如右图所示。</p><p>然后我们回到 Hierarchy 面板，直接长按（千万别点击，直接长按！） player_0 然后拖曳到 CameraMotor 元件中的 Look At 属性。这样就可以给摄像机设置目标（为玩家）了。你也可以通过修改 Bound X 和 Y 来调整玩家可以移动的边距。</p><p>接下来，点击 ▶ 即可测试你的玩家是否在移动的时候被镜头跟随了。可以试试调整边界值来观察变化</p><p>那这篇文章到这里结束啦！喜欢我的视频的小伙伴记得在我们的官网注册账号，以获得更多福利哦！我们下个文章再见啦~</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（4）绘制地板和NPC并实现碰撞检测</title>
      <link href="/2021/c070a29f.html"/>
      <url>/2021/c070a29f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先，我们将 Atlas 素材里一开始我们准备好的 player_1 素材拖曳到 Hierarchy 面板。这时候就会产生第二个角色。我们在 Hierarchy 面板中选中刚刚加入的 player_1，然后在 Inspector 面板中，最顶端的 player_1 改为 Test_NPC。以区分他是玩家或是 NPC，然后我们将他的坐标（Position）的 X 轴修改为 -0.2，让他出现在玩家左侧。</p><p>接下来，在 Inspector 面板中，点击 Add Component 按钮，添加一个 BoxCollider2D 元件，该元件就是用来检测物体碰撞，碰撞包括：触碰到NPC和其对话、触碰到怪物造成伤害、触碰到墙体无法继续前进等等。调整框的大小，这里我选择和我的玩家一样。 调整参数为：Offset X: 0, Y: -0.01，Size X: 0.1, Y: 0.1</p><p><img src="/uploads/unity2020-rpg/20210808%20Create%20NPC.png"/></p><h2 id="制作地板"><a href="#制作地板" class="headerlink" title="制作地板"></a>制作地板</h2><p>我们点击 Atlas，然后在 Inspector 面板中点击 Sprite Editor。我们找到两个合适的图标作为地板和墙体。我选择了深色的块作为墙壁，并将其命名为 wall_0；然后选择另一个较为浅色的块作为地板，将其命名为 floor_0。切割完毕之后，点击 Apply，这时候发现 Atlas 图集的小箭头多出了两个图标。</p><div style="display: flex; justify-content: space-between;">  <img src="/uploads/unity2020-rpg/20210808%20Wall%20Sprite.png"/>  <img src="/uploads/unity2020-rpg/20210808%20Floor%20Sprite.png"/></div><p>当我们将 floor_0 图块直接拖拽到 Hierarchy 面板上，默认他会出现在原点（x = 0, y = 0），也就是我们玩家的位置。这时候你会发现，我们的玩家被这个图块挡住了。</p><h2 id="修改渲染图层"><a href="#修改渲染图层" class="headerlink" title="修改渲染图层"></a>修改渲染图层</h2><p>为了解决这个问题，我们需要知道一个概念：图层。在 Hierarchy 面板选择 player_0，在 Inspector 面板定位到 Sprite Renderer 元件的 Sorting Layer 项（如果没有这个属性，则是隐藏在 Additional Layer 里）点开下拉框，然后点击 Add Sorting Layer。这时候 Inspector 面板将会跳转至 Tags &amp; Layer，并且展开 Sorting Layers 属性列。</p><p>在 Sorting Layer 点击右侧的 ＋ 号，新建一个图层 Actor（角色）。添加完毕后，我们再点击 Hierarchy 面板中的 player_0，再找到 Inspector 面板里的 Sorting Layer。点开下拉框选择刚刚添加的 Actor，然后你的 玩家就会出现在地板前面了！</p><p>同理，对 NPC 也要执行同样的操作。</p><p><img src="/uploads/unity2020-rpg/20210808%20Sorting%20Layer.png"/></p><p>接下来，我们需要再继续复制粘贴几个地板，然后再把墙壁放上去。结果大概这样（如果你有强迫症，每个区块之间的间隔为0.16）我们现在用比较笨的方法去弄这个，后续将会使用 Tile Palette 功能进行地图绘制。</p><p><img src="/uploads/unity2020-rpg/20210808%20Simple%20Map.png"/></p><h2 id="碰撞的概念"><a href="#碰撞的概念" class="headerlink" title="碰撞的概念"></a>碰撞的概念</h2><p>首先我们要知道几个需求，地板是没有 BoxCollider 的，所以不被考虑在内：</p><ol><li>玩家不可经过踩上去的地方（碰到这些，玩家会被阻拦）<ol><li>墙体</li><li>NPC</li></ol></li><li>玩家可以踩上去的地方（触发某些机制）<ol><li>开关</li><li>回复泉水</li><li>陷阱</li></ol></li></ol><p>所以，我们需要增加两个图层（Layer）。这和 Sorting Layer 是不同的，Sorting Layer 是关于渲染的层级关系，而 Layer 可以理解为一个组别，我们需要实现的是：当玩家碰上这些块的时候，会出现什么事情。</p><p>现在，我们选择 Hierarchy 界面的 wall_0 然后在 Inspector 界面的 Layer 下拉菜单中点击 Add Layer。我们在 User Layer 中依次添加 Blocking 和 Actor 层。</p><p><img src="/uploads/unity2020-rpg/20210808%20User%20Layer.png"/></p><p>点击 Hierarchy 面板中的 wall_0，然后按住 CTRL 选择 wall_1（可以多选）。如果某些需要选择的物体在 Hierarchy 面板中是连续的，可以直接长按 Shift 多选。然后 Layer 下拉菜单中选择 Blocking，这将作为我们玩家的障碍物。然后我们也要给他俩加上 BoxCollider2D 元件。</p><p><img src="/uploads/unity2020-rpg/20210808%20Wall%20Properties.png"/></p><p>之后再选择 player_0 和 Test_NPC，将 Layer 切换为刚刚创建的 Actor 层。</p><p>别担心，之后不会那么麻烦。我们会把这些琐碎的事情交给 Tilemap 来做，但是现在为了让大家理解原理，就先搞得麻烦一点。</p><p>有了碰撞体之后，还是不能阻止玩家经过的。我们需要让角色知道“哦，这是墙体，我不能穿过去”。那要让角色知道的事情，就需要用代码来完成了。</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>碰撞检测的编程思路是这样的：我们需要在移动的时候，往移动的方向前方投影一个看不见的方块，如果这个方块检测到障碍物，那么人物就不能向前移动。</p><p>所以我们需要声明 RaycastHit2D hit; 变量来检测。</p><p>我们在之前朝向切换和开始移动之间写上一段代码，具体位置在这里：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (moveDelta.x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    transform.localScale = Vector3.one;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (moveDelta.x &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 在这里添加新代码 <span class="doctag">///</span></span></span><br><span class="line"></span><br><span class="line">transform.translate(moveDelta * Time.DeltaTime);</span><br></pre></td></tr></table></figure><p>然后我们说到，RaycastHit2D 的作用是放置一个投影，用于检测前方是否有障碍物，所以我们调用 <code>Physic2D.BoxCast()</code> 函数，创建一个投影块。具体检测两个轴，x 和 y。我们先检测 y 轴（上下），BoxCast() 函数需要传递 6 个参数，分别是：</p><ol><li>投影块要出现的位置：角色的位置</li><li>投影块的大小：角色的 BoxCollider2D 的大小</li><li>角度：角色移动不需要角度，所以传递 0</li><li>方向：所需要计算的方向（这里只能计算一个轴的方向（上下、左右））。它的计算判断应该是取 x y 轴的点，然后算与原点的角度。</li><li>投影块的距离：我们传递绝对值，这样不管是向左走（-1）还是向右走（1）都能为 1</li><li>需要检测的碰撞体所在图层：检测 Blocking 和 Actor 层</li></ol><p>当检测的投影块碰撞（collider）为空，则可以移动。代码如下</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">hit = Physics2D.BoxCast(</span><br><span class="line">    transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">    boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">    <span class="keyword">new</span> Vector2(<span class="number">0</span>, moveDelta.y), <span class="comment">// 方向计算其中一个方向 moveDelta.y</span></span><br><span class="line">    Mathf.Abs(moveDelta.y * Time.deltaTime), <span class="comment">// 检测距离为我们需要移动的距离</span></span><br><span class="line">    LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果检测到空的</span></span><br><span class="line"><span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让他动起来</span></span><br><span class="line">    <span class="comment">// 因为我们只检测 y 轴，所以我们要修改为 y 轴</span></span><br><span class="line">    transform.Translate(<span class="number">0</span>, moveDelta.y * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，我们也需要给 x 轴有同样的操作：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">hit = Physics2D.BoxCast(</span><br><span class="line">    transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">    boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">    <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">    <span class="keyword">new</span> Vector2(moveDelta.x, <span class="number">0</span>), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">    Mathf.Abs(moveDelta.x * Time.deltaTime), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">    LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果检测到空的</span></span><br><span class="line"><span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为检测 x 轴，所以我们要修改为 x 轴</span></span><br><span class="line">    transform.Translate(moveDelta.x * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的完整代码如下</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D boxCollider;</span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDelta;</span><br><span class="line">    <span class="keyword">private</span> RaycastHit2D hit; <span class="comment">// 用于碰撞检测</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxCollider = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> x = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> y = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">        moveDelta = <span class="keyword">new</span> Vector3(x, y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (moveDelta.x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = Vector3.one;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (moveDelta.x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放置一个方块来检测，确保我们能够朝这个方向移动。如果检测为空，则表示可以移动</span></span><br><span class="line">        hit = Physics2D.BoxCast(</span><br><span class="line">            transform.position, <span class="comment">// 角色的位置</span></span><br><span class="line">            boxCollider.size, <span class="comment">// 碰撞体的大小</span></span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">            <span class="keyword">new</span> Vector2(<span class="number">0</span>, moveDelta.y), <span class="comment">// 方向计算其中一个方向 moveDelta.y</span></span><br><span class="line">            Mathf.Abs(moveDelta.y * Time.deltaTime), <span class="comment">// 检测距离为我们需要移动的距离</span></span><br><span class="line">            LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>)); <span class="comment">// 需要检测的层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果检测到空的</span></span><br><span class="line">        <span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 让他动起来</span></span><br><span class="line">            <span class="comment">// 因为我们只检测 y 轴，所以我们要修改为 y 轴</span></span><br><span class="line">            transform.Translate(<span class="number">0</span>, moveDelta.y * Time.deltaTime, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        hit = Physics2D.BoxCast(</span><br><span class="line">            transform.position,</span><br><span class="line">            boxCollider.size,</span><br><span class="line">            <span class="number">0</span>, <span class="comment">// 角色不需要移动角度，所以为 0</span></span><br><span class="line">            <span class="keyword">new</span> Vector2(moveDelta.x, <span class="number">0</span>), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">            Mathf.Abs(moveDelta.x * Time.deltaTime), <span class="comment">// 这个是检测 x 轴的，所以需要改</span></span><br><span class="line">            LayerMask.GetMask(<span class="string">&quot;Actor&quot;</span>, <span class="string">&quot;Blocking&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hit.collider == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 因为我们检测 x 轴，所以我们要修改为 x 轴</span></span><br><span class="line">            transform.Translate(moveDelta.x * Time.deltaTime, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测的时候，我们发现玩家居然完全不能移动，怎么回事？</p><p>因为我们检测的是 Blocking 层和 Actor 层、玩家也在 Actor 层里，所以他就检测自己，觉得“自己和自己碰撞了”。那需要解决这个问题，我们需要打开项目设置：Unity 左上角 Edit / Project Settings 然后弹出的对话框中左侧选择 Physic 2D。在右侧的属性列表中找到 Queries Start in Colliders，取消勾选。</p><p><img src="/uploads/unity2020-rpg/20210808%20Physic2D%20Setting.png"/></p><p>设置结束后，运行游戏。可以发现玩家可以在地图上奔跑，然后遇到障碍物会停下了。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（3）角色移动</title>
      <link href="/2021/c64e943e.html"/>
      <url>/2021/c64e943e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如果你是跟着上一篇文章来的，那么你的屏幕上应该有两个角色，我们先把 player_0 (1) 删掉，直接点击 Delete 键即可。</p><p>现在，我要让角色动起来。从这里开始，我们就会涉及到编程了。</p><p>不会编程的小伙伴不用担心，我会把所有代码清晰的复制粘贴到这里来。你们只需要理解每一行代码，并且给代码写上注释就行。方便以后你复习项目的时候，可以清楚的知道当初自己写了什么。</p><p>回到我们的 Hierarchy 界面，我们选中 player_0。然后在 Inspector 界面点击下方的 Add Component 按钮，添加新的元件。Unity 已经为我们准备了一大堆的元件库，但是现在我们需要创建新的元件（代码）。所以我们需要在元件库搜索框里输入 Player。然后列表会弹出两个元件，直接无视它，点击 New Script，然后点击 Create and Add 按钮。</p><p>这时候你就会发现 Project 面板的 Asset 目录下出现了一个文件：Player；并且你的 player_0 的 Inspector 面板也会出现一个 Player 的元件。如果没有的话，将刚刚创建的 Player 文件拖曳到 player_0 的 Inspector 面板里。</p><p>另外，如果需要删除元件，在 Inspector 面板，右键你所需要删除的元件的名字，然后点击 Remove Component 即可。</p><p><img src="/uploads/unity2020-rpg/20210808%20Create%20Player%20Script.png"/></p><p>我们将这个 Player 文件拖曳到 Scripts 文件夹里。这时候 Script 文件夹的样式将会变成实心的。然后双击打开 Script 文件夹，让后双击打开 Player 文件。系统会选择默认的代码编辑器打开这个文件（通常是 Visual Studio 2019）</p><h2 id="修复-Unity-依赖"><a href="#修复-Unity-依赖" class="headerlink" title="修复 Unity 依赖"></a>修复 Unity 依赖</h2><p>双击点开之后，初始界面应该如下：</p><p><img src="/uploads/unity2020-rpg/20210808%20Player%20Script%20Default.png"/></p><p>注意看，上面的 MonoBehavior 是白色的字体，这说明他对于浏览器只是普通的文本。但是 MonoBehaviour 是 Unity 的库，这意味着我们的 Unity 源码没被 Visual Studio 关联。所以我们先关闭 Visual Studio，然后回到 Unity。</p><p>在 Unity 的右上角菜单里 选择：Edit / Preferences 这时候会弹出一个设置对话框，我们打开 External Tools 标签页，然后在 External Script Editor 的下拉框那里，选择 Visual Studio，然后自动的接下来的属性目录会改变。点击 Regenarate project files，等待 Unity 添加项目依赖就行。</p><p><img src="/uploads/unity2020-rpg/20210808%20External%20Editor%20Fix.png"/></p><p>接着再打开刚刚的 Player 源文件，这时就会发现 MonoBehaviour 由原先的白色变为绿色。</p><p><img src="/uploads/unity2020-rpg/20210808%20External%20Editor%20Fix%20Result.png"/></p><h2 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h2><p>我会一并将代码复制到最下方，这里来说 Unity 的编程技巧。一切从简，我们将原先 Unity 生成给我们的函数 Start 和 Update 删除。</p><p>移动角色，我们就需要让其检测碰撞，当碰撞到物体时，得让他停下。这里我们就要用到 Unity 的 BoxCollider2D 元件。因为我们开发的是 2D 游戏，所以选的空间后面都带有 2D 后缀（2D 和 3D 计算公式不一样，所以需要区分）。</p><p>然后我们写上 Start 函数（同时按下 CTRL + SHIFT + M 就能快速实现 Unity 的函数，在弹出的对话框中选择所需的函数，然后点击确定即可），Start 函数的调用时机是在这个游戏物件（Game Object）被创建之后。也就是说，当我们点击开始游戏，因为场景上有玩家的 Game Object 就会被调用一次。我们通常用 Start 函数来初始化对象，所以这里先用来初始化 刚刚定义的 boxCollider 成员变量。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D boxCollider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxCollider = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，我们需要给玩家设置一个 BoxCollider2D 元件。回到刚刚创建代码文件的步骤，在 Add Component 搜索框里搜索 BoxCollider2D 然后点击它。</p><p>接下来，我们回到 Scene 面板，这时候会发现角色周围多出了一个绿色的框，这就是我们的碰撞侦测盒子。我们可以点击 Inspector 面板里 BoxCollider2D 元件中的 Edit Collider 按钮，然后鼠标点击 Scene 面板中的绿色小方块进行微调。</p><p>我的调整参数为：Offset X: 0, Y: -0.01，Size X: 0.1, Y: 0.1</p><p><img src="/uploads/unity2020-rpg/20210808%20Player%20Collider.png"/></p><p>接着，回到 Visual Studio，我们通过上面创建 Start 函数一样的方法，增加一个 FixedUpdate 函数，该函数调用时机是每隔一个固定的帧进行刷新（比如一秒60帧，他就在每个 60 秒的第一帧调用一次）</p><p>FixedUpdate 函数通常用来修改有关物理操作。但是不建议将获取按键写在这里，因为他只是在某个固定的帧数调用，所以有一定的概率不会捕获到你所按下的键位影响用户体验。但是目前我们需要控制物理动作，所以用 FixedUpdate 函数。</p><p>在 FixedUpdate 函数里，我们需要接收用户输入。更改角色朝向，修改角色位置（移动）</p><p>要让他移动，我们就需要一个 3D 的方向变化（Unity 是一个 3D 游戏引擎，只是 2D 少了一个维度，在平面上移动）。我们定义一个 Vector3 类型的变量 moveDelta。然后在每个固定帧（Fixed Update）调用 Input.GetAxisRaw() 函数分别获得横轴和纵轴点击值。</p><p>GetAxisRaw 的参数字符串怎么决定？我们回到 Unity，右上角菜单点击 Edit / Project Setting，打开对话框，在对话框左侧列表选择 Input Manager，在右侧界面展开 Axes，然后选择对应的轴（这里有一大堆，我们先看 Horizontal 和 Vertical）。GetAxisRaw 的参数就是对应所需的 Name。</p><p><img src="/uploads/unity2020-rpg/20210808%20Input%20Manager.png"/></p><p>至于怎么决定按下的键位？是这么一回事，我们看上面的图，Name 决定我们怎么去明明这个轴（操作），这里 Horizontal 理解为横向移动。那么横向移动就肯定需要两个按钮嘛（左右键）然后我们还可以通过 a 和 d 键进行移动，那我们就需要设置一正一负（负 -1，正 1）的键位名，负（Negative Button）是 left 而正（Postitve Button）则是 right。那么 a 和 d 键我们就设置在替代按钮（Alt Xxx Button）其他的暂不解释。</p><p>所以 GetAxisRaw() 函数的工作原理：当玩家点击a，系统收到的就是 -1 的值，d 则是 1 的值。没有按下任何键位就是 0</p><p>我们分别将两个不同的轴保存在 x 和 y 两个不同的变量里。然后将其传递到 moveDelta 变量里。这里需要 new Vector3()，然后将我们获取到的 x 和 y 值传递进去。然后 3D 包括了 xyz 三个值，所以在平面中，z = 0。</p><p>接下来，我们需要知道玩家什么时候需要反面。也就是当玩家的横轴被切换之后，就需要根据它所移动的方向来切换。我们通过获取 moveDelta.x 来获取玩家横向移动的值，当他大于0，则朝向右边，小于0则朝向左边。</p><p>最后我们需要让角色动起来。完整代码如下：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider2D boxCollider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDelta;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        boxCollider = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取用户输入（左右上下）</span></span><br><span class="line">        <span class="built_in">float</span> x = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        <span class="built_in">float</span> y = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 moveDelta 重置</span></span><br><span class="line">        moveDelta = <span class="keyword">new</span> Vector3(x, y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据行走的方向，切换行走图的朝向</span></span><br><span class="line">        <span class="keyword">if</span> (moveDelta.x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = Vector3.one; <span class="comment">// 节省资源，所以使用 Vector3 的静态变量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (moveDelta.x &lt; <span class="number">0</span>) <span class="comment">// 为了避免放开键位之后，moveDelta.x = 0 而导致角色回归原本的朝向</span></span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让他动起来</span></span><br><span class="line">        transform.Translate(moveDelta * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们回到 Unity，等待编译。点击上方的播放按钮 ▶。等待游戏开始，点击 wasd 和上下左右键即可操作角色移动。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（2）相机设置</title>
      <link href="/2021/1eb38b5f.html"/>
      <url>/2021/1eb38b5f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>上一篇文章，我们说了怎么导入图片素材。接下来，我们点开我们导入的图片旁边那个小箭头，会看见两个我们切割出来的图片，我们选中 player_0，拖拽到 Hierarchy 面板里，这会使其出现在我们游戏场景的中央。或者你也可以拖曳到 Scene 面板里，随意把它扔到一个位置。这边我们直接放在 Hierarchy 面板。</p><p>完成这个步骤后，注意看 Inspector 面板的 Transform 元件（Component）的 Position 是不是都为 0（居中）。</p><p>拖进去之后，你会发现 Scene 面板里好像什么都没有。这是因为我们的素材太小了，只有 16 个像素。我们可以通过鼠标滚轮在 Scene 面板里进行缩放，然后通过鼠标中键移动位置。</p><p><img src="/uploads/unity2020-rpg/20210808%20Place%20Character.png"/></p><p>接下来我们打开 Game 面板（ctrl + 2），会发现中间的人物超级无敌小！要调整这个呢，首先我们需要修改我们的目标界面分辨率。在 Game 面板的上方，有个 Free Aspect 下拉框。这个意思是你的游戏界面会随着你的窗口大小自适应。点开下拉框，我们可以选择 16:9 分辨率等。但是我们的游戏像素单位是 16px，所以我们将其改为 800 × 600 分辨率即可。</p><p>我们点开下拉框，选择 ＋ 号，然后创建新的分辨率。Label 可以随意命名、宽高分别设置为 800 和 600。</p><p><img src="/uploads/unity2020-rpg/20210808%20Camera%20Resolution.png"/></p><p>是的，它还是很小。因为我们只是修改了游戏分辨率，根据现实，我们需要修改镜头机位才能改变他的大小。所以我们点开 Hierarchy 面板的 Main Camera，然后找到 Camera 元件，将其 Projection 属性调整为 Orthographic，2D 游戏不需要透视。然后将其 Size 修改为 1。</p><p><img src="/uploads/unity2020-rpg/20210808%20Camera%20Properties.png.png"/></p><p>现在，角色已经肉眼可见了。接下来，给大家展示个概念，我们先在 Hierarchy 面板选中 player_0 然后复制粘贴一份。再修改新的 player_0 (1) 的 position 属性，y 轴设置为 0.16，其余不变。然后我们发现新角色叠在了原角色的头顶上。</p><p>这是因为在素材导入的时候，我们设置的 Pixel Per Unit（PPU）为 100（点开 Project 面板里的 Atlas 文件，然后观察 Inspector 面板）的 Pixel Per Unit 属性。这意味着，每个单位（1, 2, 3）都有 100 像素点。但是我们的角色图只有 16px，所以就 16 / 100 = 0.16</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPG 游戏开发（1）导入图片素材</title>
      <link href="/2021/dd08b928.html"/>
      <url>/2021/dd08b928.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>第一次做游戏教学文章，不知道大家会不会喜欢。在这里，我们用 Unity 2020.3.15f2 版本作为开发工具。</p><p>首先，在游戏目录里创建4个文件夹：</p><ol><li>Artwork 图片素材<ol><li>Animation</li><li>Levels</li></ol></li><li>Prefab 预制件</li><li>Scenes 默认会被创建，保存游戏场景（舞台）</li><li>Scripts 代码</li></ol><p><img src="/uploads/unity2020-rpg/0x72_16x16DungeonTileset.v4.png" alt=""></p><p>我们用以下素材进行演示，这个素材是由 0x72 设计的 16 × 16 像素图集。原链接在<a href="https://0x72.itch.io/16x16-dungeon-tileset?download" title="https://0x72.itch.io/16x16-dungeon-tileset?download">这里</a>，作者将此素材免费分享。喜欢的可以打赏支持创作。</p><p>我们将这个图片直接拖到 Unity 项目里的 Artwork 文件夹里。</p><p>这个图片包含了：</p><ol><li>场景（地图路块）</li><li>武器</li><li>怪物</li><li>角色</li><li>动态火炬</li></ol><p>我可能会另外做一些像素图标，但是目前学习情况下用这个足够了。</p><p>我们将图集文件名改为 Atlas：选中图集，然后点击 F2 或右键点击 Rename 即可重命名。当你选中之后，会看见右侧 Inspector 面板里出现该文件的设定（如下图）。我们将其属性修改为跟下图一样。</p><p><img src="/uploads/unity2020-rpg/20210808%20Atlas%20Properties.png"/></p><ol><li>Texture Type 决定这张图片是什么类型，我们选的是 Sprite 精灵图。</li><li>Sprite Mode = Multiple。这个意思是我们给出的文件是一个图集（有多个元素在里边）所以用 Multiple（多个）。这样我们就可以把这个图集分割成各个元素。</li><li>Filter Mode = Point。这是个像素图，不需要像位图一样每个像素点间有过度。如果选的是 Bilinear，那么图像将会是模糊的。</li></ol><p>修改完毕之后，点击 Apply。然后再点击 Sprite Editor，Unity 会弹出一个对话框，我们需要对像素图进行切割。</p><p>从 Atlas 图集中，右下角 12 个角色中选出两个你喜欢的角色，然后按住鼠标左键将它们分别框起来。</p><p><img src="/uploads/unity2020-rpg/20210808%20Atlas%20Cut%20Player%200.png"/><br><img src="/uploads/unity2020-rpg/20210808%20Atlas%20Cut%20Player%201.png"/></p><ol><li>鼠标滚轮用于缩放</li><li>长按鼠标中键并拖曳可以移动图片</li><li>长按鼠标左键并拉出框框用于切割图标，选择之后可以通过周围几个节点对选取范围进行调整。</li><li>在已有的选取框外长按鼠标左键并拖拽，可以切割下一个图标。</li><li>下方的属性面板可以让你清楚的了解你所选中的信息（里面的属性值可以被修改）这里不做一一介绍。主要需要注意：我们选的是 16 × 16 的像素图，所以选中的时候也按照比例调整宽高（W H）值</li><li>当两个角色都被框选中之后，点击上方的 Apply 即可。然后关闭 Sprite Editor 对话框</li><li>这时候你就会发现 Atlas 文件出现了个小箭头，点击箭头会出现刚刚所选中的两个图片。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> C-Sharp </category>
          
          <category> Unity 2020 开发地牢探险类游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity 游戏开发 </tag>
            
            <tag> RPG 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是数字签名</title>
      <link href="/2021/a1fc949f.html"/>
      <url>/2021/a1fc949f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <a href="/2021/52267ce2.html" title="比特币的原理">比特币的原理</a> 的文章里，我提到了数字签名这项技术。那这个数字签名是什么东西呢？它怎么去执行加密的？</p><h2 id="生日碰撞"><a href="#生日碰撞" class="headerlink" title="生日碰撞"></a>生日碰撞</h2><p>在讨论数字签名前，先来了解生日碰撞的概念。<strong>以下涉及概率论，我会尽量说的简单点</strong>。</p><p>问题：一个班级有50个学生，至少两个学生生日在同一天的概率是多少？可能很多人都会觉得，一年 365 天，这概率很低。但是真的是这样吗？举个实例：中学的时候，我班和我同一天生日的就有三个人。</p><p>那么这个概率怎么算呢？</p><p>首先，我定义 P = 所有人的生日不在同一天的概率，那么 1 - P = 至少两个人生日在同一天的概率。<br>如果全班只有 1 个人， P = 100%，因为 P = 365 / 365，一年有 365 天，他可以任选一天。<br>全班有两个人，那么 P = (365 / 365) × (364 / 365) ，第一个人任选一天后，第二个人只能从 365 天里的 364 天选其中一天。<br>以此类推，当全班有 n 个人，Pn = (365 × 364 × … × (365 - n + 1) ) / 365 n</p><p>当全班有 10 个人，则 P10 = 88.1%，也就是 88.3% 的概率全班不在同一天生日。而 1 - P = 11.7% 也就是 11.7% 的概率至少两个同学同一天生日。</p><p>当全班有 20 个人，则 P20 = 48.8% 而 1 - P = 51.2%。</p><p>而全班有 50 个人，则全班不在同一天生日的概率 P50 = 2.9% 反之 1 - P = 97.1%。</p><hr><p><strong>数字签名不是一种加密，和我们现实生活中的签名是一样的。</strong>在 <a href="/2021/e726410.html" title="比特币的安全">比特币的安全</a> 我们在讨论比特币安全性质的时候说到，电脑因为能轻易的保存并复制我们传统的身份认证（人脸、签名、指纹）。所以需要给数据加上一个电脑无法复制的电子签名。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>这里就用到了一项技术——哈希函数。它可以给某个字符串（数据）经过计算之后，变为一个有限长度的新的字符串。我们将它生成出来的值称为摘要（digest）或散列值（hash values）。这个摘要就相当于数据的指纹。</p><p>举个栗子：<br>我将 123 经过哈希函数计算之后，得出一个 3 位的结果 abc；<br>而我将 4abd5 通过哈希函数计算之后，也能得出一个 3 位的结果 efg。<br>你给我一个长度为 10G 的电影，最后也得出一个 3 位的结果</p><p>而这个哈希函数具有不可逆（无法从摘要逆向演算回初值）的性质，所以可以用来加密密码。</p><p>所以我们知道了哈希函数的两个特点：</p><ol><li>单向的——你给我摘要 ，问我源数据是什么，我不知道。</li><li>位数固定——不论多长的数据，经过哈希函数之后都会变成一个和其他数据一样长的结果。具体生成长度，取决于你所使用的哈希函数的类型。</li></ol><p>因为最终生成结果是固定的，所以有可能会出现<strong>两个不同的数据最终得出同样结果</strong>的情况，这个情况称之为<strong>生日碰撞</strong>。而出现<strong>生日碰撞</strong>就达不到数字签名的要求了。<strong>因为签名是必须独一无二的</strong>。所以只能修改哈希函数的算法来降低生日碰撞。</p><p>经过计算，如果你的哈希值有 N 个，那么生日碰撞概率大于 50% 只需要 1.2 × √n 就行了。</p><ol><li>如果哈希值有 100 种可能，那么出现生日碰撞大于 50% 的概率所需的原项只需要 12 个。</li><li>如果有 10000 种可能，则只需要 120 个原项。</li></ol><h2 id="数字签名的过程"><a href="#数字签名的过程" class="headerlink" title="数字签名的过程"></a>数字签名的过程</h2><p>签名的目的是<strong>让别人知道这个信息是你发出来的</strong>。我们用非对称加密进行解释。</p><ol><li>A 要给 B 发送一组数据。他要先把这组数据进行加密<ol><li>加密方法是公开的，谁都能加密</li><li>只有 B 知道怎么解密。</li></ol></li><li>然后 A 还需要把这组数据进行哈希运算之后，再通过私钥加密。使其成为数字签名。<ol><li>钥匙分了两把：私钥是 A 自己的钥匙，A 自己保存好，任何人都不知道，用于加密的。</li><li>公钥是 A 公开给所有人的钥匙，用于解密由 A 加密的密文。</li></ol></li><li>A 把加密后的数据连同数字签名一并发给 B</li><li>B 将加密后的数据进行哈希运算后，得到哈希值。再通过公钥解密，得到 A 加密的哈希值。</li><li>最后 B 比较两组哈希值，如果两组哈希值能对上，那么表示数据由 A 发出来，并且中途未被篡改。</li></ol><p><img src="/uploads/Digital%20Signature.png" alt="数字签名示意图"/></p><p>为什么？</p><ol><li>因为只有 A 有私钥，所以别人就算写了其他数据并且加密，也无法获得 A 的私钥进行加密。</li><li>就算有个坏蛋 C 也对数据进行加密发送过去，但是他所用的私钥无法被 A 的公钥解密，或者说解密后的哈希值不匹配。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">https://zh.wikipedia.org/wiki/散列函數</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字签名 (Digital Signature) </tag>
            
            <tag> 生日碰撞 (Birthday Collision) </tag>
            
            <tag> 哈希函数 (Hash Function) </tag>
            
            <tag> 非对称加密 (Asymmetric Encryption) </tag>
            
            <tag> 公钥私钥 (Public Key/Private Key) </tag>
            
            <tag> 加密技术 (Encryption Techniques) </tag>
            
            <tag> 信息安全 (Information Security) </tag>
            
            <tag> 数据完整性 (Data Integrity) </tag>
            
            <tag> 比特币技术 (Bitcoin Technology) </tag>
            
            <tag> 散列函数 (Hashing Algorithms) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币的安全</title>
      <link href="/2021/e726410.html"/>
      <url>/2021/e726410.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>哈喽大家好！我是小麦。继上一篇文章，我总结了比特币的原理。那么这篇文章就会对比特币的安全问题进行研究，探讨比特币在所有记录是公开而且匿名的情况下怎么保证数据的安全。</p><p>在文章开始前，可以点击菜单的登录按钮，注册我们的官网账号。未来会有很多福利回馈给各位读者！谢谢各位支持！</p><p>哦对了！还有参考视频：</p><ol><li>李永乐老师的Youtube：<a href="https://www.youtube.com/watch?v=pbAVauYsqP0">https://www.youtube.com/watch?v=pbAVauYsqP0</a></li><li>李永乐老师的BiliBili：<a href="https://www.bilibili.com/video/BV12b411q7ku">https://www.bilibili.com/video/BV12b411q7ku</a></li></ol><h2 id="传统的身份认证"><a href="#传统的身份认证" class="headerlink" title="传统的身份认证"></a>传统的身份认证</h2><p>我们在现实社会里用的身份认证有人脸识别、签名、指纹。这些是银行或者电子钱包证明“你是你”的手段。那在虚拟世界里，传统签名是不能被使用的。因为人脸、签名、指纹都能被电脑所储存并复制，是不安全的。</p><p><img src="/uploads/Traditional Security.png" alt="传统加密手段"/></p><h2 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h2><p>比特币的用户在注册的时候，系统会生成一个随机数。通过随机数，产生私钥（Private Key）；再通过私钥产生公钥（Public Key）和地址（Address）。其中，每个钥匙的重要性是不同的。私钥是保密的，就相当于你的密码，他是必须保密的，而且一旦私钥丢了（忘记了），那你的比特币就丢了。而公钥和地址是公开的。</p><p>当你要别人给你钱的时候，你只要知道他的地址；当你要给别人钱的时候，你需要发送你的公钥和地址给他。你不用担心私钥被泄露等问题。因为通过公钥是反算不回私钥的。</p><p>私钥和公钥的作用在于，私钥可以把一段字符串进行加密；而公钥则是把加密之后的数据进行解密。加密和解密的方法钥匙不一样，这种方法称之为<strong>非对称加密（</strong>Asymmetric cryptography<strong>）</strong>。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><img src="/uploads/ESign Step 1.gif"/></p><p>假如 A 需要付款给 B 10 个比特币，那么 A 就需要先制作一个记录，说明 A → 10BTC → B；然后通过 SHA256 算法将这段信息算出数字摘要。然后摘要再通过私钥进行加密，产生密码。</p><p><img src="/uploads/ESign Step 2.gif"/></p><p>然后 A 对全网进行广播，广播内容为 A → 10BTC → B ，公钥和密码。</p><p><img src="/uploads/ESign Step 3.gif"/></p><p>当公众收到 A 的广播之后，先对 A → 10BTC → B 这个信息进行哈希运算，得出摘要。然后使用公钥和密码进行解密（上面说了，私钥进行加密，公钥可以解密），得出摘要。然后将两个摘要进行对比，如果两个摘要相等，说明密码是符合要求的。解释：因为你有唯一的私钥，私钥加密摘要之后产生密码。</p><p>当满足这些条件后，交易才算成立。</p><hr><p>假设 A 只有 10 个比特币，那么他几乎同时转账给 B 和 C 10 个比特币，那怎么去解决这个问题呢？</p><h2 id="余额检查"><a href="#余额检查" class="headerlink" title="余额检查"></a>余额检查</h2><p>首先要知道比特币是怎么查询余额的。区块链是将很多的信息一块一块打包之后再串起来。每个人在使用比特币的时候，都需要下载整个区块链的数据（从比特币第一个块开始，一直到最新的块都需要下载）。所以当 A 准备支付 10BTC 给 B 时，他将信息广播出去后，收到这个信息的人会检查 A 是否在区块链的记录里有没有这笔余额。我们上一篇文章说到<strong>区块链保存的是从比特币创世纪开始一直到最新的账单信息</strong>，所以每一笔账目的来龙去脉都清清楚楚。</p><p><img src="/uploads/BlockChain.gif" alt="区块链示意图"/></p><p>当检查 A 的余额充足时，本次交易成立；反之失败。</p><p>支付信息被确认的前提是：<strong>别人接受你的交易信息（余额足够），且打包连接上区块链</strong>。否则就算你发出广播，这笔交易依然没有作用。</p><h2 id="对付双重支付"><a href="#对付双重支付" class="headerlink" title="对付双重支付"></a>对付双重支付</h2><p>当 A 只有 10BTC 却执行两个 10BTC 的交易给不同的人时，他会发送两个广播，一个是 A → B，另一个是 A → C。那么根据网络延迟等因素，其余用户在接到这两条广播的时间是不一样的。有的人先得到 B 的交易信息、有的人却得到 C 的交易信息。</p><p>这时候两伙人都会对这两个账单进行处理，不论是先付给 B 或 C 的交易，第一笔交易的余额检查肯定是通关的。而第二笔就不被接受。那么怎么取决谁的交易记录是正确的呢？就是当两伙人中的其中一个人（假设这个人是处理 C 交易的）做好数学题，打包了区块并连接起来，那么当其他人见区块链已经被更新之后，他们就会放弃自己的块，接着最新的块进行计算。自然的，B 交易就被丢弃了。</p><p>说仔细一点就是：当区块被连上 C 交易成立，这时候 A 的余额就为 0 了。那么就算 A → B 的这笔交易被带到下一个区块去，他也会因为余额不足而无法被通过。</p><p>所以当有人用比特币给我们付款的时候，我们不能当时就认为钱已经到账了。我们得等到<strong>下一个区块被创建</strong>这个事情才算是事实。</p><h2 id="防篡改"><a href="#防篡改" class="headerlink" title="防篡改"></a>防篡改</h2><p>比特币不可能伪造别人的记录。因为电子签名是绝对安全的（只要你不泄露自己的私钥）。但是可以删除某一条记录。比如 A 给 B 10BTC，然后 A 删掉了这个记录，这项交易就算取消。那怎么去防止这件事情的发生？</p><p>比特币有个原则叫<strong>最长链原则</strong>，意思就是当最新的区块链有两个区块被同时链接上去。那么其他矿工这时候会产生两拨人。一拨是先看到 A 区块的，另一拨是先看到 B 区块的。那这两拨人都会以自己接收到的第一个新区块为准，继续往下算。那么当某个矿工找到下一个新的块（比如 A 区块的那个矿工），那么他就会把新的区块连接上 A 链。这个时候 A 链就会成为最长链。那么其他矿工看到这条最长链，就会自然的舍弃短的 B 链，然后继续去接上 A 链。那么 B 链所链接上去的 B 块就算失败了。</p><p>一般情况下，其中一条链产出 6 个以内的区块就会分出胜负，那么另外一条链上的交易将会被撤回，重新放回交易池等待打包。</p><p>那么如果有人执意要继续算 B 链呢？也可以。但是全网的基本原则是最长链原则，所以绝大部分的矿工都会找最长的链继续接下去。那么你自己一个人挖是不可能对抗的了全网的算力的。</p><h2 id="51攻击"><a href="#51攻击" class="headerlink" title="51攻击"></a>51攻击</h2><p>为了防止账本（区块链）被篡改，每个新加入的区块必须在区块头上写上上一个区块的哈希值，称为哈希指针（Hash Pointer）。因为只要改变任何一个区块的其中一个字符，都会影响他的哈希值，进而使新的区块断开连接。那就必须修改下一区块的随机值才能连上，一直修改到最新的区块。这是不可能完成的。</p><p>既然有了最长链原则，那么当一个人的电脑性能（算力）大于 51% 他就能算出最长链，控制账本。所以比特币的矿工算力越强，所需要算出的 0 就越多以保证谁都不能控制记账权。</p><p>在用户基数不多的虚拟货币系统就容易遭到 51% 攻击。比如比特黄金 Bitcoin Gold，在 2018 年 5 月 18 日就遭过一次。攻击者先吧自己价值 1000万 的比特黄金转给交易所。这笔转账被记录在区块 A 上，同时交易者秘密准备了没有发生此交易的区块 B 并继续计算后续的区块。等 A 链上的交易被确定之后，攻击者就可以把在交易所的比特黄金提现。</p><p>但是攻击者的算力大于 51% B 链的长度始终大于 A 链，这时只要向全网发布更长的 B 链，B 链将会取代 A 链，而区块 A 里的交易转账也会被撤回。攻击者白赚 1000 万。</p><h2 id="为什么比特币不怕-51-攻击"><a href="#为什么比特币不怕-51-攻击" class="headerlink" title="为什么比特币不怕 51% 攻击"></a>为什么比特币不怕 51% 攻击</h2><p>当你是一个有钱人，你能拥有世界上 51% 的电脑的时候。你压根就不会去通过这种方式就为了抹掉自己的一条记录。他只会在主链上继续去挖更多的块，赚取更多的钱。</p><p>那本期有关比特币的分享到这里结束，接下来我也准备了几个主题进行研究。喜欢这篇文章的朋友可以把文章分享出去。也可以加入我们的 Discord 服务器进行更多交流。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子签名 (Digital Signature) </tag>
            
            <tag> 非对称加密 (Asymmetric Cryptography) </tag>
            
            <tag> 余额检查 (Balance Verification) </tag>
            
            <tag> 最长链原则 (Longest Chain Rule) </tag>
            
            <tag> 双重支付 (Double Spending) </tag>
            
            <tag> 防篡改 (Tamper Resistance) </tag>
            
            <tag> 51% 攻击 (51% Attack) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币的原理</title>
      <link href="/2021/52267ce2.html"/>
      <url>/2021/52267ce2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>哈喽大家好！我是小麦。最近想装一台电脑，然后看了眼显卡价格……嗯，还是很高。想到了导致今天这个局面的“罪魁祸首”——加密货币。今天看了李永乐老师两年前讲解比特币原理的视频，现在来做个笔记。</p><p>老规矩，视频链接：</p><ol><li>李永乐老师Youtube：<a href="https://www.youtube.com/watch?v=g_fSistU3MQ">https://www.youtube.com/watch?v=g_fSistU3MQ</a></li><li>李永乐老师BiliBili：<a href="https://www.bilibili.com/video/av45247943">https://www.bilibili.com/video/av45247943</a></li><li>老高与小茉比特币：<a href="https://www.youtube.com/watch?v=7B-1vDFuYRk">https://www.youtube.com/watch?v=7B-1vDFuYRk</a></li><li>老高与小茉区块链：<a href="https://www.youtube.com/watch?v=sjx_rpay9rk">https://www.youtube.com/watch?v=sjx_rpay9rk</a></li></ol><p>以下文章可能有点深奥，读者可以在文章下方讨论，我会尝试给你们解答。</p><h2 id="比特币是什么"><a href="#比特币是什么" class="headerlink" title="比特币是什么"></a>比特币是什么</h2><p>比特币也叫电子货币、数字货币，它由一名化名为中本聪的网络极客于2008年11月1日在网络上写的一篇文章《比特币：一种点对点的电子现金系统》所提出。这篇文这里提出一种构思：<strong>去中心化</strong>的电子<strong>记账</strong>系统。</p><p><img src="/uploads/BitCoin%2016.png"/></p><h3 id="去中心化的电子记账系统"><a href="#去中心化的电子记账系统" class="headerlink" title="去中心化的电子记账系统"></a>去中心化的电子记账系统</h3><p>我们在和别人进行交易之后，需要检查我还有多少余额，这就是记账。目前我们的记账包括使用电子钱包都是由银行来记账。 银行就是这套记账系统的中心，我们信任银行，因为银行的背后是国家的信用。</p><p>而比特币是去中心化的记账系统。</p><h2 id="怎么去中心化"><a href="#怎么去中心化" class="headerlink" title="怎么去中心化"></a>怎么去中心化</h2><p>去掉银行、微信支付宝这些可信任的第三方之后，最大的问题是我们无法互相信任。中本聪提到的概念是：将所有人的账本都公开给别人看。在区块链的世界，转账就得发广播，目的就是让所有人都知道网络里每个人每一笔钱的来龙去脉。</p><p>当 A 和 B 进行交易，A 需要把交易信息和电子签名告诉所有这个系统下的用户（广播）。大家会通过电子签名验证这句话的确是 A 说的，再将这笔帐记载账本上。</p><p>那么大家怎么知道 A 有这笔钱呢？A 的账本帮忙确认，而这个账本就叫做区块。</p><h2 id="区块链-BlockChain"><a href="#区块链-BlockChain" class="headerlink" title="区块链 BlockChain"></a>区块链 BlockChain</h2><p>比特币的底层技术就是区块链。</p><p>这些由不同人发出的账单需要打包成一个块，称之为区块。一个区块的大小大概是1Mb，大约能储存4000条交易信息，取决于每条信息长度。</p><p>这个区块要和以前的区块（从比特币诞生的第一个区块一直到上一个区块）连在一起，再把新的区块往后接，这就叫做区块链。</p><p>区块链记录了比特币从创立到今天每一笔交易记录，所有人的钱从哪来到哪去都记得一清二楚、透明公开。</p><p><img src="/uploads/BlockChain.gif" alt="区块链示意图"/></p><h2 id="遇到几个问题"><a href="#遇到几个问题" class="headerlink" title="遇到几个问题"></a>遇到几个问题</h2><p>有了系统之后，我们需要思考几个问题：以谁为准？为什么别人愿意帮你记账？怎么防伪、篡改？怎么防止双重支付？怎么保密？</p><h3 id="记账的动力"><a href="#记账的动力" class="headerlink" title="记账的动力"></a>记账的动力</h3><p>为什么别人愿意消耗自己的电脑资源去记录和他自己无关的账单？为了让所有人有动力去做题记账，比特币有个奖励系统：</p><ol><li>手续费。每个人在进行交易的时候都需要多付一点比特币，多付的钱就作为记账的手续费。这和平时我们用银行卡、信用卡的手续费是一样的。甚至银行卡的手续费来的更高。</li><li>打包奖励。中本聪提出一个方案：从比特币创建之初，每过 10 分钟需要打包一个区块，每个区块奖励 50 比特币（只有其中一个用户有权利打包），然后每隔四年，奖励减半。</li></ol><p>根据打包奖励，我们可以算出总共有多少个比特币：</p><p>一个包50比特币，<br>一个小时6个10分钟，<br>每天24小时，<br>每年365天，<br>奖励减半周期为4年。</p><p>50 × 6 × 24 × 365 × 4 × ( 1 + ½ + ½2 + ½3 + …) = 2100万</p><h3 id="以谁为准"><a href="#以谁为准" class="headerlink" title="以谁为准"></a>以谁为准</h3><p>每个人都想要这笔奖励，所有每个人都抢着去打包。每个区块里的包含的交易和交易顺序都会不同，如果有记假账的那就更混乱了。所以，记账者必须让所有人都能接受，这样大家的账本才能统一，这也被称为共识机制（Consensus mechanism）。中本聪的办法是“工作量证明（Proof of Work）“，它的本质是穷举。每个人都需要去做一个很难的数学题。这个很难的数学题是没人可以用脑子计算出来的，必须一个一个数去尝试，才能试出结果。这个过程称之为：挖矿。</p><p>如果有人把这个数学题做出来了，那就可以获得打包奖励。</p><h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>那么这道数学题是怎样的数学题呢？这里提到一个算法——哈希函数。我会另外写一篇文章研究这个。哈希函数主要是把一个字符串（数据）运算之后转换成摘要的形式。而且正向算很容易，反向推导却很难（几乎不可能）。</p><p>其中一个很著名的算法叫 SHA256，是美国国家安全局发明的一种算法。具体就是将数据经过算法之后变为一个独一无二的 256 位二进制数。不管你的数据长度多少，最后生成出来的二进制数一定是 256 位，而原输入只要有一点轻微改动，也会导致每一位数值产生变化。</p><p>挖矿就是基于 SHA256 的运算。我们需要对一个字符串进行两次 SHA256 计算。</p><p>打开一个区块（通常是个JSON文件）可以看到里面包含了：</p><ol><li>头部信息（区块头）</li><li>交易数量 Number of transactions</li><li>交易详情 Transaction details</li></ol><p><img src="/uploads/BlockChain.gif" alt="区块链示意图"/></p><p>区块头是区块的标签，里面包含：</p><ol><li>时间戳<br>该区块产生的近似时间，精确到秒的UNIX时间戳，必须严格大于前11个区块时间的中值，同时全节点也会拒绝那些超出自己 2 个小时时间戳的区块</li><li>Merkle根<br>该区块中，交易的Merkle树根的哈希值（同样采用两次 SHA256 进行计算）</li><li>随机数<br>为了找到<strong>满足目标所设定的随机数</strong></li><li>上一个区块的哈希值。</li></ol><p>在这里，我们把区块头理解为字符串。</p><h3 id="记账以及计算难度"><a href="#记账以及计算难度" class="headerlink" title="记账以及计算难度"></a>记账以及计算难度</h3><p>想要记账（将我们的区块链接上去），我们需要把字符串执行哈希加密，并且加密结果（也就是 256 位二进制数）的前面几位数必须为零（取决于当前设置难度）。那么字符串是不能改的，因为里面包含了所有的区块信息，唯一能改的是区块头里的随机数。</p><p>二进制只有两种可能 0 或 1，所以进行一次哈希加密的成功率等于 2 的 n 次方分之一。而这个 n 就是所需要的（前几位）0，取决于当前参与计算的算力，算力越强，要算的 0 越多 PoW 的证明难度也就越大。</p><p>当然，每个人的打包难度都是不一样的，影响因素有：交易信息、时间戳、个人信息。所以照成随机数大小不同（前面说了随机数只能通过穷举的方式进行计算）。有的人运气好，第一个数就算出来了，有的人需要多算很多次。平均来说的话，就是<strong>谁的计算能力好，谁就更有希望打包这个块</strong>。</p><p>中本聪在设计的时候，保证<strong>每十分钟出一个块</strong>，所以需要改变 n 的难度，才能达成这个目标。这里我们做个数学题</p><ul><li>假设世界上有 10000 台矿机，每台矿机的计算量大概是 14T Hash/s，每秒计算 14T（T 是 1012） 所以是 1.4 × 1013</li><li>十分钟总共能计算： 1.4 × 1013 次 × 104 台 × 600 秒 = 8 × 1019 次。</li><li>概率是 1/2n 所以需要出一个块，平均计算的次数是 2n</li><li>通过计算，n = 66，所以概率 P = 1/266 。平均计算的次数是 266 大概等于 8 × 1019 次。</li></ul><p>那我们这里讲了比特币的底层架构（区块链）以及挖矿是什么东西。下一篇我们来研究比特币的安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希函数 (Hash Function) </tag>
            
            <tag> 比特币 (Bitcoin) </tag>
            
            <tag> 去中心化 (Decentralization) </tag>
            
            <tag> 区块链 (Blockchain) </tag>
            
            <tag> 工作量证明 (Proof of Work) </tag>
            
            <tag> 挖矿 (Mining) </tag>
            
            <tag> 共识机制 (Consensus Mechanism) </tag>
            
            <tag> SHA256算法 (SHA256 Algorithm) </tag>
            
            <tag> 加密货币原理 (Cryptocurrency Principles) </tag>
            
            <tag> 数字货币 (Digital Currency) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日记加密思路总结</title>
      <link href="/2021/fd9b7188.html"/>
      <url>/2021/fd9b7188.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="日记加密的思路总结"><a href="#日记加密的思路总结" class="headerlink" title="日记加密的思路总结"></a>日记加密的思路总结</h1><p>哈喽大家好，这是我们的第一篇文章。喜欢这类文章的小伙伴可以<a href="http://tootaio.com/wp-login.php?action=register">点击这里</a>注册我们官网的账号，一起讨论哦！ 也期待你们<a href="https://discord.gg/sJcv7ZM">加入我们的Discord服务器</a>一起聊天！</p><p>刚刚看了一下李永乐老师的日记加密算法，现在对视频所介绍的思路进行回忆并做总结。什么？你问视频链接在哪里？Okay，在这里：</p><ol><li>Youtube链接：<a href="https://youtu.be/32xToL3JdU0">https://youtu.be/32xToL3JdU0</a></li><li>BiliBili链接：<a href="https://www.bilibili.com/video/BV11X4y1w77c">https://www.bilibili.com/video/BV11X4y1w77c</a></li></ol><p>这篇文章不会涉及代码实现，纯粹讨论思路。后面我会在 Coding Challenge 里面尝试去吧这个加密功能写出来。所以现在我会根据老师所说，用我们生活中能用到的工具（白纸、美工刀）去演示这个加密过程。</p><hr><h2 id="制作密码盘"><a href="#制作密码盘" class="headerlink" title="制作密码盘"></a>制作密码盘</h2><p>现在来简单的用图文叙述加密及解密过程。首先，我们准备一张白纸，在纸上划分四个区域，然后在左上方划出 4 × 4 同样大小的方框</p><p><img src="/uploads/Diary%20Encrypt%20Step%201.gif" alt="第一步：画上小方格"/></p><p>将小方框同样画在其余 3 个区域，然后在第一个区域上写上 1 ~ 16 个号码</p><p><img src="/uploads/Diary%20Encrypt%20Step%202.gif" alt="第二步：填满其余区域并填上数字"/></p><p>然后用镜像的方法去填满其他三个区域。镜像的意思是以中间分割线用镜子的方式将左边的元素写在右边，上下亦然。</p><p><img src="/uploads/Diary%20Encrypt%20Step%203.gif" alt="第三步：镜像填充每个格子"/></p><p>这样，我们的密码盘就已经做好了。我会在这里放上密码盘的成品，想要使用的伙伴可以去下载并打印出来。</p><p><img src="/uploads/Diary%20Encrypt.png" alt="密码盘"/></p><h2 id="使用密码盘"><a href="#使用密码盘" class="headerlink" title="使用密码盘"></a>使用密码盘</h2><p><img src="/uploads/Diary%20Encrypt%20Step%204.gif" alt="第四步：每个号码挖一个洞"/></p><p>接下来，我们将四个区域用颜色区分开来。然后我们发现，每个号码都在不同的区域上出现了一次。接下来，从 1 ~ 16 我们分别挑不同的颜色进行挖洞。注意：每个号码只能<strong>被挖一次</strong>且可以不挖。</p><p>然后，我们找来另一张纸，叠在密码盘下方。开始跟着空格从左往右写明文（明文就是一般我们看得懂的问字）。像以下这张图，我们挖了15个格子。</p><p><img src="/uploads/Diary%20Encrypt%20Hole.png" alt="密码盘，已经挖好的洞"/></p><p>当写满一面之后，我们从左往右翻密码卡；再次写满另一面之后，从上往下翻、最后从左往右翻页。其顺序示意图依次如下：</p><p><img src="/uploads/Diary%20Encrypt%20Flip%20Showcase.png" alt="日记加密反转示意图"/></p><p>这里一张卡，最多可以写64个字符。那如果你要写更多的话，可以将字体挤在一起写。具体操作如下：当你写完首64个字符之后，将密码盘上下翻转回正面，然后在第一个格子文字的右侧写上下一个字符，以此类推。直到写完你所有的文章。</p><p>还有就是，当密码盘没写完的话，就用其他杂乱无章的文字将剩余的空位填满。<strong>加密学，很重要的一个概念就是“障眼法”。</strong>我们没有写满的空白地方就可以用这些无意义的字符去填满它。混淆视听。</p><h2 id="密码盘原理"><a href="#密码盘原理" class="headerlink" title="密码盘原理"></a>密码盘原理</h2><p>看到这里的小伙伴，可以给自己一个鼓励了。那么我们就来分析这个密码盘的原理及其安全性和基本用途。</p><h3 id="为什么只能镂空其中一个号码？"><a href="#为什么只能镂空其中一个号码？" class="headerlink" title="为什么只能镂空其中一个号码？"></a>为什么只能镂空其中一个号码？</h3><p>首先思考一下，为什么每个数字只能挑其中一个颜色进行挖洞？右侧这张图或许能给你很好的思路。</p><p>从这张图中，你可以观察到数字 1 分布在了四个角，配合翻转示意图，就可以发现，其实当我们旋转的时候，数字 1 的确会出现在每个不同的角落。因此我们只能从四个区域里面挑出其中一个位置进行镂空。</p><p><img src="/uploads/Diary%20Encrypt%20Color.png" alt="密码盘彩色版"/></p><p><img src="/uploads/Diary%20Encrypt%20Flip%20Showcase.png" alt="日记加密反转示意图"/></p><h3 id="这玩意的安全性？"><a href="#这玩意的安全性？" class="headerlink" title="这玩意的安全性？"></a>这玩意的安全性？</h3><p>OK，首先我们知道这个密码盘有 16 个号码，每个号码对应 4 个区域，外加如果完全没有镂空。那么每个号码有 5 种选择，那这个密码盘就有 516 个可能性（152587890625，1500亿种可能性）。但是这个具有固定算法的，用计算机就能暴力破解出来了。所以这个加密手段是不能对抗暴力计算的。</p><h3 id="怎么记住密码盘的位置？"><a href="#怎么记住密码盘的位置？" class="headerlink" title="怎么记住密码盘的位置？"></a>怎么记住密码盘的位置？</h3><p>这是个好问题！那这里有 64 个格子，我们怎么记得这张卡上的位置呢？李老师教的方法有两个：二进制换算和特殊号码。</p><h4 id="二进制记忆法"><a href="#二进制记忆法" class="headerlink" title="二进制记忆法"></a>二进制记忆法</h4><p>这就要用到高中学到的二进制了。很简单，逢二进一的那个进制。首先，我们将密码盘转向正面。镂空的部分用黑色填满，没镂空则用白色填满。黑色代表 1，白色代表 0。那么从上往下依次为（这里我将二进制写出来，并且直接换算成十进制）：</p><p><img src="/uploads/Diary%20Encrypt%20Binary.png" alt="将镂空的地方用黑色填满，代表 1；没镂空的地方用白色填满，代表 0"/><br>将镂空的地方用黑色填满，代表 1；没镂空的地方用白色填满，代表 0</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 1010 = 138</span><br><span class="line">1001 0110 = 150</span><br><span class="line">1001 0000 = 144</span><br><span class="line">0010 0000 = 32</span><br><span class="line">0100 1000 = 72</span><br><span class="line">0100 1000 = 74</span><br><span class="line">0000 0000 = 0</span><br><span class="line">0000 0100 = 4</span><br></pre></td></tr></table></figure><p>那么你只要记住 10 进制的部分就能反推二进制出来。那如果不想记这么几个毫不相关的号码呢？</p><h4 id="区域记忆法"><a href="#区域记忆法" class="headerlink" title="区域记忆法"></a>区域记忆法</h4><p>那，我们知道这个密码盘已经被我们划分了 4 个区域，那么我们就按照密码盘的区域分别写上一段码，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0 代表不镂空，1 表示红色，2 表示黄色，3 表示蓝色，4 表示绿色：</span><br><span class="line">1242 1221 1431 0314</span><br></pre></td></tr></table></figure><p>那么这16个代码有什么意义呢？这里我参考了李永乐老师所举的例子，用了牛顿和爱因斯坦的生日（<code>1642 1225 1879 0314</code>），并且做了写处理——因为我们能表示的数值只有 0 ~ 4，所以大于 4 的就减去 4，直到他小于等于 4 为止。</p><p>那么我们只需要记得这16个对我们有意义的号码，就能反推成自己的加密卡了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们的<strong>镜像加密</strong>原理了。后续我会尝试用代码去实现镜像加密及其核心思路。喜欢这类文章的小伙伴可以<a href="http://tootaio.com/wp-login.php?action=register">点击这里</a>注册我们官网的账号，一起讨论哦！ 也期待你们<a href="https://discord.gg/sJcv7ZM">加入我们的Discord服务器</a>一起聊天！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> 李永乐老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 数据库应不应该取别名</title>
      <link href="/2021/83c00540.html"/>
      <url>/2021/83c00540.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>除了查询的数据表可以取别名来方便操作外，对数据列也是可以取别名的。</p><hr><p>我先来说我的观点：对于数据列，是不建议取别名的。假设有以下两张表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 部门表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> department(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 员工信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">dept_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> fk_dept_id <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> department(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> department(name) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;教学部&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;研发部&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;产品部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(name, dept_id) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">(<span class="string">&#x27;王五&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">(<span class="string">&#x27;赵六&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>因为 id 和 name 重名，那么在查询的时候，后端程序员这么写查询语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">emp.id,   <span class="comment">-- 因为这里只有一个 ID，就是用户 ID</span></span><br><span class="line"><span class="comment">-- 查询两个 name，需要设置别名</span></span><br><span class="line">emp.name <span class="keyword">AS</span> employee_name,</span><br><span class="line">dept.name <span class="keyword">AS</span> dept_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">employee <span class="keyword">AS</span> emp</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">department <span class="keyword">AS</span> dept</span><br><span class="line"><span class="keyword">ON</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p>得到的数据将为</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;emp_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dept_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;教学部&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;emp_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;dept_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品部&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>但是，如果另一个接口的别名不同的话，json 将会输出对应字段名称，照成前端代码不统一。</p><p>所以我赞成在建立后端数据库的时候就明确每个数据表之间的字段。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 解决数据库中文乱码 详细版</title>
      <link href="/2021/78544108.html"/>
      <url>/2021/78544108.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="检查前端页面编码"><a href="#检查前端页面编码" class="headerlink" title="检查前端页面编码"></a>检查前端页面编码</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><h2 id="修改Eclipse字符集"><a href="#修改Eclipse字符集" class="headerlink" title="修改Eclipse字符集"></a>修改Eclipse字符集</h2><p><code>Window &gt; Preferences &gt; General &gt; Workspace</code>，修改<code>Text file encoding</code>项。</p><p>选择 <code>Other</code>，下拉框选择<code>UTF-8</code></p><h3 id="原先项目乱码解决"><a href="#原先项目乱码解决" class="headerlink" title="原先项目乱码解决"></a>原先项目乱码解决</h3><p>然后你就会发现你的项目里的汉字全是乱码，这时候随便在某个地方创建一个Java文件，命名为<code>Main.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A code block</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/eclipse-workspace&quot;</span>);<span class="comment">//需要转码的GBK格式文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/eclipse-workspace2&quot;</span>);<span class="comment">//转码成UTF-8的目标文件夹</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Main</span>().copyFile(f1, f2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File f1, File f2)</span> <span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line"><span class="keyword">if</span>(f1.isDirectory()) &#123;</span><br><span class="line">f2.mkdir();</span><br><span class="line">File[] fs = f1 .listFiles();</span><br><span class="line"><span class="keyword">for</span> (File subF : fs) &#123;</span><br><span class="line"><span class="comment">//递归遍历目录</span></span><br><span class="line">copyFile(subF, <span class="keyword">new</span> <span class="title class_">File</span>(f2, subF.getName()));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f1.isFile() &amp;&amp; f1.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//对java文件进行转码</span></span><br><span class="line">parse2UTF_8(f1, f2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//对非java文件直接复制</span></span><br><span class="line">copyData(f1, f2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyData</span><span class="params">(File f1, File f2)</span> <span class="keyword">throws</span> FileNotFoundException, IOException&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f1);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (-<span class="number">1</span> != (temp = fis.read(bytes))) &#123;</span><br><span class="line">fos.write(bytes, <span class="number">0</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fos.flush();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> != fis) &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> != fos) &#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该方法引用 杰克思勒(Jacksile)的文章：Eclipse修改编码后乱码解决</span></span><br><span class="line"><span class="comment"> * 之后作了小修改</span></span><br><span class="line"><span class="comment"> * 原码地址 http://www.cnblogs.com/tufujie/p/5137564.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parse2UTF_8</span><span class="params">(File file, File destFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// 读写对象</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile.getAbsolutePath(), <span class="literal">false</span>), <span class="string">&quot;utf8&quot;</span>));</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file.getAbsolutePath()), <span class="string">&quot;gbk&quot;</span>));</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 读写动作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">            msg.append(line).append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            line = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        ps.write(msg.toString());</span><br><span class="line">        br.close();</span><br><span class="line">        ps.flush();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭Eclipse，然后 javac，java编译运行这段代码。</p><p>然后删掉旧的workspace文件夹，eclipse打开新的workspace文件夹。</p><h2 id="修改后端代码"><a href="#修改后端代码" class="headerlink" title="修改后端代码"></a>修改后端代码</h2><p>到Servlet的get、post方法添加这几行代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>); </span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>【可选项】优化效率，字符串的获取方式可以变为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.getParameter(<span class="string">&quot;name&quot;</span>).getBytes(<span class="string">&quot;utf-8&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))</span><br></pre></td></tr></table></figure><p>修改MySQL的url：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//useUnicode表示允许使用自定义的Unicode,</span></span><br><span class="line"><span class="comment">//characterEncoding是给定自定义的Unicode是什么</span></span><br><span class="line">String url=<span class="string">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&quot;</span></span><br></pre></td></tr></table></figure><h2 id="修改数据库字符集"><a href="#修改数据库字符集" class="headerlink" title="修改数据库字符集"></a>修改数据库字符集</h2><p>到你的MySQL去，执行以下代码（通过Navicat的话，直接New Query就行）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_database <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_server <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_system <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%chara%&quot;;</span><br></pre></td></tr></table></figure><p>如果表格大概长这样，就行了：</p><div class="table-container"><table><thead><tr><th>Variable_name</th><th>Value</th></tr></thead><tbody><tr><td>character_set_client</td><td>utf8</td></tr><tr><td>character_set_connection</td><td>utf8</td></tr><tr><td>character_set_database</td><td>utf8</td></tr><tr><td>character_set_filesystem</td><td>binary</td></tr><tr><td>character_set_results</td><td>utf8</td></tr><tr><td>character_set_server</td><td>utf8</td></tr><tr><td>character_set_system</td><td>utf8</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 总结性介绍</title>
      <link href="/2021/b49d3ef.html"/>
      <url>/2021/b49d3ef.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>前言：次文章乃个人理解，如与实际知识点有出入，欢迎讨论指教，谢谢各位——作者：小麦</p><p>8/3/2021 - 对Ajax获取数据之前讲的不严谨，对其增加案例讲解；补充SQL语句的介绍</p></blockquote><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p><h2 id="Java是干前端还是后端的"><a href="#Java是干前端还是后端的" class="headerlink" title="Java是干前端还是后端的"></a>Java是干前端还是后端的</h2><p>这个嘛，都有，只是Java设计后端的知识点更多，前端Java的代表就是安卓开发。后端的话，就是接下来我们要讲的。</p><h2 id="为什么要学Java"><a href="#为什么要学Java" class="headerlink" title="为什么要学Java"></a>为什么要学Java</h2><p>Java语言是目前中国市场需求量最高的编程语言，就冲这一点——赚钱！</p><h1 id="生涩难懂的概念"><a href="#生涩难懂的概念" class="headerlink" title="生涩难懂的概念"></a>生涩难懂的概念</h1><blockquote><p>以下知识点都是个人理解，用最基本的方式去搞清楚这些概念。可能和专业认知有出入，欢迎指正</p></blockquote><h2 id="什么是JavaWeb？"><a href="#什么是JavaWeb？" class="headerlink" title="什么是JavaWeb？"></a>什么是JavaWeb？</h2><p>用Java技术来解决相关web互联网领域的技术栈。web包括：web服务端和web客户端两部分。Java在客户端的应用有Java Applet，不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet，JSP、第三方框架等等。Java技术对Web领域的发展注入了强大的动力。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>Internet上被人访问的Web资源分为两种，静态web资源和动态web资源。</p><p>前端就是让使用者看得见的界面——比如HTML页面。</p><h3 id="静态Web资源"><a href="#静态Web资源" class="headerlink" title="静态Web资源"></a>静态Web资源</h3><p>顾名思义，静态Web资源就是给人浏览的数据始终不变的。比如我写了个静态页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>My First Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            Hello, world!</span><br><span class="line">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么不论你什么时候打开这个页面，你看到的内容始终不变。</p><p>它的开发技术是由：HTML、CSS构成。</p><h3 id="动态Web资源"><a href="#动态Web资源" class="headerlink" title="动态Web资源"></a>动态Web资源</h3><p>动态的资源是由程序产生的，我们在不同时间点访问Web页面看到的内容各不相同。举个栗子：我们打开百度词条</p><p><img src="/uploads/javaweb-note/%E7%99%BE%E5%BA%A6%E7%99%BE%E7%A7%91.png" alt="百度百科"> </p><p>你会看到，右边的<code>V百科</code>字段内容会不定时的更新（若干天之后你打开这个就会看见他变成其他图片了）。就连词条里的文本解释（整个页面内容）也会随着用户点击右上角的<code>编辑</code>进行修改，然后发送到后端服务器更新保存。修改之后，如果其他用户在另一个位置打开这个网页，将看见你修改后的词条信息。</p><p>动态web资源开发技术：JavaScript、JSP/Servlet、ASP、PHP等。在Java中，动态web资源开发技术统称为Java Web。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>暗地里搞事情的，就是后端。我们从前端获取用户输入的数据，然后通过后端对数据进行处理，再返回到前端。后端就是在后面默默处理数据的打工人。</p><h3 id="为什么要有后端？"><a href="#为什么要有后端？" class="headerlink" title="为什么要有后端？"></a>为什么要有后端？</h3><p>维基百科 Wikipedia 上由 1,181,768篇条目（数据截至2021年3月7日）。整整一百万条，这还只是中文页面而已，光是英文页面都有600万条！他有个实时反馈的搜索框，为了给大家讲明白，上图：</p><p><img src="/uploads/javaweb-note/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%E6%90%9C%E7%B4%A2.png" alt="维基百科搜索"> </p><p>就是右上角那玩意，设想：如果将这100万条字条（你想象成平时我们用的大英字典）全都直接在页面加载的时候直接保存在你电脑的缓存（我们打开网页实际上就是下载一个临时的HTML供我们查看，这点可以在<code>F12</code>的<code>Sources</code>标签里看到整个网站包含的所有文件和媒体资源。），平均每一个单词16字节（乐观），那么首先吃不消的是你的移动数据，第二影响用户体验。你想我需要通过几分钟时间来加载这个搜索框，而不是实际看到的页面内容（就好像《给他爱》中执行了19.8亿次的if-else判断，那漫长的等待时间），那是个什么体验？还别说那些内存小的老爷机……弄不好直接蓝屏报销。</p><p>这时候就要祭出我们的其中一项利器了！有请Ajax！</p><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>承上，维基百科里有100万条中文词条，那么当我们搜索的时候，Wikipedia将会调用ajax将我们的数据通过API发送到后端，让后端进行数据处理。再将搜寻结果返回到前端页面，通过JavaScript对返回来的数据进行处理展示给用户。</p><p>这点我们可以通过<code>F12</code>的开发者模式获得验证（对百度百科也适用，只不过百度百科令在下咂舌，恕在下懒得对其进行解释）</p><p><img src="/uploads/javaweb-note/%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91Ajax%E4%BB%A3%E7%A0%81.png" alt="维基百科 Ajax 代码"> </p><p>通过代码查询，可以看到，在index.php这个文件里的第588行有个Ajax代码（别问为什么我这么搜，该死的直觉）。这是我们熟悉的jQuery（事实上现在市面上大部分的网站都使用jQuery库，真香）。具体呢就是访问<code>url</code>后面拼接的链接（俗称API）进行数据获取，然后在前端JavaScript进行数据处理。</p><h3 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h3><p>Ajax即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术）</p><p>白话点说，就是：在不刷新页面下，对页面数据内容进行更新的一项技术。</p><h3 id="Ajax和后端有什么关系"><a href="#Ajax和后端有什么关系" class="headerlink" title="Ajax和后端有什么关系"></a>Ajax和后端有什么关系</h3><p>要说关系的话，就是通过Ajax访问后端开放的API接口，然后对API接口返回的值进行处理，显示在前端页面。</p><h3 id="用Ajax获取数据"><a href="#用Ajax获取数据" class="headerlink" title="用Ajax获取数据"></a>用Ajax获取数据</h3><p>我们用原生JavaScript来实现Ajax，并对他进行讲解：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>XMLHttpRequest 对象<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;loadDoc()&quot;</span>&gt;</span>修改内容<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;core.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* core.js */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadDoc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 给 xhttp 设置事件监听</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123; <span class="comment">// 当访问得到数据</span></span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">responseText</span>; <span class="comment">// 将返回值写到页面上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;ajax_info.txt&quot;</span>, <span class="literal">true</span>); <span class="comment">// 设置请求方式，文件或API链接，是否异步</span></span><br><span class="line">    xhttp.<span class="title function_">send</span>(); <span class="comment">// 发送Ajax请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ajax_info.txt的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;AJAX&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;AJAX 并不是编程语言。&lt;/p&gt;</span><br><span class="line">&lt;p&gt;AJAX 是一种从网页访问 Web 服务器的技术。&lt;/p&gt;</span><br><span class="line">&lt;p&gt;AJAX 代表异步 JavaScript 和 XML。&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>当我们点击<code>修改内容</code>按钮后，<code>ajax_info.txt</code>的内容就会在不刷新页面的情况下直接写进HTML里。</p><p>我们也可以把上面的<code>core.js</code>重写成jQuery的ajax函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadDoc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;ajax_info.txt&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">responseText</span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="variable language_">this</span>.<span class="property">responseText</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Ajax事实上就是通过访问URL，然后程序员需要处理返回来的response值而已。至于所访问的对象是文件、接口、文本文档……都可以。以我对他的认知，就是能获取到字符串的就行。</p><h2 id="API？"><a href="#API？" class="headerlink" title="API？"></a>API？</h2><p>应用程序接口（Application Programming Interface）。在这里就是后端代码给你的一扇门，让你可以通过这扇门传递数据给他。它也可以通过这扇门给你数据。也就是页面和后端代码沟通的一个桥梁。</p><h2 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h2><p>简单理解：我们输入的账号密码，这叫数据。维基上的词条内容，这叫数据。保存在数据库里的图片啥的，这也叫数据。</p><p>数据（英语：data）是通过观测得到的数字性的特征或信息。更专业地说，数据是一组关于一个或多个人或对象的定性或定量变量。</p><h1 id="后端在干嘛"><a href="#后端在干嘛" class="headerlink" title="后端在干嘛"></a>后端在干嘛</h1><p>那么Ajax通过API传递给后端之后，后端在干嘛？这里我们用一套自己写的案例来讲解：</p><h2 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h2><blockquote><p>这前端JavaScript代码有点旧，后端一直在更新，我只是讲个概念，代码用不了的。会解释用不了的原因</p></blockquote><p>在第二学期的时候，我们通过JavaScript和后端给的接口进行数据访问。</p><p>我们拿最基础的来讲——登陆界面</p><p><img src="/uploads/javaweb-note/%E8%88%AA%E7%A9%BA%E7%AE%A1%E7%90%86%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png" alt="航空管理登录页面"></p><p>然后我输入邮箱密码后点击<code>Login</code>就会调用JavaScript函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Login</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/SunshineAirlines/LoginServlet&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="string">&quot;Email=&quot;</span> + <span class="title class_">Email</span>.<span class="property">value</span> + <span class="string">&quot;&amp;Password=&quot;</span> + <span class="title class_">Password</span>.<span class="property">value</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里处理后端返回来的数据，进行跳转或错误信息显示等操作。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>反编译这里存粹是在讲后端在干嘛。看不懂可以跳过</p><p>大概知道Ajax访问的API是JavaServlet，然后我们反编译的东西叫做War包</p></blockquote><p>然后我们执行这个Ajax的时候，首先会到这个Servlet进行处理，我们通过反编译<code>SunshineAirlines.war</code>War包。找到<code>edu.wtbu.servlet.LoginServlet.class</code>的代码。这里的classes文件夹对应我们开发的src文件夹。只不过classes是因为Java文件被编译的时候，文件后缀将是<code>.class</code>。</p><p><img src="/uploads/javaweb-note/%E5%8F%8D%E7%BC%96%E8%AF%91LoginServlet.png" alt="反编译LoginServlet"> </p><p>在Ajax对数据进行请求的时候，我们用的是POST方法，所以会调用doPost方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> UsersService.login(email, password); <span class="comment">// 传递给UsersService的静态方法login()进行处理</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> JSON.toJSONString(result); <span class="comment">// 将Result对象转换成JSON字符串</span></span><br><span class="line">    response.getWriter().append(msg); <span class="comment">// 返回数据（就是个页面，内容是返回的JSON字符串）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们完整的的API URL是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/SunshineAirlines/login?email=behappy@vip.sina.com&amp;password=behapp</span><br></pre></td></tr></table></figure><p>所以，通过<code>getParameter()</code>方法之后，<code>email = behappy@vip.sina.com</code>和<code>password = behapp</code></p><p>第五行，我们将这两个变量值传递给UsersService的静态方法<code>login()</code>进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">login</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="string">&quot;fail&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    HashMap&lt;String, Object&gt; user = UsersDao.findByEmailAndPassword(email, password);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.setFlag(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        result.setData(user);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">bUser</span> <span class="operator">=</span> findByEmail(email);</span><br><span class="line">        <span class="keyword">if</span> (bUser.booleanValue()) &#123;</span><br><span class="line">            result.setData(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.setData(<span class="string">&quot;邮箱不存在&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三行我们又将值传递给<code>UsersDao</code>的<code>findByEmailAndPassword()</code>方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Object&gt; <span class="title function_">findByEmailAndPassword</span><span class="params">(String email, String password)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from Users where Email=? and Password=?&quot;</span>;</span><br><span class="line">    List&lt;HashMap&lt;String, Object&gt;&gt; usersList = MySqlHelper.executeQueryReturnMap(sql, </span><br><span class="line">                                                                                (Object[])<span class="keyword">new</span> <span class="title class_">String</span>[] &#123; email, password &#125;);</span><br><span class="line">    <span class="keyword">if</span> (usersList == <span class="literal">null</span> || usersList.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">return</span> usersList.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行，我们准备SQL语句，然后对数据库中叫Users的表进行查找，慢慢的把数据传递回去。</p><p>以上就是后台做的工作</p><blockquote><p>当然，后台做的工作可不止这些，比如说一些网站需要设计算法，阻止爬虫爬取信息，也可以通过Java后端代码进行计算。这里有机会再说，又是扯出一堆知识点。</p></blockquote><h1 id="看不懂反编译那部分可以直接跳到这里"><a href="#看不懂反编译那部分可以直接跳到这里" class="headerlink" title="看不懂反编译那部分可以直接跳到这里"></a>看不懂反编译那部分可以直接跳到这里</h1><p>其实看不懂上面的话，这里我怕也讲不清楚，凑合着看一下。</p><h2 id="SQL语句？"><a href="#SQL语句？" class="headerlink" title="SQL语句？"></a>SQL语句？</h2><p>我们需要对数据库进行操作，最基本的就是对其进行增删改查（CRUD），那么和数据库沟通，就需要一套和数据库交流的语言。这就是SQL</p><p>SQL（Structured Query Language:结构化查询语言）是一种特定目的编程语言，用于管理关系数据库管理系统（RDBMS），或在关系流数据管理系统（RDSMS）中进行流处理。</p><h2 id="什么是Servlet？"><a href="#什么是Servlet？" class="headerlink" title="什么是Servlet？"></a>什么是Servlet？</h2><p>Servlet（Server Applet），全称Java Servlet。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p><p>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p><h2 id="什么是War包？"><a href="#什么是War包？" class="headerlink" title="什么是War包？"></a>什么是War包？</h2><blockquote><p>Java还有个东西叫Jar包，和War包概念一样，我就一起讲吧</p></blockquote><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都可以看成压缩文件，都可以用解压软件打开，jar包和war包都是为了项目的部署和发布，通常在打包部署的时候，会在里面加上部署的相关信息。这个打包实际上就是把代码和依赖的东西压缩在一起，变成后缀名为.jar和.war的文件，就是我们说的jar包和war包。</p><p>这个“压缩包”可以被编译器直接使用，把war包放在tomcat目录的webapp下，tomcat服务器在启动的时候可以直接使用这个war包。通常tomcat的做法是解压，编译里面的代码，所以当文件很多的时候，tomcat的启动会很慢。</p><h3 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h3><p>jar包是java打的包。jar包中只是用java来写的项目打包来的，里面只有编译后的class和一些部署文件。</p><h3 id="War包"><a href="#War包" class="headerlink" title="War包"></a>War包</h3><p>war包可以理解为javaweb打的包。war包里面的东西比较全，包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。</p><h3 id="什么时候使用Jar包和War包？"><a href="#什么时候使用Jar包和War包？" class="headerlink" title="什么时候使用Jar包和War包？"></a>什么时候使用Jar包和War包？</h3><p>当你的项目在没有完全完成的时候，不适合使用war文件，因为你的类会由于调试之类的经常改，这样来回删除、创建war文件很不方便，来回修改，来回打包，最好是你的项目已经完成了，不做修改的时候，那就打个war包吧，这个时候一个war文件就相当于一个web应用程序；而jar文件就是把类和一些相关的资源封装到一个包中，便于程序中引用。</p><h2 id="什么是Tomcat？"><a href="#什么是Tomcat？" class="headerlink" title="什么是Tomcat？"></a>什么是Tomcat？</h2><p>他就是个Servlet容器。</p><p>实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全局管理和Tomcat阀等。由于Tomcat本身也内含了HTTP服务器，因此也可以视作单独的Web服务器。但是，不能将Tomcat和Apache HTTP服务器混淆，Apache HTTP服务器是用C语言实现的HTTPWeb服务器；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p><h1 id="追问"><a href="#追问" class="headerlink" title="追问"></a>追问</h1><h2 id="什么是JSP？"><a href="#什么是JSP？" class="headerlink" title="什么是JSP？"></a>什么是JSP？</h2><h2 id="Servlet干嘛的？"><a href="#Servlet干嘛的？" class="headerlink" title="Servlet干嘛的？"></a>Servlet干嘛的？</h2><h1 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Java">Java - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://blog.csdn.net/xiaoyaGrace/article/details/105482920">2020年Java市场需求分析_xiaoyaGrace的博客-CSDN博客_java市场需求</a></li><li><a href="https://baike.baidu.com/item/Java Web">java web_百度百科 (baidu.com)</a></li><li><a href="https://zh.wikipedia.org/wiki/前端和后端">前端和后端 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://www.html.cn/qa/other/19407.html">java是前端还是后端？ - html中文网</a></li><li><a href="https://zh.wikipedia.org/wiki/AJAX">AJAX - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://www.w3schools.com/js/js_ajax_intro.asp">AJAX Introduction (w3schools.com)</a></li><li><a href="https://zh.wikipedia.org/wiki/应用程序接口">应用程序接口 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://zh.wikipedia.org/wiki/数据">数据 - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL">SQL - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://zh.wikipedia.org/wiki/Java_Servlet">Java Servlet - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://www.jianshu.com/p/57f8a4aae6a3">jar包和war包的介绍与区别 - 简书 (jianshu.com)</a></li><li><a href="https://zh.wikipedia.org/wiki/Apache_Tomcat">Apache Tomcat - 维基百科，自由的百科全书 (wikipedia.org)</a></li><li><a href="https://blog.csdn.net/skyejy/article/details/78310549">(servlet是干什么的？一个程序媛的成长记录❤-CSDN博客</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 航空管理系统后端笔记</title>
      <link href="/2021/5943eb7f.html"/>
      <url>/2021/5943eb7f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Response.setContentType(text/html;charset=utf-<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>将浏览器编码设置为utf-8，使其出现中文时不会乱码</p><h2 id="404报错"><a href="#404报错" class="headerlink" title="404报错"></a>404报错</h2><p>servlet 名称没有更改成和 api 文档中一致，或者是文件夹包名命名错误，解决方法就是将其改为一致。</p><h2 id="500报错"><a href="#500报错" class="headerlink" title="500报错"></a>500报错</h2><h3 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h3><p>代码中数据定义出错，缺少定义或者代码本身错误，解决方案是检查代码的数据定义，以及代码本身问题。</p><h3 id="Size-gt-1"><a href="#Size-gt-1" class="headerlink" title="Size &gt; 1"></a>Size &gt; 1</h3><p>sql语句出现问题，在返回数据时参数位置写反，以及sql语句中，应该为’？’的地方写出了具体数据，解决方案是将其修正过来。</p><hr><p>在sql条件为两个时，需要用and连接，如果没有连接则会报错。在部分接口startDate和endDate的获取是根据<br>departureDate时，引号中间有空格。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 解决后端中文乱码</title>
      <link href="/2021/6aa24485.html"/>
      <url>/2021/6aa24485.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="修改数据库可以保存中文"><a href="#修改数据库可以保存中文" class="headerlink" title="修改数据库可以保存中文"></a>修改数据库可以保存中文</h2><blockquote><p>以下方法适用于 MySQL 5.0 和 8.0。</p></blockquote><p>首先打开 MySQL Command Line Client（就是 MySQL 的终端程序），输入数据库密码。</p><p>在第一行输入 <code>show variables like &#39;%char%&#39;;</code>，它会返回一张表。上面是数据库编码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| Variable_name            | Value                                |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| character_set_client     | gbk                                  |</span><br><span class="line">| character_set_connection | gbk                                  |</span><br><span class="line">| character_set_database   | utf8mb4                              |</span><br><span class="line">| character_set_filesystem | binary                               |</span><br><span class="line">| character_set_results    | gbk                                  |</span><br><span class="line">| character_set_server     | utf8mb4                              |</span><br><span class="line">| character_set_system     | utf8mb3                              |</span><br><span class="line">| character_sets_dir       | C:\Program Files\MySQL\MySQL Server  |</span><br><span class="line">                             8.0\share\charsets\                  |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 12 三层 JDBC</title>
      <link href="/2021/cc297d3e.html"/>
      <url>/2021/cc297d3e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="步骤回顾"><a href="#步骤回顾" class="headerlink" title="步骤回顾"></a>步骤回顾</h3><p>要进行一次完整的数据库增删改查，我们需要执行以下的步骤：</p><ol><li>获得 URL 的参数</li><li>将参数拼接成 SQL 语句</li><li>访问数据库（省略 MySqlHelper 所做的操作）</li><li>处理数据</li><li>Servlet 界面显示返回值</li></ol><h3 id="一层-JDBC"><a href="#一层-JDBC" class="headerlink" title="一层 JDBC"></a>一层 JDBC</h3><blockquote><p>MySqlHelper + Servlet（界面）</p></blockquote><ol><li>Servlet 负责接收 URL 参数</li><li>然后将 SQL 语句和参数传递给 MySqlHelper 的方法</li><li>MySqlHelper 查询数据库之后处理返回值对象，并合并为 List 对象返回给 Servlet</li><li>Servlet 将其转换成 JSON 字符串，输出。</li></ol><p><strong>注：</strong> 这个版本的 JSON 也不是我们想要输出的样子，因为它没有 data 和 flag 键。</p><h3 id="两层-JDBC"><a href="#两层-JDBC" class="headerlink" title="两层 JDBC"></a>两层 JDBC</h3><blockquote><p>MySqlHelper + DAO + Servlet，外加一个 pojo.Result 实体类</p></blockquote><p>DAO = Data Access Object 数据访问层</p><p>DAO 保存了 SQL 语句</p><ol><li>Servlet 负责接收 URL 参数</li><li>将参数传给对应的 DAO</li><li>DAO 拼接参数，调用 MySqlHelper 得到 List 对象</li><li>DAO 再把数据返回给 Servlet</li><li>Servlet 将数据保存在 Result 实例的 data 成员变量里</li><li>Servlet 再将 Result 对象转换为 JSON 字符串，输出。</li></ol><h2 id="三层-JDBC"><a href="#三层-JDBC" class="headerlink" title="三层 JDBC"></a>三层 JDBC</h2><blockquote><p>MySqlHelper + DAO + Service + Servlet</p></blockquote><p>Service 业务逻辑层，它将 DAO 返回的数据处理后装进 Result 对象里，返回给 Servlet。</p><p>添加一个 service 包，创建的 Service 类名命名方式和 DAO 文件一样：<code>数据库表名Service.java</code>。</p><p>Service 负责调用 DAO 的方法，所以通常 service 的方法名应该和 DAO 一样，返回值为 Result。代码长这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">getCityNames</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">result.setFlag(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">result.setData(CityDao.getCityNames());</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 Servlet 里原先两层重复的代码（以下这一段）可以直接简化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">result.setFlag(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">result.setData(CityDao.getCityNames());</span><br></pre></td></tr></table></figure><p>改为这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> get或post方法(request, response) &#123;</span><br><span class="line"><span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> CityService.getCityNames();</span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">response.getWriter().append(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 10 MySqlHelper 类第 3 版</title>
      <link href="/2021/b29dd643.html"/>
      <url>/2021/b29dd643.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>引入 HashMap，让返回值变为哈希表，而不是 ResultSet。因为 ResultSet 不能直接转为 JSON 字符串。</p><p>HashMap 是键值对，键是唯一的，值是不唯一的。所以可以通过键来找到对应的值。</p><p>修改函数的返回值为：<code>HashMap&lt;String, Object&gt;</code>。意味着我们需要的键值对为字符串和 Object 类型</p><p>然后再将数据通过 Servlet 返回</p><p>仅仅通过 HashMap 返回是不行的。因为我们需要返回的数据可能是多条，而 HashMap 只能是一条记录。下面我们会一步一步的去升级它，看着！</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先，我们最后要返回的是 JSON 字符串。所以需要下载阿里巴巴的 FastJson 包。到 <a href="https://repo1.maven.org/maven2/com/alibaba/fastjson/1.2.78/">Central Repository: com/alibaba/fastjson/1.2.78 (maven.org)</a> 下载 fastjson-1.2.78.jar。然后拖入项目的 <code>src/main/webapp/WEB-INF/lib</code> 文件夹下。</p><h2 id="第一次升级"><a href="#第一次升级" class="headerlink" title="第一次升级"></a>第一次升级</h2><p>修改 executeQuery：</p><blockquote><p>这里我省略了 中间一大段，改为注释。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Object&gt; <span class="title function_">executeQuery</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/* 建立连接 */</span></span><br><span class="line"><span class="comment">/* 创建 PreparedStatement 对象 */</span></span><br><span class="line"><span class="comment">/* 遍历 Params */</span></span><br><span class="line"><span class="comment">/* 执行查询 */</span></span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">map.put(<span class="string">&quot;UserId&quot;</span>, rs.getObject(<span class="number">1</span>)); <span class="comment">// 获取数据中的第 1 列</span></span><br><span class="line">map.put(<span class="string">&quot;Name&quot;</span>, rs.getObject(<span class="string">&quot;Name&quot;</span>)); <span class="comment">// 获取数据中列名为 Name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 关闭资源 */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 servlet 的 Get 或 Post 函数中写上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取 URL 中的参数 */</span></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">HashMap&lt;String, Object&gt; map = MySqlHelper.executeQuery(sql, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 转换为 JSON 字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(map);</span><br><span class="line">response.getWriter().append(json);</span><br></pre></td></tr></table></figure><p>上面执行查询的时候，我们的参数列表传递的是 null，也就是会返回整张表的数据。但是当我们实际运行的时候，会发现接口只返回了最后一项数据。</p><p>因为每次执行 while 循环，map.put 就会查询 UserId，第一次循环，没有，就创建一个 UserId 键，然后赋值。第二次循环，前面说键是唯一的，所以查询到了 UserId 就会覆盖旧的，然后替换为新的值。所以他只会返回最后一条数据。</p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>为了让它能够返回多条数据，我们需要让 HashMap 变成一个列表，可以保存多条数据。这时候我们就需要用到 List 对象了。</p><p>我们把代码改一改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;HashMap&lt;String, Object&gt;&gt; <span class="title function_">executeQuery</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HashMap&lt;String, Object&gt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/* 建立连接 */</span></span><br><span class="line"><span class="comment">/* 创建 PreparedStatement 对象 */</span></span><br><span class="line"><span class="comment">/* 遍历 Params */</span></span><br><span class="line"><span class="comment">/* 执行查询 */</span></span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">map.put(<span class="string">&quot;UserId&quot;</span>, rs.getObject(<span class="number">1</span>)); <span class="comment">// 获取数据中的第 1 列</span></span><br><span class="line">map.put(<span class="string">&quot;Name&quot;</span>, rs.getObject(<span class="string">&quot;Name&quot;</span>)); <span class="comment">// 获取数据中列名为 Name</span></span><br><span class="line">list.add(map); <span class="comment">// 将 map 添加到 List 里。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 关闭资源 */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，实例化 List 的时候不能直接 new List，而是要 new ArrayList。ArrayList 是 List 的子类。这是 Java 面向对象中的多态。</p><p>然后在 servlet 的 Get 或 Post 函数中写上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取 URL 中的参数 */</span></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; list = MySqlHelper.executeQuery(sql, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 转换为 JSON 字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(list);</span><br><span class="line">response.getWriter().append(json);</span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>仔细看，我们的 while 循环里，map 的键是写死的。但是如果我们要访问不同的表呢？或者说我们增加了新的数据列呢？所以我们要让 map 的键是动态调整的</p><p>这时候我们就需要把返回的列名提取出来，让 map 的键根据类名动态添加。首先，ResultSet 里边是没有获取列名的方法的。这时候我们就需要用到另一个对象：ResultSetMetaData</p><p>再修改代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;HashMap&lt;String, Object&gt;&gt; <span class="title function_">executeQuery</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line">List&lt;HashMap&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HashMap&lt;String, Object&gt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/* 建立连接 */</span></span><br><span class="line"><span class="comment">/* 创建 PreparedStatement 对象 */</span></span><br><span class="line"><span class="comment">/* 遍历 Params */</span></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">rs = pstmt.executeQuery();</span><br><span class="line"><span class="comment">// 获取 ResultSet 元数据</span></span><br><span class="line">ResultSetMetaData = rs.getMetaData();</span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 遍历返回的所有列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rsmd.getColumnCount(); i++) &#123;</span><br><span class="line">map.put(rsmd.getColumnName(i + <span class="number">1</span>), rs.getObject(i + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">list.add(map); <span class="comment">// 将 map 添加到 List 里。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 关闭资源 */</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们用 rs.getMetaData() 获得 ResultSet 元数据</li><li>rsmd.getColumnCount() 获得返回的列数</li><li>rsmd.getColumnName(i + 1) 获得列名，因为 java.sql 包下的索引都是 1 开始，所以 i + 1</li></ol><p>然后我们可以把之前的关闭也一并取消注释，因为 ResultSet 已经被我们整理好了，可以直接关闭释放资源。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 9 MySqlHelper 类第 2 版</title>
      <link href="/2021/cf6c99b3.html"/>
      <url>/2021/cf6c99b3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>之前的 MySqlHelper 在调用的时候是这样的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM [table] WHERE [col1] = [value1] AND [col2] = [value2]&quot;</span>;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> MySqlHelper.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>可以发现，我们之前的 SQL 语句已经写死了所有的数据。这样在后续开发的时候非常不方便，且不安全。容易出现 SQL 注入等情况。</p><p>现在，我们要优化我们的 MySqlHelper 类，让它的函数定义为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql, Object[] param)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title function_">executeUpdate</span><span class="params">(String sql, Object[] param)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>解释一下，<code>Object[] param</code> 是 SQL 语句的参数。为什么是 Object 类型？因为我们的参数可能是 String 也可能是 Integer。所有 Object 是 Java 中所有类的祖宗类，也就是说 Integer 和 String 都是继承自 Object 类的。</p><p>修改之后，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 方法：查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="comment">// 创建 PreparedStatement 对象</span></span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 遍历 param，如果有的话</span></span><br><span class="line"><span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> params[i].getClass().getName();</span><br><span class="line"><span class="comment">// 判断参数类型是字符串还是整数型</span></span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;String&quot;</span>)) &#123;</span><br><span class="line">pstmt.setString(i + <span class="number">1</span>, params[i].toString()); <span class="comment">// i + 1 是因为 pstmt 的索引从 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;Integer&quot;</span>)) &#123;</span><br><span class="line">pstmt.setInt(i + <span class="number">1</span>, Integer.parseInt(params[i].toString())); <span class="comment">// 转换为整数型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">rs = pstmt.executeQuery();</span><br><span class="line"><span class="comment">//closeAll(); // 暂时不关</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 方法：增删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql, Object[] params)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">// 创建 PreparedStatement 对象</span></span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 遍历 param，如果有的话</span></span><br><span class="line"><span class="keyword">if</span> (params != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> params[i].getClass().getName();</span><br><span class="line"><span class="comment">// 判断参数类型是字符串还是整数型</span></span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;String&quot;</span>)) &#123;</span><br><span class="line">pstmt.setString(i + <span class="number">1</span>, params[i].toString()); <span class="comment">// i + 1 是因为 pstmt 的索引从 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (className.contains(<span class="string">&quot;Integer&quot;</span>)) &#123;</span><br><span class="line">pstmt.setInt(i + <span class="number">1</span>, Integer.parseInt(params[i].toString())); <span class="comment">// 转换为整数型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">result = pstmt.executeUpdate();</span><br><span class="line">closeAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体就是：在 pstmt 创建之后，判断有没有 params。如果有则遍历 params 数组。里面获取 params 数组元素的类名，再判断它是整形还是字符串。再使用 setString 和 setInt 函数设置字符串和整数到 pstmt 对象里。</p><p>对于 setInt 函数，我们要使用 Integer.parseInt() 函数将字符串转换成整数型。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 8 MySqlHelper 类第 1 版</title>
      <link href="/2021/6fd145f4.html"/>
      <url>/2021/6fd145f4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>先来复习一遍要对数据库进行操作的步骤</p><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><ol><li>注册驱动</li><li>连接数据库</li><li>准备 PrepareStatement，预处理 SQL 语句</li><li>调用 executeUpdate() 得到 int 类型返回值</li><li>处理数据</li><li>关闭连接</li></ol><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ol><li>注册驱动</li><li>连接数据库</li><li>准备 PrepareStatement，预处理 SQL 语句</li><li>调用 executeQuery() 得到 ResultSet 类型返回值</li><li>处理数据</li><li>关闭连接</li></ol><h2 id="原先代码"><a href="#原先代码" class="headerlink" title="原先代码"></a>原先代码</h2><p>如果说看不懂上面我想表达什么，看看这两份代码</p><h3 id="增删改-1"><a href="#增删改-1" class="headerlink" title="增删改"></a>增删改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册驱动</span></span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.cj.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driver);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/数据库名&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 PrepareStatement 对象，预处理 SQL 语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接释放资源</span></span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册驱动</span></span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.cj.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driver);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/数据库名&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 PrepareStatement 对象，预处理 SQL 语句</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理结果</span></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接释放资源</span></span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySqlHelper-类提取"><a href="#MySqlHelper-类提取" class="headerlink" title="MySqlHelper 类提取"></a>MySqlHelper 类提取</h2><p>经过观察以上两个文件，我们得知其实除了执行查询和处理结果的语句有不同之外，很大一部分的代码都是重复的。所以我们可以将重复的部分提取出来，然后将他们封装成一个类。另外就是，如果没有这么做，那么每次访问数据库的时候，都需要重复写这些冗余的代码</p><p>所以我们需要一个类，负责处理数据库的链接和数据库增删改查。</p><p>我们把所有重复的代码提取出来，MySqlHelper.java 内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tootaio.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlHelper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/trading&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 匿名方法注册驱动</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 注册驱动程序</span></span><br><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driver);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 关闭连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeAll</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pstmt != <span class="literal">null</span>) &#123;</span><br><span class="line">pstmt.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 方法：查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span> &#123;</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="comment">// 创建 PreparedStatement 对象</span></span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">rs = pstmt.executeQuery();</span><br><span class="line"><span class="comment">//closeAll(); // 暂时不关</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 方法：增删改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">conn = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">// 创建 PreparedStatement 对象</span></span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 执行查询</span></span><br><span class="line">result = pstmt.executeUpdate();</span><br><span class="line">closeAll();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太长了看不懂？这里就来跟你解释。</p><p>首先这个类做了两件事情：</p><ul><li>增删改 executeUpdate</li><li>查 executeQuery</li><li>注册驱动</li><li>关闭连接 closeAll</li></ul><p>然后我们把他们共用的变量提取出来，得到：</p><ul><li>url: “jdbc:mysql://localhost:3306/trading”</li><li>username: “root”</li><li>password: “123456”</li><li>Connection 对象 conn</li><li>PreparedStatement 对象 pstmt</li><li>ResultSet 对象 rs</li></ul><h3 id="executeQuery"><a href="#executeQuery" class="headerlink" title="executeQuery"></a>executeQuery</h3><p>要让这个类能够执行查询，我们需要创建一个查询函数。参数列表是SQL语句，然后在里面执行查询操作。最后返回的是 ResultSet 对象。</p><h3 id="executeUpdate"><a href="#executeUpdate" class="headerlink" title="executeUpdate"></a>executeUpdate</h3><p>这个和查询方法的内容是一模一样的，只不过需要调用 pstmt 的 executeUpdate 函数，然后返回值是 int 类型。</p><h3 id="closeAll-函数"><a href="#closeAll-函数" class="headerlink" title="closeAll 函数"></a>closeAll 函数</h3><p>因为我们连接数据库，所以执行完操作后需要关闭对象释放资源。但是这边我们不关闭 rs 对象。目前不关</p><p>因为 rs 对象是要被返回，如果被关闭了，那么数据就没了。我们将会在下一个版本中解决这个问题。</p><h3 id="准备驱动"><a href="#准备驱动" class="headerlink" title="准备驱动"></a>准备驱动</h3><p>这里我们用了 static 匿名函数。static 匿名函数的调用时机是第一次使用这个 MySqlHelper 类中被调用。</p><p>因为 Class.forName() 是一个函数，函数不能在成员变量的域中被调用，必须要在函数里面才能被调用。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 7 SQL 语句</title>
      <link href="/2021/c259fa2a.html"/>
      <url>/2021/c259fa2a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>数据要和字段一一对应。如果是自增的字段可以直接略过</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段<span class="number">1</span>, 字段<span class="number">2</span>, 字段n)</span><br><span class="line"><span class="keyword">VALUES</span> (数据<span class="number">1</span>, 数据<span class="number">2</span>, 数据n);</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>* 代表返回所有字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> 条件</span><br></pre></td></tr></table></figure><ul><li>条件可以是零个或多个<ul><li>零个代表直接返回所有数据</li><li>多个条件可以用逻辑 AND 和 OR 进行隔开</li></ul></li><li>条件的语句通常为<ul><li>字段名 = 值</li><li>字段名 LIKE 值的样式（比如包含某些字母……）</li></ul></li><li>星号代表返回查询到的所有字段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 6 Servlet + JDBC</title>
      <link href="/2021/5c6bf6d0.html"/>
      <url>/2021/5c6bf6d0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><blockquote><p>这里以 MySQL Workbench 为例</p></blockquote><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>打开你的 MySQL 实例，在 Schemas 窗口中的<strong>空白位置</strong>右键，Create Schema</p><p>将其命名为自定义的数据库名。他的字符集设置为 utf8，utf8_general_ci</p><p>然后在 Schemas 窗口中，点击刚刚创建的数据库的 🔽 符号展开数据库。</p><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>右键 Tables，点击 Create Table，</p><p>在里面自定义表名，数据库字段。初学者先直接用鼠标操作。表名需要为小写</p><ol><li>Column Name  字段名<ol><li>数据库里不区分大小写，但是好习惯是<strong>字段名为大驼峰</strong></li></ol></li><li>Datatype 数据类型<ol><li>INT 整数型</li><li>VARCHAR() 可伸缩长度类型，可回收多余</li><li>CHAR 不会自动回收</li></ol></li><li>PK - Primary Key 主键</li><li>NN - Not Null 非空</li><li>UQ - Unique 独特（这个数据只能在整张表同一列中出现一次）</li><li>B - Binary 二进制</li><li>UN - Unsigned 无标号</li><li>ZF - Zero Fill 填充零</li><li>AI - Auto Increment 自增</li><li>G - Generated</li><li>Default / Expression 默认值</li></ol><p>通常在 Column Name 中输入特定的字段，系统会智能的帮你设定成所需的约束：</p><ol><li>UserId<ol><li>Datatype = INT</li><li>Primary Key</li><li>Not Null</li></ol></li></ol><p>Auto Increment 可以通过 Default / Expression 设置初始值，而每次增长多少位则需要使用 SQL 语句。</p><p>设置完了之后，点击 Apply 保存</p><p>这时候点开 Tables 的 🔽 符号，可以看到我们刚刚创建的表。</p><h3 id="打开表"><a href="#打开表" class="headerlink" title="打开表"></a>打开表</h3><p>右键点击 Select Rows，可以显示表的数据。</p><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>右键点击 Alter Table，可以对表的结构进行修改</p><h2 id="修改数据库可以保存中文"><a href="#修改数据库可以保存中文" class="headerlink" title="修改数据库可以保存中文"></a>修改数据库可以保存中文</h2><p>首先打开 MySQL Command Line Client（就是 MySQL 的终端程序），输入数据库密码。</p><p>在第一行输入 <code>show variables like &#39;%char%&#39;;</code>，它会返回一张表。上面是数据库编码。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| Variable_name            | Value                                |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| character_set_client     | gbk                                  |</span><br><span class="line">| character_set_connection | gbk                                  |</span><br><span class="line">| character_set_database   | utf8mb4                              |</span><br><span class="line">| character_set_filesystem | binary                               |</span><br><span class="line">| character_set_results    | gbk                                  |</span><br><span class="line">| character_set_server     | utf8mb4                              |</span><br><span class="line">| character_set_system     | utf8mb3                              |</span><br><span class="line">| character_sets_dir       | C:\Program Files\MySQL\MySQL Server  |</span><br><span class="line">                             8.0\share\charsets\                  |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br></pre></td></tr></table></figure><p>我们要做的是<strong>把所有不是 utf8 的字符集全部改成 utf8</strong> 除了 binary 和那行路径。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> character_set_client <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_database <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_results <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_server <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">SET</span> character_set_system <span class="operator">=</span> &quot;utf8&quot;;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>最后得出结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| Variable_name            | Value                                |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br><span class="line">| character_set_client     | utf8mb3                              |</span><br><span class="line">| character_set_connection | utf8mb3                              |</span><br><span class="line">| character_set_database   | utf8mb3                              |</span><br><span class="line">| character_set_filesystem | binary                               |</span><br><span class="line">| character_set_results    | utf8mb3                              |</span><br><span class="line">| character_set_server     | utf8mb3                              |</span><br><span class="line">| character_set_system     | utf8mb3                              |</span><br><span class="line">| character_sets_dir       | C:\Program Files\MySQL\MySQL Server  |</span><br><span class="line">                             8.0\share\charsets\                  |</span><br><span class="line">+--------------------------+--------------------------------------+</span><br></pre></td></tr></table></figure><p>最后，在 <strong>每次的 doGet 或者 doPost（反正你要操作数据库的时候）</strong> 在函数开始加上以下两行代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="JAVA-JDBC-编程"><a href="#JAVA-JDBC-编程" class="headerlink" title="JAVA JDBC 编程"></a>JAVA JDBC 编程</h2><p>JDBC 数据库操作的步骤，在 doGet 或 doPost 方法写上以下代码</p><h3 id="1-注册驱动程序"><a href="#1-注册驱动程序" class="headerlink" title="1. 注册驱动程序"></a>1. 注册驱动程序</h3><blockquote><p>加载待连接数据库的驱动到 JVM 里</p></blockquote><p>先下载驱动 <a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a> ，在这个链接中，下拉框选择 Platform Independent，然后选择 <code>Platform Independent (Architecture Independent), ZIP Archive</code> 下载</p><p>解压之后，找到 <code>mysql-connector-java-8.0.26.jar</code> 包，把这个包拖到我们的项目中 <code>src/main/webapp/WEB-INF/lib</code> 文件夹里</p><p>写上注册驱动程序的代码，Class.forName 方法需要 try catch 代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>; <span class="comment">// MySQL 8.0 要加上 cj</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driver);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h3><p>DriverManager.getConnection 方法需要 try catch 代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>; <span class="comment">// 被起来吧，最后是数据库名</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 数据库链接，数据库用户名，密码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 Connection 的时候，使用代码提示导入 <code>java.sql.Connection</code> 包，DriverManager 要导入 <code>java.sql.DriverManager</code> 包。</p><h3 id="3-创建-PreparedStatement-对象（预处理-SQL-语句）"><a href="#3-创建-PreparedStatement-对象（预处理-SQL-语句）" class="headerlink" title="3. 创建 PreparedStatement 对象（预处理 SQL 语句）"></a>3. 创建 PreparedStatement 对象（预处理 SQL 语句）</h3><p>PreparedStatement 一样需要导入 <code>java.sql.PreparedStatement</code> 包</p><blockquote><p>因为 conn 变量的作用域在 try catch 代码块里，所以我们将第三步放在第二步的 try catch 代码块里执行<br>然后我们要在 doGet 或者 doPost 函数的最外层给它声明一个 String sql = “”; 用来存放我们的 SQL 语句。这个语句的作用域在整个函数中。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>; <span class="comment">// 被起来吧，最后是数据库名</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 数据库链接，数据库用户名，密码</span></span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-执行查询"><a href="#4-执行查询" class="headerlink" title="4. 执行查询"></a>4. 执行查询</h3><blockquote><p>这不是个固定写法，分为查询和增删改两个不同的操作<br>第四步也需要放在第二步的 try catch 代码块里执行</p></blockquote><h4 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h4><p>executeUpdate() 函数，返回值类型：返回数据库受影响行数，0 = 失败，非 0 = 成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>; <span class="comment">// 被起来吧，最后是数据库名</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>); <span class="comment">// 数据库链接，数据库用户名，密码</span></span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>executeQuery() 函数，返回值类型 ResultSet 结果集，需要导包。它是数据集对象，代表查询的结果。rs.next() true 代表成功，false 代表失败</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-结果处理"><a href="#5-结果处理" class="headerlink" title="5. 结果处理"></a>5. 结果处理</h3><blockquote><p>因情况而异</p></blockquote><h4 id="增删改-1"><a href="#增删改-1" class="headerlink" title="增删改"></a>增删改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 操作成功</span></span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，注册成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 操作失败</span></span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，注册失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p>rs.next() 表示指向下一个。指针的概念，将他的光标指向下一行数据。从查询结果的第 0 行开始。所以第一次调用 next，会指向第一行数据。</p><p>如果第一行有数据，则返回 true。通常用这个特性来判断是否查询成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，登录成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-关闭链接释放资源"><a href="#6-关闭链接释放资源" class="headerlink" title="6. 关闭链接释放资源"></a>6. 关闭链接释放资源</h3><blockquote><p>先开后关<br>Java 也有 Garbage Collection 垃圾回收机制，但是只有在内存不够的时候，虚拟机才会去回收</p></blockquote><h4 id="增删改-2"><a href="#增删改-2" class="headerlink" title="增删改"></a>增删改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 操作成功</span></span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，注册成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 操作失败</span></span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，注册失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h4><p>ResultSet 集合需要关闭以释放资源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/session1&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，登录成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter.append(<span class="string">&quot;亲，登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close</span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 5 Servlet 入门</title>
      <link href="/2021/72adb8f7.html"/>
      <url>/2021/72adb8f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>这段视频没有声音，我大概猜测一下</p></blockquote><p>在 src / main / java 目录下创建一个 Servlet。名字随意</p><p>里面的代码应该如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tootaio.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/LoginServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">response.getWriter().append(<span class="string">&quot;Served at: &quot;</span>).append(request.getContextPath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，<code>@WebServlet()</code> 是当前 servlet 的路径（网址路径）</p><p>doGet 是获取 HttpGet 时该怎么处理</p><p>doPost 是遇到 HttpPost 时该怎么处理</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 4 隐含对象</title>
      <link href="/2021/2f28c290.html"/>
      <url>/2021/2f28c290.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h2><p>首先我们在 login.jsp 中写上：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;userLogin.jsp&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>邮箱：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="getParameter-函数"><a href="#getParameter-函数" class="headerlink" title="getParameter 函数"></a>getParameter 函数</h3><p>用于获取 HTTP GET / POST 的参数</p><p>然后在 userLogin.jsp 中写上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;您好，你刚才输入的邮箱是：&lt;%= request.getParameter(<span class="string">&quot;email&quot;</span>) %&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;密码是：&lt;%= request.getParameter(<span class="string">&quot;password&quot;</span>) %&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>或者可以用另一种输出方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">您好，你刚才输入的邮箱是：</span><br><span class="line">&lt;%=</span><br><span class="line"><span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">out.print(email);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">密码是：</span><br><span class="line">&lt;%=</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">out.print(password);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="getAttributes-函数"><a href="#getAttributes-函数" class="headerlink" title="getAttributes 函数"></a>getAttributes 函数</h3><p>首先我们需要给他保存属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;% request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;小麦&quot;</span>); %&gt;</span><br></pre></td></tr></table></figure><p>获取所保存的属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%= request.getAttribute(<span class="string">&quot;msg&quot;</span>) %&gt;</span><br></pre></td></tr></table></figure><p>其中，msg 是属性的 key 唯一标识符。</p><h2 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h2><p>可以用来做页面跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;目标页面&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;目标页面&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>第一种可以将当前的 request 和 response 对象带过去，所以 request.setAttributes 所保存的数据是仅限于 request 对象里。如果直接调用 response.sendRedirect(“”)，那么新页面的 request 对象又是全新的。</p><h2 id="Session-对象"><a href="#Session-对象" class="headerlink" title="Session 对象"></a>Session 对象</h2><p>session 可以替代 request，作用域比 request 还大。他是当前对话都有效。也就是如果你没有把浏览器关掉，那么他就一直存在。</p><p>举个栗子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;小麦&quot;</span>);</span><br><span class="line">session.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;秃头&quot;</span>);</span><br><span class="line"></span><br><span class="line">response.sendRedirect(<span class="string">&quot;welcome.jsp&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 welcome.jsp 里，我们调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getAttribute(<span class="string">&quot;msg&quot;</span>);</span><br><span class="line">session.getAttribute(<span class="string">&quot;msg&quot;</span>);</span><br></pre></td></tr></table></figure><p>那么我们会发现，只有 session 那一段才会有值，request 对象是 null。</p><p>甚至我们在另一个页面 hello.jsp 调用 session.getAttribute(“msg”)，他也能获取到这个值。</p><h2 id="Exception-对象"><a href="#Exception-对象" class="headerlink" title="Exception 对象"></a>Exception 对象</h2><p>假设有个页面出错了，且他的错误跳转为 error.jsp，那么我们可以在 error.jsp 里写上：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>页面出错啦！<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>错误信息为：&lt;%= exception.getMessage() %&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>exception 对象保存了当前异常中的所有信息</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 3 友好页面</title>
      <link href="/2021/a5fd522b.html"/>
      <url>/2021/a5fd522b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 WEB-INF 文件下右键 New &gt; Other 搜寻 XML</p><p>然后找到 XML File</p><p>文件名一定要叫 web.xml</p><hr><p>通过点击项目名，然后找到 Java EE Tools &gt; Generate Deployment Descriptor Stubs。等一段时间</p><p>Eclipse 会在 src / main / webapp / WEB-INF 目录下生成一个 web.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee; http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>FriendlyPages<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，我们需要在 web-app 标签的 xsi:schemaLocation=”” 属性中的两个地址中央插入一个 “;”，否则默认会报错</p><p>最后在 web-app 标签之中插入你所需要的错误页面所指向的页面</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee; http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>FriendlyPages<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/errorpage/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">location</span>&gt;</span>/errorpage/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb 笔记 2 导出导入 JavaWeb 项目</title>
      <link href="/2021/cbcca323.html"/>
      <url>/2021/cbcca323.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="导出项目"><a href="#导出项目" class="headerlink" title="导出项目"></a>导出项目</h2><p>在项目名称点击右键，点击 Export &gt; WAR</p><p>项目名千万别改，只需要确定导出位置。</p><p>可以在导出之后，修改 .war 文件的项目名</p><h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><p>首先确保该项目有没有 SQL 文件，有的话先导入进数据库。</p><p>打开 Eclipse，在 Project Explorer 的空白位置点击右键，Import &gt; Import</p><p>选择 General &gt; Existing Projects into Workspace，然后点击 Next</p><p>选择我们需要导入的项目目录，然后点击 Finish</p><p>然后右键修改他的 Build Path，将 JRE 和 Server Runtime 改为现有工作空间的配置。</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>作业 1 JSP 错误页面</title>
      <link href="/2021/85e468ff.html"/>
      <url>/2021/85e468ff.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>首先创建一个错误页面 error.jsp</p><p>在它的第一行加上 <code>isErrorPage=&quot;true&quot;</code>，将其声明为错误页面</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> isErrorPage=<span class="string">&quot;true&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><p>然后在会出错的页面上的第一行加上 <code>errorPage=&quot;error.jsp&quot;</code>，将其错误页面指向 error.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> errorPage=<span class="string">&quot;error.jsp&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JSP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记 1 JSP 语法</title>
      <link href="/2021/f2a02888.html"/>
      <url>/2021/f2a02888.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="脚本程序"><a href="#脚本程序" class="headerlink" title="脚本程序"></a>脚本程序</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">// 这是个代码片段</span></span><br><span class="line"><span class="comment">// 第一行代码</span></span><br><span class="line"><span class="comment">// 第二行代码</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%! <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> %&gt;</span><br><span class="line">&lt;%! <span class="type">int</span> a, b, c; %&gt;</span><br><span class="line">&lt;%! <span class="type">Circle</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2.0</span>); %&gt;</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">今天的日期是: &lt;%= (<span class="keyword">new</span> <span class="title class_">java</span>.util.Date()).toLocaleString()%&gt;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%-- 该部分注释在网页中不会被显示--%&gt;</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page ... %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</span><br><span class="line">&lt;%@ include ... %&gt; 包含其他文件</span><br><span class="line">&lt;%@ taglib ... %&gt; 引入标签库的定义，可以是自定义标签</span><br></pre></td></tr></table></figure><h3 id="隐含对象"><a href="#隐含对象" class="headerlink" title="隐含对象"></a>隐含对象</h3><ol><li>request</li><li>response</li><li>out</li><li>session</li><li>application</li><li>config</li><li>pageContext</li><li>page</li><li>exception</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JSP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 安装教学</title>
      <link href="/2021/a157bd5a.html"/>
      <url>/2021/a157bd5a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>下载地址 <a href="https://dev.mysql.com/downloads/windows/installer/8.0.html">https://dev.mysql.com/downloads/windows/installer/8.0.html</a></p><p>有两个下载按钮，如果网线好可以选择 2M 的那个在线安装包。然后点击 No thanks, just start my download</p><p>打开安装包之后，</p><ol><li>选择 Developer default</li><li>Python 可以忽略，他会给你个提示框，点击 Continue 就行</li><li>然后显示需要下载的 MySQL 软件列表，点击 Execute，等待下载</li><li>下载完毕之后，点击 Next，然后点击 Install，等待安装</li><li>安装完毕之后，点击 Next</li><li>接下来都是 Next，直到要你输入密码</li><li>然后也是一直 Next、Execute、Finish……</li><li>最后让你检查你的服务器是否正常操作，输入密码检查就行了</li><li>然后点击 Execute</li><li>安装完毕之后，会自动打开 MySQL Workbench</li><li>这玩意跟 Navicat 一样，只不过是 MySQL 自带的，比较靠谱。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 和 Tomcat 配置教学</title>
      <link href="/2021/625eb75e.html"/>
      <url>/2021/625eb75e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>编译器：eclipse IDE 2021-09<br>JDK：jdk1.8.0_301<br>Tomcat：9.0.53</p><h2 id="配置-TomCat-服务器"><a href="#配置-TomCat-服务器" class="headerlink" title="配置 TomCat 服务器"></a>配置 TomCat 服务器</h2><p>到 <a href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html</a> 下载 Java JDK</p><blockquote><p>选择自己的版本，如大部分同学的 Windows 64 位架构就选 <code>Windows x64</code></p></blockquote><p>安装之后添加上环境变量</p><ol><li>在环境变量中加上 <code>JAVA_HOME</code>，值是 Java JDK 的安装目录 <code>C:\Program Files\Java\jdk1.8.0_301</code></li><li>在 Path 里加上 <code>%JAVA_HOME%\bin</code> 和 <code>%JAVA_HOME\jre</code></li></ol><p>到 <a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a> 下载 Tomcat，直接解压到 C 盘目录下</p><h2 id="配置-Eclipse"><a href="#配置-Eclipse" class="headerlink" title="配置 Eclipse"></a>配置 Eclipse</h2><p>创建一个工作环境，先不用创建项目</p><p>在菜单栏点击 Window &gt; Preferences 以下操作都在这个界面完成</p><h3 id="先配置-Java"><a href="#先配置-Java" class="headerlink" title="先配置 Java"></a>先配置 Java</h3><p>找到 Java &gt; Installed JREs，点击 Add 按钮，选择 Standard VM</p><p>JRE home 选择我们安装的 Java 路径，1.8 版本的 JDK 通常为：<code>C:\Program Files\Java\jdk1.8.0_301</code></p><p>然后点击 Finish，再勾选我们新建的 JDK</p><h3 id="再配置-Tomcat-运行时"><a href="#再配置-Tomcat-运行时" class="headerlink" title="再配置 Tomcat 运行时"></a>再配置 Tomcat 运行时</h3><p>找到 Server &gt; Runtime Environments，点击 Add 按钮，选择所需的版本，我们选择的是 Tomcat 9.0</p><p>点击 Next，在 Tomcat installation directory 中找到我们下载的 Tomcat 目录（刚刚我们放到 C 盘根目录下）<code>C:\Softwares\apache-tomcat-9.0.53</code></p><p>然后点击 Finish</p><h3 id="还有中文乱码"><a href="#还有中文乱码" class="headerlink" title="还有中文乱码"></a>还有中文乱码</h3><p>在上面搜 encoding 然后找到 General &gt; Workspace。找到左下角的 Text file encoding，改为 UTF-8</p><p>另外继续找这三个：</p><ol><li>Web &gt; CSS Files</li><li>Web &gt; HTML Files</li><li>Web &gt; JSP Files</li><li>如果 XML 也要的话，顺便咯，反正是一样的</li></ol><p>然后找到右边的 Encoding 下拉菜单，选择第一个 ISO 10646 / Unicode(UTF-8)</p><h3 id="顺便解决汉字太小"><a href="#顺便解决汉字太小" class="headerlink" title="顺便解决汉字太小"></a>顺便解决汉字太小</h3><p>先下载替代字体 <a href="https://github.com/microsoft/cascadia-code/releases">https://github.com/microsoft/cascadia-code/releases</a> 下载解压缩之后，里面有很多个字体，全选右键安装。</p><p>找到 General &gt; Appearance &gt; Colors and Fonts，然后在右侧的列表中找 Basic &gt; Text Editor Block Selection Font 和 Text Font</p><p>把里面的都改成 Cascadia Code, Regular, 10。字体要大一点也行</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>简单一点，CTRL + N（File &gt; New &gt; Other），找到 Web &gt; Dynamic Web Project</p><p>项目名随意，注意看 Target runtime 是不是我们配置好的 Tomcat 版本。然后点击 Finish</p>]]></content>
      
      
      <categories>
          
          <category> 系列 </category>
          
          <category> 编程语言 </category>
          
          <category> JavaWeb 学习笔记 </category>
          
          <category> Java JavaWeb </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React 笔记</title>
      <link href="/2020/e6dac0f2.html"/>
      <url>/2020/e6dac0f2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>善于提取组件，把组件拆分成更小的组件</p><p><code>props</code> 只读。</p><p>不要直接修改 <code>state</code> ，应该调用 <code>this.setState()</code><br>否则不会重新渲染组件。</p><p>构造函数是唯一可以给 <code>this.state</code> 赋值的地方</p><p><code>state</code> 的更新可能是异步的<br>出于性能考虑，React 可能会把多个 <code>setState()</code> 调用合并成一个调用。<br>因为 <code>this.props</code> 和 <code>this.state</code> 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。<br>让 <code>setState()</code> 接收一个函数而不是一个对象。这个函数用上一个 <code>state</code> 作为第一个参数，将此次更新被应用时的 <code>props</code> 做为第二个参数</p><p><code>state</code> 的更新会被合并</p><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。<br>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。<br>在 React 中另一个不同点是你不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code> 。</p><p><code>class</code> 的方法默认不会绑定 <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p><p>推荐使用 <code>class field</code> 语法或者 <code>bind</code> 语法<br>用箭头函数 <code>onClick=&#123;() =&gt; &#123;&#125;&#125;</code> 会导致性能问题</p><p>在 JavaScript 中，<code>true &amp;&amp; expression</code> 总是会返回 <code>expression</code>, 而 <code>false &amp;&amp; expression</code> 总是会返回 <code>false</code>。<br>返回 <code>false</code> 的表达式会使 <code>&amp;&amp;</code> 后面的元素被跳过，但会返回 <code>false</code> 表达式。</p><p>让 <code>render</code> 方法直接返回 <code>null</code>，而不进行任何渲染。</p><p><code>key</code> 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。<br>一个元素的 <code>key</code> 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 <code>id</code> 来作为元素的 <code>key</code><br>当元素没有确定 <code>id</code> 的时候，万不得已你可以使用元素索引 <code>index</code> 作为 <code>key</code><br>如果列表项目的顺序可能会变化，我们不建议使用索引来用作 <code>key</code> 值，因为这样做会导致性能变差，还可能引起组件状态的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> JavaScript React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 命名规范</title>
      <link href="/2020/60cf182d.html"/>
      <url>/2020/60cf182d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="包名-package"><a href="#包名-package" class="headerlink" title="包名 package"></a>包名 package</h2><ol><li>包名全小写</li><li>Java 包名格式为：<code>域名.公司名.项目名.模块名</code>。<ol><li>假设：航空管理系统的 servlet 模块，那么包名就是：<code>com.tootaio.sunshineairline.servlet</code>。</li></ol></li><li>包名通常是这个世界上独一无二的，所以大部分情况下，很多公司都会把它们的域名（公司网站）反过来写：<code>edu.tsinghua.project.package</code></li></ol><h2 id="类名-Class"><a href="#类名-Class" class="headerlink" title="类名 Class"></a>类名 Class</h2><ol><li>类名采用大驼峰式：<code>HelloWorld</code></li><li>中间不需要空格、下划线</li><li>类名必须与它的文件名相同<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello.java 文件名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123; <span class="comment">// 类名必须和文件名一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法名-methodName"><a href="#方法名-methodName" class="headerlink" title="方法名 methodName"></a>方法名 methodName</h2><ol><li>小驼峰方式命名：<code>helloWorld</code></li></ol><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><ol><li>小驼峰方式命名，和方法名相同</li><li>编程命名最重要的思想：简单、见字知意</li></ol><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><ol><li>采用全部大写，单词之间用下划线分开</li></ol><h2 id="命名原则"><a href="#命名原则" class="headerlink" title="命名原则"></a>命名原则</h2><ol><li>名称只能由字母、数字、下划线、$符号等组成,，但不能以数字开头。</li><li>名称不能使用JAVA中的关键字，比如 char、 double、if、for、class。</li><li>不允许使用中文及拼音命名（如果你想被打，可以试试）<ol><li>shazi<ol><li>傻子</li><li>沙子</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集训 Wamp 环境讲解第 2 版</title>
      <link href="/2020/5ccac489.html"/>
      <url>/2020/5ccac489.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#20200530-版本与主机声明">20200530 版本与主机声明</a></li><li><a href="#20200531-安装步骤">20200531 安装步骤</a></li><li><a href="#20200530-wamp-自带插件">20200530 wamp 自带插件</a><ul><li><a href="#mysql--mariadb">MySQL / MariaDB</a></li><li><a href="#apache">Apache</a></li><li><a href="#php">PHP</a></li></ul></li><li><a href="#20200530-wamp-插件更新办法">20200530 wamp 插件更新办法</a></li><li><a href="#20200530-wamp-纠错">20200530 wamp 纠错</a><ul><li><a href="#图标橘色">图标橘色</a></li></ul></li><li><a href="#20200530-mariadb--mysql-主要数据库-dbms-的切换-20200531-更新注意事项">20200530 MariaDB &lt;-&gt; MySQL 主要数据库 (DBMS) 的切换 （20200531 更新注意事项）</a></li><li><a href="#20200531-创建与删除-virtualhost">20200531 创建与删除 VirtualHost</a></li><li><a href="#20200531-外部设备访问">20200531 外部设备访问</a><ul><li><a href="#步骤">步骤</a></li><li><a href="#纠错">纠错</a></li></ul></li></ul><h2 id="本次-wamp-安装日期：-2019年5月29日"><a href="#本次-wamp-安装日期：-2019年5月29日" class="headerlink" title="本次 wamp 安装日期： 2019年5月29日"></a>本次 wamp 安装日期： 2019年5月29日</h2><ul><li>安装版本<ul><li>WampServer 3.2.0 -&gt; 3.2.2</li><li>PHP 7.3.12 -&gt; 7.4.6</li><li>MySQL 0 (NULL) -&gt; MySQL 8.0</li><li>MariaDB 10.4.10</li></ul></li><li>主机<ul><li>系统版本：Win 10 Home Single Language</li><li>处理器：英特尔 酷睿 i5-8265U CPU @ 1.60GHz 1.80GHz</li><li>RAM： 12G</li><li>系统类型：64 位操作系统</li></ul></li></ul><h2 id="20200531-更新"><a href="#20200531-更新" class="headerlink" title="20200531 更新"></a>20200531 更新</h2><ul><li><p>安装</p><ul><li>从 <a href="http://wampserver.aviatechno.net/">http://wampserver.aviatechno.net/</a> 下载 （我的是 64位 操作系统）</li><li>Wampserver 3.2.0 64 bit x64 - Apache 2.4.41 - PHP 5.6.40/7.3.12/7.4.0 - MariaDB 10.4.10|10.3.20</li><li>双击运行 wampserver3.2.0_x64.exe 进行安装</li><li>一直点下一步（不要调任何东西）</li><li>后面会让你选择默认浏览器，选择 chrome 安装目录：[通常在：”C:\Program Files (x86)\Google\Chrome\Application\chrome.exe”]</li><li>再来选择默认文本打开工具，我选的 VScode：[通常在：”C:\Users\用户名\AppData\Local\Programs\Microsoft VS Code\Code.exe”]</li><li>第一次运行可能会出错（wamp 小图标不会变绿色）：[退出重启 wamp 即可]</li></ul></li><li><p>安装wamp的时候不要选择任何附带的产品（如 MySQL5.7，MySQL8.0）</p><ul><li>wamp的插件位置（默认）：C:\wamp64\bin</li><li>wampserver会自带一个 MariaDB 数据库，默认端口是 3306<ul><li>MariaDB的默认数据库用户名是：root，密码是：【空的】</li><li>这会导致我们的原有的 MySQL5.5 数据库的端口被占用<ul><li>打开 navicat，会发现就有的数据库都没了，这是正常的。</li><li>旧的数据库都还在，只不过因为服务被 MariaDB 占用了，MariaDB 是不会继承旧有数据库的</li></ul></li></ul></li><li>wampserver会自带PHP版本有三个<ul><li>5.6.40 - 旧版本是 wampserver 客户端CLI的运行环境，不能删除</li><li>7.3.12 - 这里可以切换，左键任务栏的 wamp 的图标，然后选择 PHP 第一个 version</li><li>7.4.0</li><li>切换版本之后需要刷新 wamp：右键任务栏的 wamp 的图标，然后 restart</li></ul></li><li>wampserver会自带 apache<ul><li>2.4.41 版本</li></ul></li><li>以上我说的插件 addon 都能更新：到 <a href="http://wampserver.aviatechno.net/">http://wampserver.aviatechno.net/</a> 有作者提供的包<ul><li>在下面 Addons Wampserver 3 的版块里<ul><li>谨慎更新，毕竟版本换了，旧有的一些 ini 文件里还是保存旧的</li><li>所以会导致 service（服务关闭不干净）的后果，但是无伤大雅：[只不过你以后就可以不用打开 wamp 主程序 就能直接打开 localhost 了]</li></ul></li><li>在更新之前，要先更新 wamp server 到 3.2.2 版本：[更新包位置就在 Updates 板块，有个 Wampserver update 3.2.2 的下载包]</li><li>然后再从 Addons 点击你想要的版本进行下载<ul><li>一般不建议胡乱更新，因为新版本通常在修 bug 会产生新 bug</li><li>下载 MySQL 的话，他会使用你的 3308 的端口<ul><li>可以将 MySQL 设置为主要数据库 (DBMS)<ul><li>但是不建议这么做</li></ul></li></ul></li></ul></li></ul></li><li>关于 PHP 插件：<ul><li>你打开 localhost 之后，会发现有个板块<ul><li>Loaded Extensions</li><li>这里都是 PHP 的插件，当你安装新的版本的时候，有时候会缺少插件<ul><li>左键 wamp 小图标，单击 PHP， 单击 PHP extensions，然后就会让你选择激活 PHP 的插件</li></ul></li></ul></li></ul></li></ul></li><li><p>更新之后，最保险的方法</p><ul><li>在关闭电脑之前，右键 wamp 的小图标，exit 退出 wamp</li></ul></li><li><p>wamp 的几个纠错</p><ul><li>开机后，打开 wamp 图标是橙色的，能够打开 localhost，但是不能访问数据库<ul><li>对于集训的同学最直接的就是：wordpress 不能正常打开<ul><li>Win键 + R，输入： service.msc 打开服务菜单</li><li>找到 MySQL 服务，右键停止这个服务</li><li>重启 wamp 就回复正常了</li></ul></li></ul></li></ul></li><li><p>MariaDB &lt;-&gt; MySQL 主要数据库 (DBMS) 的切换</p><ul><li>首先确保你已经在 wamp 安装了 MySQL 和 MariaDB</li><li>正常情况下<ul><li>主端口为：3306</li><li>MariaDB 为主，MySQL 端口就在3308</li><li>MySQL 为主，MariaDB 端口就在3307</li></ul></li><li>重要<ul><li>先到 PHPmyAdmin <a href="http://localhost/phpmyadmin/">http://localhost/phpmyadmin/</a> 导出原有的数据库</li><li>登录 MariaDB / MySQL 数据库之后，最上面一排控制栏点击 Export</li><li>选择 Quick，Format = SQL</li><li>然后 右下角的 GO</li><li>这时候到下载（download）文件夹里，就会存在一个 127_0_0_1.sql 文件，这时候就是导出成功了</li><li>切换之后，回到 PHPmyAdmin</li><li>登录 MySQL / MariaDB 数据库之后，点击 Import</li><li>Choose File 选择 127_0_0_1.sql 文件</li><li>直接点 GO</li><li>切换主要服务器，只需要<ul><li>右键 wamp 的小图标，单击 Tools，在 Default DBMS 那块点击 Invert…</li><li>重启 wamp 就行</li></ul></li></ul></li><li>任何修改，都要重启 wamp 以防万一</li></ul></li></ul><h2 id="20200531-更新-1"><a href="#20200531-更新-1" class="headerlink" title="20200531 更新"></a>20200531 更新</h2><ul><li><p>创建 virtual host</p><ul><li>在 localhost 或者 127.0.0.1 左下角找到 Add a virtual host</li><li>在 Name of the Virtual Host 输入任意你想要的名字（不能有空格和下划线），大写会变成小写</li><li>在 Complete absolute path of the VirtualHost folder 输入绝对路径</li><li>【可选】If you want to use VirtualHost by IP 输入你想要有的本地 IP</li><li>最后，右键 wamp 小图标，restart</li><li>例如：<ul><li>test-helloWorld</li><li>C:/wamp64/www/SunshineAirlines-mobile</li><li>127.0.0.8</li></ul></li><li>那么我访问的话可以通过这几种方式访问<ul><li>localhost/SunshineAirlines-mobile</li><li>127.0.0.1/SunshineAirlines-mobile</li><li>test-helloworld/</li><li>127.0.0.8</li></ul></li></ul></li><li><p>删除 virtual host</p><ul><li>在 localhost 或者 127.0.0.1 左下角找到 Add a virtual host</li><li>右边有个 suppress VirtualHost form 按钮</li><li>勾选你要删除的 ServerName</li><li>完了之后点击 Supress VirtualHost</li></ul></li><li><p>外部访问</p><ul><li>前提：主机与需要访问主机的设备在同一局域网下</li><li>访问步骤<ul><li>主机电脑 win键 + R，输入：cmd</li><li>在命令提示符(cmd)里输入 ipconfig</li><li>找到：IPv4 Address. . . . . . . . . . . : 192.168.1.1</li><li>在需要访问主机的设备的浏览器输入框里输入这个 IP 地址</li><li>这时候就会出现 wamp 的界面了</li></ul></li><li>报错<ul><li>同一局域网下，输入 IP 地址后，仍无法访问<ul><li>在主机任务栏的无线连接小图标点击</li><li>点击《网络与 Internet 设置 || Network and Internet settings》</li><li>点击《更改连接属性 || Change connection propertise》</li><li>选择《专用 || Private》</li><li>刷新需要访问主机的设备的浏览器</li></ul></li><li>没有权限访问：403 Forbidden<ul><li>前提：本机通过127.0.0.1和localhost都可以正常访问</li><li>自wamp 3开始，localhost 被定义为 virtual host，我们需要修改 httpd-vhosts.conf 文件来修改相关的行为。<ul><li>首先创建 virtual host<ul><li>上边有 virtual host 的创建方法</li></ul></li><li>左键 wamp，鼠标悬浮 Apache，点击 httpd-vhosts.conf</li><li>这时候会跳出文本编辑器<ul><li>如果是 VScode<ul><li>ctrl + F 搜索 Require local</li></ul></li><li>如果是 Notepad || Notepad++<ul><li>ctrl + H 搜索 Require local</li></ul></li><li>全部替换为 Require all granted</li></ul></li><li>左键 wamp，鼠标悬浮 Apache，<ul><li>悬浮 Service admin…</li><li>restart service</li></ul></li><li>局域网内其他主机通过IP访问成功</li><li>参考：<a href="https://blog.csdn.net/yang5726685/article/details/79359803">https://blog.csdn.net/yang5726685/article/details/79359803</a></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 笔记</title>
      <link href="/2020/61622d0e.html"/>
      <url>/2020/61622d0e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>以下是您提供的JavaScript代码片段和建议的Markdown格式：</p><h3 id="两数之间的随机数"><a href="#两数之间的随机数" class="headerlink" title="两数之间的随机数"></a>两数之间的随机数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min;</span><br></pre></td></tr></table></figure><h3 id="两数之间的随机整数"><a href="#两数之间的随机整数" class="headerlink" title="两数之间的随机整数"></a>两数之间的随机整数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min)) + min; <span class="comment">// 不含最大值，含最小值</span></span><br></pre></td></tr></table></figure><h3 id="两数之间的随机整数，包括两个数在内"><a href="#两数之间的随机整数，包括两个数在内" class="headerlink" title="两数之间的随机整数，包括两个数在内"></a>两数之间的随机整数，包括两个数在内</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (<span class="number">100</span> - <span class="number">10</span> + <span class="number">1</span>)) + <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="可以输出的地方（部分常用的）"><a href="#可以输出的地方（部分常用的）" class="headerlink" title="可以输出的地方（部分常用的）"></a>可以输出的地方（部分常用的）</h3><ul><li><code>document.body.innerHTML</code></li><li><code>document.write();</code></li></ul><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符 ?:"></a>三目运算符 <code>?:</code></h3><p>判断表达式 ? 真 : 假</p><h3 id="prompt输入数字一定要"><a href="#prompt输入数字一定要" class="headerlink" title="prompt输入数字一定要"></a>prompt输入数字一定要</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="title function_">prompt</span>());</span><br></pre></td></tr></table></figure><h3 id="空格转义字符"><a href="#空格转义字符" class="headerlink" title="空格转义字符"></a>空格转义字符</h3><ul><li><code>&amp;nbsp;</code></li></ul><h3 id="全方大的空白"><a href="#全方大的空白" class="headerlink" title="全方大的空白"></a>全方大的空白</h3><ul><li><code>&amp;emsp;</code></li></ul><h3 id="半方大的空白"><a href="#半方大的空白" class="headerlink" title="半方大的空白"></a>半方大的空白</h3><ul><li><code>&amp;ensp;</code></li></ul><h3 id="Date-获取月份一定要-1"><a href="#Date-获取月份一定要-1" class="headerlink" title="Date() 获取月份一定要 +1"></a>Date() 获取月份一定要 +1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data.<span class="title function_">getMonth</span>() + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="时间小于10输出0"><a href="#时间小于10输出0" class="headerlink" title="时间小于10输出0"></a>时间小于10输出0</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">var</span> hour = date.<span class="title function_">getHours</span>() &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + date.<span class="title function_">getHours</span>(): date.<span class="title function_">getHours</span>();</span><br><span class="line"><span class="keyword">var</span> minute = date.<span class="title function_">getMinutes</span>() &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + date.<span class="title function_">getMinutes</span>() : date.<span class="title function_">getMinutes</span>();</span><br><span class="line"><span class="keyword">var</span> second = date.<span class="title function_">getSeconds</span>() &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + date.<span class="title function_">getSeconds</span>() : date.<span class="title function_">getSeconds</span>();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
